{
  "id": "powershell-azure-best-practices",
  "title": "PowerShell Azure Integration Best Practices",
  "body": "Best practices for PowerShell scripts that interact with Azure services, including error handling and network considerations:\n\n**Azure PowerShell Module Selection:**\n```powershell\n# Use Az modules (recommended)\nInstall-Module Az -Force -AllowClobber\nImport-Module Az.Accounts, Az.Resources, Az.KeyVault\n\n# Avoid mixing Az and AzureRM modules\n# Uninstall AzureRM if present\nUninstall-AzureRm\n```\n\n**Authentication Patterns:**\n```powershell\n# Service Principal authentication (recommended for automation)\n$credential = Get-Credential\nConnect-AzAccount -ServicePrincipal -Credential $credential -Tenant $tenantId\n\n# Managed Identity (for Azure resources)\nConnect-AzAccount -Identity\n\n# Certificate-based authentication\n$cert = Get-ChildItem Cert:\\CurrentUser\\My\\$thumbprint\nConnect-AzAccount -ServicePrincipal -Certificate $cert -ApplicationId $appId -Tenant $tenantId\n```\n\n**Error Handling for Azure Operations:**\n```powershell\nfunction Initialize-AzureContext {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)]\n        [string]$SubscriptionId,\n        \n        [switch]$EnablePublicAccess\n    )\n    \n    try {\n        # Set context with error handling\n        $context = Set-AzContext -SubscriptionId $SubscriptionId -ErrorAction Stop\n        Write-Information \"Azure context set to subscription: $($context.Subscription.Name)\" -InformationAction Continue\n        \n        return $context\n    }\n    catch [Microsoft.Azure.Commands.Profile.Errors.AzPSCloudException] {\n        Write-Error \"Failed to authenticate to Azure: $($_.Exception.Message)\"\n        throw\n    }\n    catch [Microsoft.Azure.Commands.Common.Exceptions.AzPSResourceNotFoundCloudException] {\n        Write-Error \"Subscription not found or access denied: $SubscriptionId\"\n        throw  \n    }\n    catch {\n        Write-Error \"Unexpected error setting Azure context: $($_.Exception.Message)\"\n        throw\n    }\n}\n```\n\n**Key Vault Operations with Network Access Handling:**\n```powershell\nfunction Get-KeyVaultSecret {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)]\n        [string]$VaultName,\n        \n        [Parameter(Mandatory)]\n        [string]$SecretName,\n        \n        [switch]$EnablePublicAccess\n    )\n    \n    try {\n        $secret = Get-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -ErrorAction Stop\n        return $secret\n    }\n    catch [Microsoft.Azure.KeyVault.Models.KeyVaultErrorException] {\n        $errorCode = $_.Exception.Body.Error.Code\n        \n        if ($errorCode -eq 'Forbidden' -and $_.Exception.Message -like '*public network access is disabled*') {\n            Write-Warning \"Key Vault '$VaultName' has public network access disabled.\"\n            \n            if ($EnablePublicAccess) {\n                Write-Information \"Attempting to enable public access...\" -InformationAction Continue\n                \n                try {\n                    Update-AzKeyVault -VaultName $VaultName -PublicNetworkAccess \"Enabled\" -ErrorAction Stop\n                    Write-Information \"Public access enabled. Retrying secret retrieval...\" -InformationAction Continue\n                    \n                    # Retry the operation\n                    Start-Sleep -Seconds 2\n                    $secret = Get-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -ErrorAction Stop\n                    return $secret\n                }\n                catch {\n                    Write-Error \"Failed to enable public access: $($_.Exception.Message)\"\n                    throw\n                }\n            } else {\n                $message = @\"\nTo resolve this issue, either:\n1. Use -EnablePublicAccess switch to temporarily enable public access\n2. Run this script from a network with access to the Key Vault\n3. Configure Key Vault firewall rules to allow your IP address\n4. Use Key Vault private endpoint if available\n\"@\n                Write-Error $message\n                throw\n            }\n        }\n        else {\n            Write-Error \"Key Vault error: $($_.Exception.Message)\"\n            throw\n        }\n    }\n    catch {\n        Write-Error \"Failed to retrieve secret '$SecretName' from vault '$VaultName': $($_.Exception.Message)\"\n        throw\n    }\n}\n```\n\n**Retry Logic for Transient Failures:**\n```powershell\nfunction Invoke-AzureOperationWithRetry {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)]\n        [scriptblock]$Operation,\n        \n        [int]$MaxRetries = 3,\n        [int]$DelaySeconds = 2\n    )\n    \n    $attempt = 0\n    do {\n        $attempt++\n        try {\n            return & $Operation\n        }\n        catch {\n            $isTransientError = $_.Exception.Message -like '*timeout*' -or \n                              $_.Exception.Message -like '*throttled*' -or\n                              $_.Exception.Message -like '*service unavailable*'\n                              \n            if ($isTransientError -and $attempt -lt $MaxRetries) {\n                Write-Warning \"Transient error on attempt $attempt. Retrying in $DelaySeconds seconds...\"\n                Start-Sleep -Seconds ($DelaySeconds * $attempt)  # Exponential backoff\n            } else {\n                throw\n            }\n        }\n    } while ($attempt -lt $MaxRetries)\n}\n```\n\n**Resource Management Best Practices:**\n```powershell\n# Always specify resource group and subscription\n$resourceParams = @{\n    ResourceGroupName = $ResourceGroupName\n    SubscriptionId = $SubscriptionId\n    ErrorAction = 'Stop'\n}\n\n# Use splatting for complex parameter sets\n$vmParams = @{\n    ResourceGroupName = $ResourceGroupName\n    Name = $VMName\n    Size = 'Standard_B2s'\n    Image = 'Win2019Datacenter'\n    Credential = $Credential\n    VirtualNetworkName = $VNetName\n    SubnetName = $SubnetName\n    SecurityGroupName = $NSGName\n    ErrorAction = 'Stop'\n}\n\nNew-AzVM @vmParams\n```\n\n**Logging and Monitoring:**\n```powershell\n# Enable Azure PowerShell logging\nEnable-AzureRmAlias -Scope CurrentUser\n\n# Log operations to Application Insights or Log Analytics\nfunction Write-AzureOperationLog {\n    param(\n        [string]$Operation,\n        [string]$Resource,\n        [string]$Status,\n        [hashtable]$AdditionalData = @{}\n    )\n    \n    $logEntry = @{\n        Timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'\n        Operation = $Operation\n        Resource = $Resource\n        Status = $Status\n        SubscriptionId = (Get-AzContext).Subscription.Id\n        Username = (Get-AzContext).Account.Id\n    } + $AdditionalData\n    \n    # Send to logging system\n    Write-Information ($logEntry | ConvertTo-Json -Compress) -InformationAction Continue\n}\n```",
  "priority": 8,
  "audience": "PowerShell developers working with Azure services",
  "requirement": "Critical for reliable Azure automation scripts",
  "categories": [
    "azure",
    "cloud",
    "error handling",
    "powershell"
  ],
  "sourceHash": "5d493cb0a872f9f494b67cd185782bfd5ae29720c649e8409532b3efda6e803d",
  "schemaVersion": "3",
  "createdAt": "2025-09-02T11:57:35.857Z",
  "updatedAt": "2025-09-02T11:57:35.857Z",
  "riskScore": 92,
  "version": "1.0.0",
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P1",
  "classification": "internal",
  "lastReviewedAt": "2025-09-02T11:57:35.857Z",
  "nextReviewDue": "2025-10-02T11:57:35.857Z",
  "reviewIntervalDays": 30,
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-02T11:57:35.857Z",
      "summary": "initial import"
    }
  ],
  "semanticSummary": "Best practices for PowerShell scripts that interact with Azure services, including error handling and network considerations:",
  "primaryCategory": "azure"
}