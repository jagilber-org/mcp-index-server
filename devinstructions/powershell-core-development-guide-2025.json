{
  "id": "powershell-core-development-guide-2025",
  "title": "PowerShell Core Development Guide - Architecture, Testing & Best Practices",
  "body": "# PowerShell Core Development Guide - Architecture, Testing & Best Practices\n\n## Overview\nComprehensive guide for PowerShell Core development based on the PowerShell/PowerShell repository analysis. Covers architecture patterns, testing frameworks, debugging capabilities, error handling, and performance optimization techniques for cross-platform PowerShell development.\n\n**Repository**: https://github.com/PowerShell/PowerShell  \n**Language**: C#, .NET Core/.NET 5+  \n**Platform**: Cross-platform (Windows, Linux, macOS)\n\n## Architecture Foundation\n\n### Core Components\n\n#### PowerShell Engine Architecture\n- **Host Layer**: Console host, ISE integration, custom hosts\n- **Engine Layer**: Command processing, pipeline execution, type system\n- **Runtime Layer**: .NET Core integration, native library interop\n- **Language Layer**: Parser, AST, cmdlet binding, parameter processing\n\n#### Key Architectural Patterns\n```csharp\n// Cmdlet base pattern\n[Cmdlet(VerbsCommon.Get, \"Example\")]\npublic class GetExampleCommand : PSCmdlet\n{\n    [Parameter(Mandatory = true, Position = 0)]\n    public string Name { get; set; }\n\n    protected override void ProcessRecord()\n    {\n        WriteObject(new ExampleObject { Name = this.Name });\n    }\n}\n```\n\n### Build System Architecture\n\n#### dotnet CLI Integration\n- **Project Files**: MSBuild-based with NuGet package management\n- **Build Targets**: Debug, Release, cross-platform compilation\n- **Tool Integration**: ResGen, TypeCatalogGen, crossgen2 optimization\n\n#### Cross-Platform Considerations\n```powershell\n# Platform-specific code patterns\nif ($IsWindows) {\n    # Windows-specific logic\n} elseif ($IsLinux) {\n    # Linux-specific logic\n} elseif ($IsMacOS) {\n    # macOS-specific logic\n}\n```\n\n## Testing Framework: Pester\n\n### Pester Framework Fundamentals\n\n#### Test Structure Patterns\n```powershell\nDescribe \"Module Function Tests\" {\n    Context \"Valid Input Processing\" {\n        It \"Should process valid input correctly\" {\n            $result = Invoke-Function -Parameter \"ValidValue\"\n            $result | Should -Be \"Expected\"\n        }\n    }\n    \n    Context \"Error Handling\" {\n        It \"Should throw on invalid input\" {\n            { Invoke-Function -Parameter \"Invalid\" } | Should -Throw\n        }\n    }\n}\n```\n\n#### Test Organization Best Practices\n- **Unit Tests**: Individual function/cmdlet validation\n- **Integration Tests**: Module-level functionality\n- **End-to-End Tests**: Complete scenario validation\n- **Performance Tests**: Benchmark and regression testing\n\n### Advanced Testing Patterns\n\n#### Mock and Stub Usage\n```powershell\n# Mock external dependencies\nMock Get-Service { return @{ Status = \"Running\"; Name = \"TestService\" } }\n\n# Test cmdlet behavior with mocked dependencies\nIt \"Should handle service status correctly\" {\n    $result = Get-ServiceStatus -ServiceName \"TestService\"\n    Assert-MockCalled Get-Service -Exactly 1\n    $result.Status | Should -Be \"Running\"\n}\n```\n\n#### Test Data Management\n```powershell\n# Test data setup and teardown\nBeforeAll {\n    $script:TestData = @{\n        ValidInput = \"TestValue\"\n        InvalidInput = $null\n        ExpectedOutput = \"ProcessedTestValue\"\n    }\n}\n\nAfterAll {\n    # Cleanup test artifacts\n    Remove-Variable TestData -Scope Script -ErrorAction SilentlyContinue\n}\n```\n\n## Debugging and Diagnostics\n\n### Built-in Debugging Capabilities\n\n#### PowerShell Debugger Commands\n```powershell\n# Set breakpoints\nSet-PSBreakpoint -Script .\\script.ps1 -Line 42\nSet-PSBreakpoint -Command Get-Process\nSet-PSBreakpoint -Variable $importantVar\n\n# Debug execution control\nStep-Over    # Execute next statement\nStep-Into    # Step into functions\nStep-Out     # Step out of current function\nContinue     # Resume execution\n```\n\n#### Advanced Debugging Techniques\n```powershell\n# Conditional breakpoints\nSet-PSBreakpoint -Script .\\script.ps1 -Line 15 -Action {\n    if ($DebugVariable -gt 100) {\n        Write-Host \"Debug condition met\" -ForegroundColor Red\n        break\n    }\n}\n\n# Debug output and tracing\nWrite-Debug \"Debug message\" -Debug\nTrace-Command -Name ParameterBinding -Expression { Get-Process } -PSHost\n```\n\n### Error Handling Patterns\n\n#### Comprehensive Error Management\n```powershell\n# Try-catch with specific exception handling\ntry {\n    $result = Invoke-RiskyOperation -Parameter $value\n} catch [System.UnauthorizedAccessException] {\n    Write-Error \"Access denied: $($_.Exception.Message)\"\n    return\n} catch [System.IO.FileNotFoundException] {\n    Write-Warning \"File not found, using default configuration\"\n    $result = Get-DefaultConfiguration\n} catch {\n    Write-Error \"Unexpected error: $($_.Exception.Message)\"\n    throw\n} finally {\n    # Cleanup operations\n    Remove-Variable result -ErrorAction SilentlyContinue\n}\n```\n\n#### Error Action Preferences\n```powershell\n# Configure error handling behavior\n$ErrorActionPreference = \"Stop\"        # Halt on any error\n$ErrorActionPreference = \"Continue\"     # Continue with warnings\n$ErrorActionPreference = \"SilentlyContinue\" # Suppress error messages\n\n# Per-command error action\nGet-Item -Path \"NonExistent\" -ErrorAction SilentlyContinue\n```\n\n## Performance Optimization\n\n### Memory Management\n\n#### Efficient Object Handling\n```powershell\n# Avoid pipeline overhead for large datasets\n$results = [System.Collections.Generic.List[PSObject]]::new()\nforeach ($item in $largeDataset) {\n    $processedItem = Process-Item $item\n    $results.Add($processedItem)\n}\n\n# Instead of:\n# $results = $largeDataset | ForEach-Object { Process-Item $_ }\n```\n\n#### Memory Profiling Techniques\n```powershell\n# Monitor memory usage\n$before = [GC]::GetTotalMemory($false)\n# Execute code to profile\n$after = [GC]::GetTotalMemory($true)  # Force garbage collection\n$memoryUsed = $after - $before\nWrite-Host \"Memory used: $($memoryUsed / 1MB) MB\"\n```\n\n### Performance Measurement\n\n#### Benchmarking Patterns\n```powershell\n# Measure execution time\n$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\n# Code to measure\n$stopwatch.Stop()\nWrite-Host \"Execution time: $($stopwatch.ElapsedMilliseconds) ms\"\n\n# Compare different approaches\nMeasure-Command { Approach-One } | Select-Object TotalMilliseconds\nMeasure-Command { Approach-Two } | Select-Object TotalMilliseconds\n```\n\n## Module Development Best Practices\n\n### Module Structure\n\n#### Standard Module Layout\n```\nMyModule/\n├── MyModule.psd1          # Module manifest\n├── MyModule.psm1          # Root module file\n├── Public/                # Exported functions\n│   ├── Get-Something.ps1\n│   └── Set-Something.ps1\n├── Private/               # Internal functions\n│   ├── Helper-Function.ps1\n│   └── Validation.ps1\n├── Tests/                 # Pester tests\n│   ├── Unit/\n│   └── Integration/\n├── docs/                  # Documentation\n└── en-US/                 # Help files\n    └── MyModule-help.xml\n```\n\n#### Module Manifest Best Practices\n```powershell\n# MyModule.psd1\n@{\n    ModuleVersion = '1.0.0'\n    GUID = 'unique-guid-here'\n    Author = 'Author Name'\n    Description = 'Module description'\n    \n    # Minimum PowerShell version\n    PowerShellVersion = '5.1'\n    \n    # Compatible PSEditions\n    CompatiblePSEditions = @('Desktop', 'Core')\n    \n    # Exported functions\n    FunctionsToExport = @(\n        'Get-Something',\n        'Set-Something'\n    )\n    \n    # Required modules\n    RequiredModules = @(\n        @{ ModuleName = 'RequiredModule'; ModuleVersion = '2.0.0' }\n    )\n    \n    # Private data\n    PrivateData = @{\n        PSData = @{\n            Tags = @('PowerShell', 'Utility')\n            ProjectUri = 'https://github.com/user/repo'\n            ReleaseNotes = 'Initial release'\n        }\n    }\n}\n```\n\n### Function Development Patterns\n\n#### Advanced Function Template\n```powershell\nfunction Get-ProcessedData {\n    [CmdletBinding(SupportsShouldProcess)]\n    [OutputType([PSCustomObject])]\n    param(\n        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]\n        [ValidateNotNullOrEmpty()]\n        [string[]]$InputData,\n        \n        [Parameter()]\n        [ValidateSet('Fast', 'Thorough', 'Custom')]\n        [string]$ProcessingMode = 'Fast',\n        \n        [Parameter()]\n        [switch]$PassThru\n    )\n    \n    begin {\n        Write-Verbose \"Starting processing in $ProcessingMode mode\"\n        $results = [System.Collections.Generic.List[PSObject]]::new()\n    }\n    \n    process {\n        foreach ($item in $InputData) {\n            if ($PSCmdlet.ShouldProcess($item, \"Process data\")) {\n                try {\n                    $processedItem = Invoke-DataProcessing -Data $item -Mode $ProcessingMode\n                    $results.Add($processedItem)\n                    \n                    if ($PassThru) {\n                        Write-Output $processedItem\n                    }\n                } catch {\n                    Write-Error \"Failed to process '$item': $($_.Exception.Message)\"\n                }\n            }\n        }\n    }\n    \n    end {\n        if (-not $PassThru) {\n            Write-Output $results.ToArray()\n        }\n        Write-Verbose \"Processing completed. $($results.Count) items processed.\"\n    }\n}\n```\n\n## Cross-Platform Development\n\n### Platform Detection\n```powershell\n# Built-in platform variables (PowerShell 6+)\nif ($IsWindows) {\n    # Windows-specific code\n} elseif ($IsLinux) {\n    # Linux-specific code\n} elseif ($IsMacOS) {\n    # macOS-specific code\n}\n\n# PowerShell 5.1 compatibility\nif ($PSVersionTable.PSVersion.Major -lt 6) {\n    # Assume Windows for PowerShell 5.1\n    $IsWindows = $true\n    $IsLinux = $false\n    $IsMacOS = $false\n}\n```\n\n### Path Handling\n```powershell\n# Cross-platform path operations\n$configPath = Join-Path $env:HOME '.myapp' 'config.json'\n\n# Platform-specific paths\nif ($IsWindows) {\n    $appDataPath = $env:APPDATA\n} else {\n    $appDataPath = Join-Path $env:HOME '.local' 'share'\n}\n```\n\n## Development Tools Integration\n\n### Visual Studio Code Integration\n\n#### PowerShell Extension Features\n- **IntelliSense**: Autocomplete, parameter hints, type information\n- **Debugging**: Breakpoints, variable inspection, call stack\n- **Testing**: Pester test discovery and execution\n- **Formatting**: PSScriptAnalyzer integration, code formatting\n\n#### Recommended Extensions\n- PowerShell (Microsoft)\n- PSScriptAnalyzer\n- PowerShell Preview (for latest features)\n- GitLens (for Git integration)\n\n### Git Integration Patterns\n\n#### PowerShell-Specific .gitignore\n```gitignore\n# PowerShell artifacts\n*.ps1xml\n*.psc1\n*.pssc\n*.psd1\n*.psm1\n\n# Debug files\n*.pdb\n*.pdb.*\n\n# Build artifacts\nbin/\nobj/\nout/\n\n# Package management\npackages/\n.nuget/\n```\n\n## CI/CD Integration\n\n### GitHub Actions for PowerShell\n```yaml\nname: PowerShell CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [windows-latest, ubuntu-latest, macOS-latest]\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Run Pester tests\n      shell: pwsh\n      run: |\n        Install-Module -Name Pester -Force -SkipPublisherCheck\n        Invoke-Pester -Path ./Tests -OutputFile TestResults.xml -OutputFormat NUnitXml\n    \n    - name: Publish test results\n      uses: dorny/test-reporter@v1\n      if: always()\n      with:\n        name: PowerShell Tests (${{ matrix.os }})\n        path: TestResults.xml\n        reporter: java-junit\n```\n\n### Azure DevOps Integration\n```yaml\ntrigger:\n- main\n\npool:\n  vmImage: 'windows-latest'\n\nsteps:\n- task: PowerShell@2\n  displayName: 'Install Pester'\n  inputs:\n    targetType: 'inline'\n    script: 'Install-Module -Name Pester -Force -SkipPublisherCheck'\n\n- task: PowerShell@2\n  displayName: 'Run Tests'\n  inputs:\n    targetType: 'inline'\n    script: 'Invoke-Pester -Path ./Tests -CI'\n\n- task: PublishTestResults@2\n  inputs:\n    testResultsFormat: 'NUnit'\n    testResultsFiles: 'testResults.xml'\n```\n\n## Security Best Practices\n\n### Code Security\n```powershell\n# Avoid string concatenation for commands\n# BAD:\n$command = \"Get-Process -Name \" + $userInput\nInvoke-Expression $command\n\n# GOOD:\n$processes = Get-Process -Name $userInput\n\n# Validate user input\n[ValidateScript({\n    if ($_ -match '^[a-zA-Z0-9]+$') {\n        return $true\n    } else {\n        throw \"Invalid characters in input\"\n    }\n})]\n[string]$SafeInput\n```\n\n### Execution Policy Management\n```powershell\n# Check current execution policy\nGet-ExecutionPolicy -List\n\n# Set execution policy for development\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n# Sign scripts for distribution\n$cert = Get-ChildItem -Path Cert:\\CurrentUser\\My -CodeSigningCert\nSet-AuthenticodeSignature -FilePath .\\script.ps1 -Certificate $cert\n```\n\n## Troubleshooting Common Issues\n\n### Module Loading Issues\n```powershell\n# Check module paths\n$env:PSModulePath -split [IO.Path]::PathSeparator\n\n# Force module reload\nRemove-Module MyModule -Force -ErrorAction SilentlyContinue\nImport-Module MyModule -Force\n\n# Debug module loading\nImport-Module MyModule -Verbose\n```\n\n### Performance Issues\n```powershell\n# Profile script execution\n$profile = Trace-Command -Name All -Expression { .\\script.ps1 } -PSHost\n\n# Measure specific operations\nMeasure-Command { \n    1..1000 | ForEach-Object { Get-Random } \n} | Select-Object TotalMilliseconds\n```\n\n### Cross-Platform Compatibility\n```powershell\n# Test PowerShell version compatibility\nif ($PSVersionTable.PSVersion -lt [Version]'6.0') {\n    Write-Warning \"This script requires PowerShell 6.0 or later\"\n    return\n}\n\n# Handle platform-specific features\ntry {\n    $service = Get-Service -Name 'Themes' -ErrorAction Stop\n} catch {\n    if ($IsLinux -or $IsMacOS) {\n        Write-Verbose \"Service management not available on this platform\"\n    } else {\n        throw\n    }\n}\n```\n\n## Advanced Development Patterns\n\n### Class-Based Development\n```powershell\nclass CustomObject {\n    [string]$Name\n    [int]$Value\n    [datetime]$Created\n    \n    CustomObject([string]$name, [int]$value) {\n        $this.Name = $name\n        $this.Value = $value\n        $this.Created = Get-Date\n    }\n    \n    [string] ToString() {\n        return \"$($this.Name): $($this.Value)\"\n    }\n    \n    [bool] IsValid() {\n        return $this.Name -and $this.Value -gt 0\n    }\n}\n\n# Usage\n$obj = [CustomObject]::new(\"Test\", 42)\n$obj.IsValid()\n```\n\n### DSL (Domain Specific Language) Patterns\n```powershell\n# Configuration DSL example\nfunction Configuration {\n    param([scriptblock]$Definition)\n    \n    & $Definition\n}\n\nfunction Server {\n    param([string]$Name, [scriptblock]$Config)\n    \n    $serverConfig = @{ Name = $Name }\n    & $Config\n    return $serverConfig\n}\n\nfunction Port {\n    param([int]$Number)\n    \n    $script:serverConfig.Port = $Number\n}\n\n# Usage\n$config = Configuration {\n    Server \"WebServer\" {\n        Port 8080\n    }\n}\n```\n\n## Resource Management\n\n### Memory and Resource Cleanup\n```powershell\nfunction Invoke-WithCleanup {\n    param(\n        [scriptblock]$ScriptBlock,\n        [scriptblock]$Cleanup\n    )\n    \n    try {\n        & $ScriptBlock\n    } finally {\n        if ($Cleanup) {\n            & $Cleanup\n        }\n        [GC]::Collect()\n        [GC]::WaitForPendingFinalizers()\n    }\n}\n\n# Usage\nInvoke-WithCleanup -ScriptBlock {\n    $largeData = Get-LargeDataset\n    Process-Data $largeData\n} -Cleanup {\n    Remove-Variable largeData -ErrorAction SilentlyContinue\n}\n```\n\n## Community and Documentation\n\n### Documentation Standards\n```powershell\n<#\n.SYNOPSIS\n    Brief description of the function.\n\n.DESCRIPTION\n    Detailed description of what the function does.\n\n.PARAMETER Name\n    Description of the Name parameter.\n\n.PARAMETER Value\n    Description of the Value parameter.\n\n.EXAMPLE\n    Get-Example -Name \"Test\" -Value 42\n    \n    This example shows basic usage of the function.\n\n.EXAMPLE\n    \"Test1\", \"Test2\" | Get-Example -Value 100\n    \n    This example shows pipeline usage.\n\n.INPUTS\n    String. You can pipe strings to this function.\n\n.OUTPUTS\n    PSCustomObject. Returns custom objects with processed data.\n\n.NOTES\n    Author: Your Name\n    Version: 1.0.0\n    Date: 2025-01-01\n\n.LINK\n    https://github.com/user/repo\n#>\n```\n\n### Community Resources\n- **PowerShell Gallery**: Module distribution and discovery\n- **GitHub**: Open source PowerShell projects and contributions\n- **PowerShell.org**: Community forums and resources\n- **PowerShell Community**: Discord, Reddit, Stack Overflow\n\n## Conclusion\n\nThis comprehensive guide covers the essential aspects of PowerShell Core development, from architecture understanding to advanced development patterns. Key takeaways:\n\n1. **Architecture Awareness**: Understanding PowerShell's layered architecture enables better design decisions\n2. **Testing Excellence**: Pester framework provides robust testing capabilities for quality assurance\n3. **Cross-Platform Considerations**: Modern PowerShell development must account for multiple operating systems\n4. **Performance Optimization**: Memory management and efficient coding patterns are crucial for scalable solutions\n5. **Security First**: Always validate input and follow security best practices\n6. **Community Engagement**: Leverage community resources and contribute back to the ecosystem\n\nBy following these practices and patterns, developers can create robust, maintainable, and cross-platform PowerShell solutions that align with the PowerShell Core project's standards and community expectations.",
  "priority": 5,
  "audience": "all",
  "requirement": "recommended",
  "categories": [
    "architecture",
    "best-practices",
    "cross-platform",
    "development",
    "powershell",
    "testing"
  ],
  "sourceHash": "d191ee924ca5dadba7be740cc4ee74a674bc43e877ea792d4698cefd471e8fe2",
  "schemaVersion": "3",
  "createdAt": "2025-09-02T12:11:13.784Z",
  "updatedAt": "2025-09-02T12:11:13.784Z",
  "riskScore": 115,
  "version": "1.0.0",
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P1",
  "classification": "internal",
  "lastReviewedAt": "2025-09-02T12:11:13.784Z",
  "nextReviewDue": "2025-10-02T12:11:13.784Z",
  "reviewIntervalDays": 30,
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-02T12:11:13.784Z",
      "summary": "initial import"
    }
  ],
  "semanticSummary": "# PowerShell Core Development Guide - Architecture, Testing & Best Practices",
  "primaryCategory": "architecture"
}