{
  "id": "dotnet-spec-driven-patterns",
  "title": ".NET Spec-Driven Development Patterns",
  "body": "# .NET Spec-Driven Development Patterns\n\n## Overview\nSpec-driven development methodology for .NET projects integrating constitutional governance, test-driven specifications, and modern .NET tooling patterns.\n\n## Specification Templates\n\n### Interface Specifications\n```csharp\n/// <summary>\n/// [SPECIFICATION]: User data contract interface\n/// \n/// Specification Requirements:\n/// - Must enforce data validation at runtime\n/// - Should support JSON serialization\n/// - Must provide clear property contracts\n/// - Should enable dependency injection\n/// </summary>\npublic interface IUserSpecification\n{\n    /// <summary>User unique identifier - must be non-empty GUID</summary>\n    Guid Id { get; }\n    \n    /// <summary>User display name - must be 1-100 characters</summary>\n    string Name { get; set; }\n    \n    /// <summary>User email - must be valid email format</summary>\n    string Email { get; set; }\n    \n    /// <summary>Account creation timestamp - must be UTC</summary>\n    DateTime CreatedAt { get; }\n}\n```\n\n### Class Specification Pattern\n```csharp\n/// <summary>\n/// [SPECIFICATION]: User data processor with validation\n/// \n/// Specification Requirements:\n/// - Input validation: All required fields must be present and valid\n/// - Error handling: Must throw UserValidationException for invalid input\n/// - Performance: Must complete within 100ms for valid input\n/// - Logging: Must log all validation attempts\n/// - Thread safety: Must be safe for concurrent access\n/// </summary>\npublic class UserProcessor : IUserProcessor\n{\n    private readonly ILogger<UserProcessor> _logger;\n    private readonly IValidator<CreateUserRequest> _validator;\n    \n    public UserProcessor(ILogger<UserProcessor> logger, IValidator<CreateUserRequest> validator)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        _validator = validator ?? throw new ArgumentNullException(nameof(validator));\n    }\n    \n    /// <summary>\n    /// Process user creation request according to specification\n    /// </summary>\n    /// <param name=\"request\">User creation request</param>\n    /// <returns>Created user data</returns>\n    /// <exception cref=\"UserValidationException\">Thrown when validation fails</exception>\n    public async Task<User> ProcessUserAsync(CreateUserRequest request)\n    {\n        // Specification validation block\n        if (request == null)\n        {\n            throw new ArgumentNullException(nameof(request));\n        }\n        \n        var validationResult = await _validator.ValidateAsync(request);\n        if (!validationResult.IsValid)\n        {\n            _logger.LogWarning(\"User validation failed: {Errors}\", validationResult.Errors);\n            throw new UserValidationException(validationResult.Errors);\n        }\n        \n        // Implementation satisfying specification\n        var user = new User\n        {\n            Id = Guid.NewGuid(),\n            Name = request.Name.Trim(),\n            Email = request.Email.ToLowerInvariant(),\n            CreatedAt = DateTime.UtcNow\n        };\n        \n        _logger.LogInformation(\"User processed successfully: {UserId}\", user.Id);\n        return user;\n    }\n}\n```\n\n## Test-Driven Specifications\n\n### xUnit Specification Tests\n```csharp\n/// <summary>\n/// Specification test suite - defines behavior before implementation\n/// </summary>\npublic class UserProcessorSpecificationTests\n{\n    private readonly UserProcessor _processor;\n    private readonly Mock<ILogger<UserProcessor>> _mockLogger;\n    private readonly Mock<IValidator<CreateUserRequest>> _mockValidator;\n    \n    public UserProcessorSpecificationTests()\n    {\n        _mockLogger = new Mock<ILogger<UserProcessor>>();\n        _mockValidator = new Mock<IValidator<CreateUserRequest>>();\n        _processor = new UserProcessor(_mockLogger.Object, _mockValidator.Object);\n    }\n    \n    [Fact]\n    [Trait(\"Category\", \"Specification\")]\n    [Trait(\"Requirement\", \"InputValidation\")]\n    public async Task ProcessUserAsync_MUST_RejectNullRequest()\n    {\n        // Arrange\n        CreateUserRequest? nullRequest = null;\n        \n        // Act & Assert\n        await Assert.ThrowsAsync<ArgumentNullException>(\n            () => _processor.ProcessUserAsync(nullRequest!));\n    }\n    \n    [Fact]\n    [Trait(\"Category\", \"Specification\")]\n    [Trait(\"Requirement\", \"InputValidation\")]\n    public async Task ProcessUserAsync_MUST_RejectInvalidInput()\n    {\n        // Arrange\n        var invalidRequest = new CreateUserRequest { Name = \"\", Email = \"invalid\" };\n        var validationResult = new ValidationResult(new[] \n        {\n            new ValidationFailure(\"Name\", \"Name is required\"),\n            new ValidationFailure(\"Email\", \"Invalid email format\")\n        });\n        \n        _mockValidator.Setup(v => v.ValidateAsync(invalidRequest, default))\n                     .ReturnsAsync(validationResult);\n        \n        // Act & Assert\n        await Assert.ThrowsAsync<UserValidationException>(\n            () => _processor.ProcessUserAsync(invalidRequest));\n    }\n    \n    [Fact]\n    [Trait(\"Category\", \"Specification\")]\n    [Trait(\"Requirement\", \"Performance\")]\n    public async Task ProcessUserAsync_MUST_CompleteWithin100Ms()\n    {\n        // Arrange\n        var validRequest = new CreateUserRequest \n        { \n            Name = \"John Doe\", \n            Email = \"john@example.com\" \n        };\n        \n        _mockValidator.Setup(v => v.ValidateAsync(validRequest, default))\n                     .ReturnsAsync(new ValidationResult());\n        \n        // Act\n        var stopwatch = Stopwatch.StartNew();\n        await _processor.ProcessUserAsync(validRequest);\n        stopwatch.Stop();\n        \n        // Assert\n        Assert.True(stopwatch.ElapsedMilliseconds < 100, \n                   $\"Processing took {stopwatch.ElapsedMilliseconds}ms, expected < 100ms\");\n    }\n    \n    [Theory]\n    [Trait(\"Category\", \"Specification\")]\n    [Trait(\"Requirement\", \"OutputFormat\")]\n    [InlineData(\"  John Doe  \", \"john.doe@EXAMPLE.COM\", \"John Doe\", \"john.doe@example.com\")]\n    [InlineData(\"Jane\", \"JANE@DOMAIN.COM\", \"Jane\", \"jane@domain.com\")]\n    public async Task ProcessUserAsync_MUST_NormalizeOutput(\n        string inputName, string inputEmail, string expectedName, string expectedEmail)\n    {\n        // Arrange\n        var request = new CreateUserRequest { Name = inputName, Email = inputEmail };\n        _mockValidator.Setup(v => v.ValidateAsync(request, default))\n                     .ReturnsAsync(new ValidationResult());\n        \n        // Act\n        var result = await _processor.ProcessUserAsync(request);\n        \n        // Assert\n        Assert.Equal(expectedName, result.Name);\n        Assert.Equal(expectedEmail, result.Email);\n        Assert.NotEqual(Guid.Empty, result.Id);\n        Assert.True(result.CreatedAt <= DateTime.UtcNow);\n    }\n}\n```\n\n## Constitutional Governance\n\n### Project Constitution\n```csharp\n/// <summary>\n/// Project Constitutional Framework\n/// Establishes immutable development principles\n/// </summary>\npublic static class ProjectConstitution\n{\n    /// <summary>\n    /// Article I: Specification Authority\n    /// All code must begin with complete behavioral specifications\n    /// </summary>\n    public static class SpecificationAuthority\n    {\n        public const string Principle = \"Specification before implementation\";\n        public const string Enforcement = \"All public methods require XML documentation with specifications\";\n        public const string Validation = \"StyleCop analyzers enforce documentation standards\";\n    }\n    \n    /// <summary>\n    /// Article II: Type Safety Mandate\n    /// All code must maintain strict type safety\n    /// </summary>\n    public static class TypeSafety\n    {\n        public const string Principle = \"Nullable reference types enabled\";\n        public const string Enforcement = \"Treat warnings as errors\";\n        public const string Validation = \"Static analysis tools enforce type contracts\";\n    }\n    \n    /// <summary>\n    /// Article III: Test-Driven Specifications\n    /// Specifications must be executable as tests\n    /// </summary>\n    public static class TestDrivenSpecs\n    {\n        public const string Principle = \"Specifications define test requirements\";\n        public const string Enforcement = \"100% specification coverage required\";\n        public const string Validation = \"All specification requirements must have corresponding tests\";\n    }\n}\n```\n\n## Project Configuration\n\n### Directory.Build.props\n```xml\n<Project>\n  <PropertyGroup>\n    <!-- Constitutional enforcement -->\n    <Nullable>enable</Nullable>\n    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n    <WarningsAsErrors />\n    <WarningsNotAsErrors>CS1591</WarningsNotAsErrors> <!-- Missing XML docs -->\n    \n    <!-- Specification validation -->\n    <DocumentationFile>$(OutputPath)$(AssemblyName).xml</DocumentationFile>\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\n    \n    <!-- Static analysis -->\n    <EnableNETAnalyzers>true</EnableNETAnalyzers>\n    <AnalysisLevel>latest</AnalysisLevel>\n    <CodeAnalysisRuleSet>$(MSBuildThisFileDirectory)ruleset.ruleset</CodeAnalysisRuleSet>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <PackageReference Include=\"StyleCop.Analyzers\" Version=\"1.1.118\">\n      <PrivateAssets>all</PrivateAssets>\n    </PackageReference>\n    <PackageReference Include=\"Microsoft.CodeAnalysis.NetAnalyzers\" Version=\"7.0.0\">\n      <PrivateAssets>all</PrivateAssets>\n    </PackageReference>\n  </ItemGroup>\n</Project>\n```\n\n## Advanced Patterns\n\n### Specification-Driven API Controllers\n```csharp\n/// <summary>\n/// [SPECIFICATION]: RESTful user management API\n/// \n/// Specification Requirements:\n/// - Input validation: All requests must be validated\n/// - Error handling: Consistent error response format\n/// - Security: All endpoints require authentication\n/// - Performance: Response times under 200ms\n/// - Logging: All operations must be logged\n/// </summary>\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize]\npublic class UsersController : ControllerBase\n{\n    private readonly IUserService _userService;\n    private readonly ILogger<UsersController> _logger;\n    \n    public UsersController(IUserService userService, ILogger<UsersController> logger)\n    {\n        _userService = userService ?? throw new ArgumentNullException(nameof(userService));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n    \n    /// <summary>\n    /// Create new user according to specification\n    /// </summary>\n    /// <param name=\"request\">User creation request</param>\n    /// <returns>Created user data</returns>\n    /// <response code=\"201\">User created successfully</response>\n    /// <response code=\"400\">Validation errors in request</response>\n    [HttpPost]\n    [ProducesResponseType(typeof(UserResponse), StatusCodes.Status201Created)]\n    [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]\n    public async Task<IActionResult> CreateUser([FromBody] CreateUserRequest request)\n    {\n        // Specification validation handled by model binding and filters\n        try\n        {\n            var user = await _userService.CreateUserAsync(request);\n            _logger.LogInformation(\"User created: {UserId}\", user.Id);\n            \n            return CreatedAtAction(\n                nameof(GetUser), \n                new { id = user.Id }, \n                UserResponse.FromUser(user));\n        }\n        catch (UserValidationException ex)\n        {\n            _logger.LogWarning(\"User creation validation failed: {Errors}\", ex.Errors);\n            return BadRequest(new ValidationProblemDetails(ex.Errors));\n        }\n    }\n}\n```\n\n## Success Metrics\n\n- **Specification Coverage**: 100% of public methods have XML documentation with specifications\n- **Type Safety**: Zero nullable reference warnings\n- **Test Coverage**: 100% of specifications have executable tests\n- **Constitutional Compliance**: All code passes static analysis\n- **Performance**: All implementations meet specification requirements",
  "priority": 85,
  "audience": "developers",
  "requirement": "recommended",
  "categories": [
    "csharp",
    "dotnet",
    "governance",
    "spec-driven-development",
    "testing"
  ],
  "sourceHash": "1d49241048839aa0ec0b26a98de386c90a753dabc57dcaec2c1375b928368a3e",
  "schemaVersion": "3",
  "createdAt": "2025-09-05T15:47:44.374Z",
  "updatedAt": "2025-09-10T10:56:56.836Z",
  "riskScore": 35,
  "version": "1.0.0",
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P4",
  "classification": "internal",
  "lastReviewedAt": "2025-09-05T15:47:44.375Z",
  "nextReviewDue": "2026-01-03T15:47:44.375Z",
  "reviewIntervalDays": 120,
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-05T15:47:44.374Z",
      "summary": "initial import"
    }
  ],
  "semanticSummary": "# .NET Spec-Driven Development Patterns",
  "primaryCategory": "csharp"
}