{
  "id": "dotnet-waWorkerHost-dump-analysis-pattern",
  "title": "WaWorkerHost .NET Memory Dump Analysis Pattern - Placeholder Exceptions & Growth Investigation",
  "body": "# WaWorkerHost .NET Memory Dump Analysis Pattern - Placeholder Exceptions & Growth Investigation\n\nAuthoritative pattern for analyzing WaWorkerHost (Azure Cloud Service worker role) .NET Framework memory growth using a production crash or ad‑hoc full dump when commit appears modest but address space or GC segments trend upward. Encodes critical correction: certain exceptions shown without stacks are CLR preallocated placeholders, NOT evidence of runtime throw storms.\n\n## 1. Scope & Preconditions\n- Target Process: WaWorkerHost.exe (.NET Framework 4.x)\n- Scenario: Increasing Private Bytes / Commit history OR apparent memory growth with sporadic OOM risk\n- Data Inputs: Full memory dump (-ma), performance counter timelines (Process / Private Bytes, .NET CLR Memory), optional ETW GC, SQL / external dependency metrics\n- Tooling: WinDbg (matching architecture), correct SOS version (warn if mismatch), !eeheap, !dumpheap, !gcroot, !address / !vadump (as needed)\n\n## 2. Immediate Sanity Checks\n1. Verify CLR & SOS version match (mismatch can hide LOH / segment detail)  \n2. !pe / !dae exception listings: Distinguish REAL vs PLACEHOLDER exceptions:\n   - PLACEHOLDER indicators: common high-impact exception types (OutOfMemoryException, StackOverflowException, ExecutionEngineException, generic System.Exception) present with NO stack trace, identical single instance addresses\n   - Rationale: CLR preallocates a minimal set for low-resource conditions\n   - Action: Do NOT attribute fault or throw volume without stacked instances\n3. !vm or !address summary: Quantify Reserved vs Committed; large private MEM_PRIVATE with low commit suggests fragmentation / reservation patterns rather than immediate leak\n\n## 3. Memory Growth Differential Diagnosis\n| Signal | Likely Cause | Confirmatory Probe | Mitigation Direction |\n|--------|--------------|--------------------|---------------------|\n| Large Reserved (GBs) but modest Commit | Fragmented LOH, pinned large arrays, address space reservation | !eeheap -gc (segment listing), !dumpheap -stat on large arrays/object[] | Reduce pinning, pool arrays, review large object allocation patterns |\n| Growing MemoryCache (System.Runtime.Caching) structures | Unbounded cache or missing eviction | !dumpheap -type MemoryCacheEntry, enumerate count/size | Add size limits, aggressive expiration, instrumentation |\n| Many pinned handles (GCHandleType.Pinned) | Native interop / large pinned buffers | !dumpheap -type System.Object[] then !gcroot / handle analysis | Replace long-lived pins with slice copies / pooling |\n| SQL TdsParserStateObject accumulation | Connection pooling mismanagement / leaked readers | !dumpheap -type System.Data.SqlClient.*StateObject | Ensure proper disposal, enable connection pool perf counters |\n| High LOH fragmentation (free gaps) | Large ephemeral objects, arrays > 85K | !eeheap LOH segment free vs used | Reuse buffers, ArrayPool, reduce ephemeral large allocations |\n\n## 4. Placeholder Exception Recognition Rules\n- If exception type is one of: OutOfMemoryException, StackOverflowException, ExecutionEngineException, System.Exception (generic) AND appears exactly once without call stack → treat as PREALLOCATED.\n- Validation Steps:\n  1. Use !dumpobject <addr> ensure no custom fields indicating thrown context\n  2. Search for additional instances (!dumpheap -type <Type>) – only 1 supports placeholder status\n  3. Absence of correlated perf counter spikes (CLR Exceptions/sec) strengthens conclusion\n- Escalation ONLY if multiple distinct addresses or stacks appear.\n\n## 5. Structured Workflow\n1. Gather Baseline: !pe / !dae, !vm, !eeheap -gc, !dumpheap -stat (top types)\n2. Classify Top Types: Focus on large arrays (System.Object[], byte[], char[]), caching types, custom domain objects\n3. Pinning Assessment: !gcroot on representative large object to detect GCHandle or static retention\n4. Cache Sizing: Enumerate MemoryCache internal entries (iterate via root object) to approximate item count & memory footprint\n5. Reserved vs Commit Gap: Determine if risk is virtual address space exhaustion (32-bit) or fragmentation patterns (64-bit still relevant for large pinned ranges)\n6. Form Hypotheses: Each with (Signal, Mechanism, Validation Action, Potential Fix)\n7. Plan Data Collection (below) for gaps\n\n## 6. Data Collection Plan (Outside Dump)\n| Gap | Collection Method | Rationale |\n|-----|-------------------|-----------|\n| Trend of Private Bytes vs Gen 2 size | Perf counters (Process, .NET CLR Memory) every 1 min | Correlate growth with GC activity |\n| LOH fragmentation & growth | Series of two+ dumps 10–15 min apart | Differentiate transient burst vs sustained accumulation |\n| Cache size fluctuations | Instrument MemoryCache.GetCount / custom metrics | Detect unbounded growth |\n| SQL connection usage | Perf counters / logging (NumberOfPooledConnections) | Identify resource retention |\n| GC Pressure vs Alloc Rate | ETW GC (Microsoft-Windows-DotNETRuntime GC keyword) | Confirm allocation churn / pause patterns |\n\n## 7. Decision Criteria\n- Pursue cache remediation if cache-related types > 20–30% of committed or trending upward monotonic across sampled dumps.\n- Investigate pinning if pinned large arrays block coalescing (visible free gaps around pinned spans) or LOH free space > 30% of LOH total.\n- Defer exception deep-dive if only placeholder set is present and no stacked duplicates.\n\n## 8. Mitigation Playbook\n| Scenario | Immediate Action | Longer-Term Hardening |\n|----------|------------------|------------------------|\n| Unbounded MemoryCache | Add absolute + sliding expirations; cap entries; on-start logging of counts | Adaptive eviction, metric-based alerts |\n| Large Buffer Churn | Introduce ArrayPool<T>; central buffer manager | Allocation telemetry & guardrails |\n| Pinned Buffer Hotspots | Reduce pin duration, copy out subset | Refactor interop API usage to minimize pin scope |\n| Fragmented LOH | Reduce ephemeral large objects; reuse; stagger allocations | Periodic memory health KPIs & regression tests |\n| SQL State Object Retention | Ensure using/dispose patterns; enable connection retry audit | Automated analyzer for improper disposal |\n\n## 9. Reporting Template (Summary Block)\n```\nSummary:\n- Reserved/Committed (GB): R=__, C=__ (Gap implies fragmentation: Y/N)\n- Top 5 Types (% of total): 1) ... 2) ... 3) ...\n- Placeholder Exceptions Only: Y/N (If Y: list types)\n- Pinning Indicators: (Y/N + example root)\n- Dominant Hypothesis: <short label>\n- Next Data Needed: <metric or dump series>\n- Recommended Immediate Action: <one-liner>\n```\n\n## 10. Common Pitfalls\n- Misinterpreting placeholder exceptions as active faults\n- Drawing conclusions with single dump (need temporal comparison)\n- Ignoring SOS version mismatch warnings (can hide segment insight)\n- Focusing on object count not total size (few large arrays outweigh many small objects)\n\n## 11. Exit Criteria\nInvestigation considered complete when: (a) Mechanistic cause identified OR ruled out with triage evidence, (b) At least one validated mitigation path documented, (c) Placeholder exceptions explicitly classified, (d) Follow-up instrumentation tasks queued / implemented.\n\n## 12. Quick Win Commands (WinDbg)\n```\n!dumpheap -stat -min 85000         // Large objects\n!dumpheap -stat System.Object[]    // Object[] dominance\n!eeheap -gc                        // Segment layout / fragmentation\n!gcroot <addr>                     // Retention / pinning check\n!dumpheap -type MemoryCache        // Cache structures\n```\n\n## 13. Validation of This Pattern\nUse on subsequent dumps to rapidly (<=10 min) decide if growth is cache, fragmentation, or external pressure. Document placeholder exception classification early to prevent hypothesis churn.\n\n---\nRevision: 1.0.0  \nStatus: Approved Pattern  \nReview Interval: 90d  \nChange Triggers: New evidence of alternate exception placeholder sets, new GC fragmentation heuristics, or shift to .NET Core hosting.",
  "rationale": "Captures repeatable .NET Framework WaWorkerHost memory investigation steps and codifies exception placeholder misinterpretation avoidance.",
  "priority": 70,
  "audience": "engineers",
  "requirement": "recommended",
  "categories": [
    "azure-cloud-services",
    "diagnostics",
    "dotnet",
    "dump-analysis",
    "memory"
  ],
  "primaryCategory": "azure-cloud-services",
  "sourceHash": "61007ee5575bd87680edfb2ea7b8679dad7b785840e42e93903ac745dcb38ed9",
  "schemaVersion": "3",
  "createdAt": "2025-09-11T16:49:56.720Z",
  "updatedAt": "2025-09-11T16:49:56.720Z",
  "riskScore": 50,
  "owner": "unowned",
  "priorityTier": "P2",
  "classification": "internal",
  "version": "1.0.0",
  "status": "approved",
  "lastReviewedAt": "2025-09-11T16:49:56.720Z",
  "nextReviewDue": "2025-11-10T16:49:56.720Z",
  "reviewIntervalDays": 60,
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-11T16:49:56.720Z",
      "summary": "initial import"
    }
  ],
  "semanticSummary": "# WaWorkerHost .NET Memory Dump Analysis Pattern - Placeholder Exceptions & Growth Investigation"
}