{
  "id": "practical-agent-implementation-patterns",
  "title": "Practical Code Patterns for AI Agent Implementation",
  "body": "# Practical Code Patterns for AI Agent Implementation\n\n## Overview\nConcrete, executable code patterns for implementing AI agent behaviors, tool coordination, and user interaction patterns in real-world scenarios.\n\n## Agent State Management\n\n### 1. Robust Agent State Pattern\n```typescript\ninterface AgentState {\n  id: string;\n  status: 'idle' | 'processing' | 'waiting' | 'error' | 'paused';\n  currentTask?: TaskInfo;\n  context: Record<string, any>;\n  capabilities: string[];\n  metrics: {\n    tasksCompleted: number;\n    averageResponseTime: number;\n    errorRate: number;\n    lastActivity: Date;\n  };\n}\n\nclass StatefulAgent {\n  private state: AgentState;\n  private stateChangeListeners: Array<(oldState: AgentState, newState: AgentState) => void> = [];\n  \n  constructor(id: string, capabilities: string[]) {\n    this.state = {\n      id,\n      status: 'idle',\n      context: {},\n      capabilities,\n      metrics: {\n        tasksCompleted: 0,\n        averageResponseTime: 0,\n        errorRate: 0,\n        lastActivity: new Date()\n      }\n    };\n  }\n  \n  async executeTask(task: TaskInfo): Promise<TaskResult> {\n    const oldState = { ...this.state };\n    \n    try {\n      this.updateState({ status: 'processing', currentTask: task });\n      \n      const startTime = Date.now();\n      const result = await this.processTask(task);\n      const duration = Date.now() - startTime;\n      \n      // Update metrics\n      this.updateMetrics(duration, true);\n      this.updateState({ status: 'idle', currentTask: undefined });\n      \n      return result;\n    } catch (error) {\n      this.updateMetrics(0, false);\n      this.updateState({ status: 'error' });\n      throw error;\n    }\n  }\n  \n  private updateState(changes: Partial<AgentState>) {\n    const oldState = { ...this.state };\n    this.state = { ...this.state, ...changes };\n    this.state.metrics.lastActivity = new Date();\n    \n    // Notify listeners\n    this.stateChangeListeners.forEach(listener => {\n      try {\n        listener(oldState, this.state);\n      } catch (error) {\n        console.error('State change listener error:', error);\n      }\n    });\n  }\n}\n```\n\n### 2. PowerShell Agent Implementation\n```powershell\nclass PowerShellAgent {\n    [string]$Id\n    [string]$Status = 'Idle'\n    [hashtable]$Context = @{}\n    [array]$Capabilities = @()\n    [hashtable]$Metrics = @{}\n    [array]$TaskHistory = @()\n    \n    PowerShellAgent([string]$id, [array]$capabilities) {\n        $this.Id = $id\n        $this.Capabilities = $capabilities\n        $this.Metrics = @{\n            TasksCompleted = 0\n            AverageResponseTime = 0\n            ErrorRate = 0\n            LastActivity = Get-Date\n        }\n    }\n    \n    [object]ExecuteTask([hashtable]$task) {\n        $startTime = Get-Date\n        $this.Status = 'Processing'\n        $this.Context['CurrentTask'] = $task\n        \n        try {\n            Write-Host \"[Agent $($this.Id)] Starting task: $($task.Name)\" -ForegroundColor Cyan\n            \n            # Route to appropriate capability handler\n            $result = switch ($task.Type) {\n                'MCP' { $this.ExecuteMCPTask($task) }\n                'PowerShell' { $this.ExecutePowerShellTask($task) }\n                'Analysis' { $this.ExecuteAnalysisTask($task) }\n                'Coordination' { $this.ExecuteCoordinationTask($task) }\n                default { throw \"Unknown task type: $($task.Type)\" }\n            }\n            \n            # Update metrics\n            $duration = (Get-Date) - $startTime\n            $this.UpdateMetrics($duration, $true)\n            \n            # Log completion\n            $taskRecord = @{\n                TaskId = $task.Id\n                Type = $task.Type\n                Status = 'Completed'\n                Duration = $duration\n                Result = $result\n                CompletedAt = Get-Date\n            }\n            $this.TaskHistory += $taskRecord\n            \n            Write-Host \"[Agent $($this.Id)] Task completed in $($duration.TotalSeconds) seconds\" -ForegroundColor Green\n            return $result\n        }\n        catch {\n            $duration = (Get-Date) - $startTime\n            $this.UpdateMetrics($duration, $false)\n            \n            Write-Error \"[Agent $($this.Id)] Task failed: $($_.Exception.Message)\"\n            \n            $errorRecord = @{\n                TaskId = $task.Id\n                Type = $task.Type\n                Status = 'Failed'\n                Duration = $duration\n                Error = $_.Exception.Message\n                FailedAt = Get-Date\n            }\n            $this.TaskHistory += $errorRecord\n            \n            throw\n        }\n        finally {\n            $this.Status = 'Idle'\n            $this.Context.Remove('CurrentTask')\n            $this.Metrics.LastActivity = Get-Date\n        }\n    }\n    \n    [object]ExecuteMCPTask([hashtable]$task) {\n        $toolName = $task.Parameters.Tool\n        $parameters = $task.Parameters.Parameters\n        \n        Write-Host \"[Agent $($this.Id)] Executing MCP tool: $toolName\" -ForegroundColor Yellow\n        \n        # Validate tool capability\n        if ($toolName -notin $this.Capabilities) {\n            throw \"Agent does not have capability for tool: $toolName\"\n        }\n        \n        # Execute tool with error handling\n        $result = Invoke-MCPTool -Tool $toolName -Parameters $parameters\n        \n        return @{\n            Tool = $toolName\n            Parameters = $parameters\n            Result = $result\n            ExecutedBy = $this.Id\n            ExecutedAt = Get-Date\n        }\n    }\n}\n```\n\n## Tool Coordination Patterns\n\n### 3. MCP Tool Chain Execution\n```powershell\nfunction Invoke-MCPToolChain {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)][array]$ToolChain,\n        [hashtable]$InitialContext = @{},\n        [switch]$ContinueOnError,\n        [string]$ResumeFromStep = $null\n    )\n    \n    $executionContext = $InitialContext.Clone()\n    $results = @()\n    $startIndex = 0\n    \n    # Resume from specific step if requested\n    if ($ResumeFromStep) {\n        $startIndex = $ToolChain | ForEach-Object { $_.Name } | \n            FindIndex { $_ -eq $ResumeFromStep }\n        \n        if ($startIndex -eq -1) {\n            throw \"Resume step '$ResumeFromStep' not found in tool chain\"\n        }\n        \n        Write-Host \"Resuming tool chain from step $startIndex: $ResumeFromStep\" -ForegroundColor Cyan\n    }\n    \n    for ($i = $startIndex; $i -lt $ToolChain.Count; $i++) {\n        $step = $ToolChain[$i]\n        $stepName = $step.Name\n        \n        try {\n            Write-Host \"Executing step $($i + 1)/$($ToolChain.Count): $stepName\" -ForegroundColor Yellow\n            \n            # Prepare parameters with context injection\n            $parameters = $step.Parameters.Clone()\n            \n            # Inject context variables\n            foreach ($key in $executionContext.Keys) {\n                $placeholder = \"{{$key}}\"\n                $value = $executionContext[$key]\n                \n                # Replace placeholders in parameter values\n                foreach ($paramKey in $parameters.Keys) {\n                    if ($parameters[$paramKey] -is [string] -and $parameters[$paramKey].Contains($placeholder)) {\n                        $parameters[$paramKey] = $parameters[$paramKey].Replace($placeholder, $value)\n                    }\n                }\n            }\n            \n            # Execute tool\n            $stepResult = Invoke-MCPTool -Tool $step.Tool -Parameters $parameters\n            \n            # Store result\n            $result = @{\n                Step = $i + 1\n                Name = $stepName\n                Tool = $step.Tool\n                Parameters = $parameters\n                Result = $stepResult\n                Success = $true\n                ExecutedAt = Get-Date\n            }\n            \n            $results += $result\n            \n            # Update context with result\n            if ($step.OutputVariable) {\n                $executionContext[$step.OutputVariable] = $stepResult\n            }\n            \n            # Update context with named outputs\n            if ($step.OutputMapping) {\n                foreach ($mapping in $step.OutputMapping.GetEnumerator()) {\n                    $outputPath = $mapping.Value\n                    $contextKey = $mapping.Key\n                    \n                    # Extract value from result using path\n                    $value = Get-PropertyValue -Object $stepResult -Path $outputPath\n                    $executionContext[$contextKey] = $value\n                }\n            }\n            \n            Write-Host \"Step $stepName completed successfully\" -ForegroundColor Green\n        }\n        catch {\n            $error = $_.Exception.Message\n            Write-Error \"Step $stepName failed: $error\"\n            \n            $result = @{\n                Step = $i + 1\n                Name = $stepName\n                Tool = $step.Tool\n                Parameters = $parameters\n                Error = $error\n                Success = $false\n                ExecutedAt = Get-Date\n            }\n            \n            $results += $result\n            \n            if (-not $ContinueOnError) {\n                throw \"Tool chain execution failed at step $stepName. Use -ResumeFromStep '$stepName' to retry from this point.\"\n            }\n        }\n    }\n    \n    return @{\n        TotalSteps = $ToolChain.Count\n        ExecutedSteps = $results.Count\n        SuccessfulSteps = ($results | Where-Object Success).Count\n        FailedSteps = ($results | Where-Object { -not $_.Success }).Count\n        Results = $results\n        FinalContext = $executionContext\n        CompletedAt = Get-Date\n    }\n}\n```\n\n### 4. Dynamic Tool Selection\n```powershell\nfunction Select-OptimalTool {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)][string]$Objective,\n        [Parameter(Mandatory)][array]$AvailableTools,\n        [hashtable]$Context = @{},\n        [hashtable]$Constraints = @{}\n    )\n    \n    $scoredTools = @()\n    \n    foreach ($tool in $AvailableTools) {\n        $score = 0\n        $reasoning = @()\n        \n        # Capability match score\n        if ($tool.Capabilities -contains $Objective) {\n            $score += 10\n            $reasoning += \"Direct capability match\"\n        }\n        \n        # Related capability score\n        $relatedCapabilities = $tool.Capabilities | Where-Object { $_ -like \"*$($Objective.Split('-')[0])*\" }\n        if ($relatedCapabilities) {\n            $score += 5\n            $reasoning += \"Related capability ($($relatedCapabilities -join ', '))\"\n        }\n        \n        # Context compatibility\n        if ($Context.Keys) {\n            $compatibleInputs = $tool.RequiredInputs | Where-Object { $_ -in $Context.Keys }\n            if ($compatibleInputs) {\n                $score += ($compatibleInputs.Count * 2)\n                $reasoning += \"Compatible context inputs ($($compatibleInputs.Count))\"\n            }\n        }\n        \n        # Constraint compliance\n        $violatesConstraints = $false\n        foreach ($constraint in $Constraints.GetEnumerator()) {\n            switch ($constraint.Key) {\n                'MaxDuration' {\n                    if ($tool.EstimatedDuration -gt $constraint.Value) {\n                        $violatesConstraints = $true\n                        $reasoning += \"Violates duration constraint\"\n                    }\n                }\n                'RequiredCapabilities' {\n                    $missingCaps = $constraint.Value | Where-Object { $_ -notin $tool.Capabilities }\n                    if ($missingCaps) {\n                        $violatesConstraints = $true\n                        $reasoning += \"Missing required capabilities: $($missingCaps -join ', ')\"\n                    }\n                }\n                'ExcludedCategories' {\n                    if ($tool.Category -in $constraint.Value) {\n                        $violatesConstraints = $true\n                        $reasoning += \"Tool category excluded\"\n                    }\n                }\n            }\n        }\n        \n        if ($violatesConstraints) {\n            $score = 0\n        }\n        \n        # Performance history bonus\n        if ($tool.SuccessRate) {\n            $score += ($tool.SuccessRate * 3)\n            $reasoning += \"Success rate bonus ($($tool.SuccessRate)%)\"\n        }\n        \n        $scoredTools += @{\n            Tool = $tool\n            Score = $score\n            Reasoning = $reasoning\n            Eligible = -not $violatesConstraints\n        }\n    }\n    \n    # Sort by score and return best match\n    $bestMatch = $scoredTools | \n        Where-Object Eligible | \n        Sort-Object Score -Descending | \n        Select-Object -First 1\n    \n    if ($bestMatch) {\n        Write-Host \"Selected tool: $($bestMatch.Tool.Name) (score: $($bestMatch.Score))\" -ForegroundColor Green\n        Write-Host \"Reasoning: $($bestMatch.Reasoning -join '; ')\" -ForegroundColor Gray\n        return $bestMatch.Tool\n    } else {\n        Write-Warning \"No suitable tool found for objective: $Objective\"\n        return $null\n    }\n}\n```\n\n## User Interaction Patterns\n\n### 5. Progressive Disclosure UI\n```typescript\nclass ProgressiveTaskInterface {\n  private taskState: TaskState;\n  private userPreferences: UserPreferences;\n  \n  async presentTask(task: TaskInfo): Promise<TaskResult> {\n    // Start with minimal information\n    const summary = this.createTaskSummary(task);\n    const userResponse = await this.promptUser({\n      message: `I can help you with: ${summary}. Shall I proceed?`,\n      options: ['Yes', 'Tell me more', 'Customize approach', 'Cancel']\n    });\n    \n    switch (userResponse) {\n      case 'Yes':\n        return this.executeWithDefaults(task);\n        \n      case 'Tell me more':\n        return this.presentDetailedPlan(task);\n        \n      case 'Customize approach':\n        return this.presentCustomizationOptions(task);\n        \n      case 'Cancel':\n        return { status: 'cancelled', reason: 'User cancelled' };\n    }\n  }\n  \n  private async presentDetailedPlan(task: TaskInfo): Promise<TaskResult> {\n    const plan = this.generateExecutionPlan(task);\n    \n    const planPresentation = {\n      overview: plan.summary,\n      steps: plan.steps.map(step => ({\n        description: step.description,\n        estimatedTime: step.estimatedTime,\n        requirements: step.requirements\n      })),\n      estimatedDuration: plan.totalDuration,\n      risks: plan.identifiedRisks\n    };\n    \n    const response = await this.promptUser({\n      message: 'Here\\'s my detailed plan:',\n      data: planPresentation,\n      options: ['Proceed with plan', 'Modify plan', 'Cancel']\n    });\n    \n    switch (response) {\n      case 'Proceed with plan':\n        return this.executeWithPlan(task, plan);\n      case 'Modify plan':\n        return this.customizePlan(task, plan);\n      default:\n        return { status: 'cancelled' };\n    }\n  }\n}\n```\n\n### 6. PowerShell Interactive Pattern\n```powershell\nfunction Start-InteractiveTask {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)][hashtable]$Task,\n        [switch]$AutoApprove = $false\n    )\n    \n    if (-not $AutoApprove) {\n        # Present task overview\n        Write-Host \"`n=== Task Overview ===\" -ForegroundColor Cyan\n        Write-Host \"Objective: $($Task.Objective)\" -ForegroundColor White\n        Write-Host \"Estimated Duration: $($Task.EstimatedDuration)\" -ForegroundColor Gray\n        \n        if ($Task.Requirements) {\n            Write-Host \"Requirements:\" -ForegroundColor Yellow\n            $Task.Requirements | ForEach-Object { Write-Host \"  - $_\" -ForegroundColor Gray }\n        }\n        \n        if ($Task.Risks) {\n            Write-Host \"Potential Risks:\" -ForegroundColor Red\n            $Task.Risks | ForEach-Object { Write-Host \"  - $_\" -ForegroundColor Gray }\n        }\n        \n        # Get user approval\n        $approval = Read-Host \"`nProceed with this task? (y/n/details)\"\n        \n        switch ($approval.ToLower()) {\n            'n' { \n                Write-Host \"Task cancelled by user\" -ForegroundColor Yellow\n                return @{ Status = 'Cancelled'; Reason = 'User declined' }\n            }\n            'details' {\n                Show-TaskDetails -Task $Task\n                return Start-InteractiveTask -Task $Task  # Recursive call after showing details\n            }\n            default {\n                Write-Host \"Proceeding with task...\" -ForegroundColor Green\n            }\n        }\n    }\n    \n    # Execute task with progress updates\n    try {\n        $result = Invoke-TaskWithProgress -Task $Task -ProgressCallback {\n            param($step, $progress)\n            \n            Write-Progress -Activity \"Executing: $($Task.Objective)\" -Status $step -PercentComplete $progress\n            \n            # Optional user intervention points\n            if ($step -like \"*requires confirmation*\") {\n                $confirm = Read-Host \"$step - Continue? (y/n)\"\n                if ($confirm.ToLower() -eq 'n') {\n                    throw \"Task cancelled by user at step: $step\"\n                }\n            }\n        }\n        \n        Write-Progress -Activity \"Executing: $($Task.Objective)\" -Completed\n        Write-Host \"Task completed successfully!\" -ForegroundColor Green\n        \n        return $result\n    }\n    catch {\n        Write-Progress -Activity \"Executing: $($Task.Objective)\" -Completed\n        Write-Error \"Task failed: $($_.Exception.Message)\"\n        \n        # Offer recovery options\n        $recovery = Read-Host \"Task failed. Options: (r)etry, (m)odify approach, (c)ancel\"\n        \n        switch ($recovery.ToLower()) {\n            'r' { \n                Write-Host \"Retrying task...\" -ForegroundColor Yellow\n                return Start-InteractiveTask -Task $Task\n            }\n            'm' {\n                $modifiedTask = Get-ModifiedTaskApproach -Task $Task -Error $_.Exception.Message\n                return Start-InteractiveTask -Task $modifiedTask\n            }\n            default {\n                return @{ Status = 'Failed'; Error = $_.Exception.Message; Cancelled = $true }\n            }\n        }\n    }\n}\n```\n\n## Error Recovery Patterns\n\n### 7. Resilient Execution Pattern\n```powershell\nfunction Invoke-ResilientExecution {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)][scriptblock]$ScriptBlock,\n        [int]$MaxRetries = 3,\n        [int]$BaseDelaySeconds = 2,\n        [array]$RetriableErrors = @('timeout', 'network', 'temporary'),\n        [scriptblock]$RecoveryAction = $null\n    )\n    \n    $attempt = 0\n    $lastError = $null\n    \n    do {\n        $attempt++\n        \n        try {\n            Write-Host \"Attempt $attempt/$($MaxRetries + 1)\" -ForegroundColor Cyan\n            \n            $result = & $ScriptBlock\n            \n            if ($attempt -gt 1) {\n                Write-Host \"Operation succeeded on attempt $attempt\" -ForegroundColor Green\n            }\n            \n            return $result\n        }\n        catch {\n            $lastError = $_\n            $errorMessage = $_.Exception.Message.ToLower()\n            \n            # Check if error is retriable\n            $isRetriable = $RetriableErrors | Where-Object { $errorMessage.Contains($_) }\n            \n            if ($isRetriable -and $attempt -le $MaxRetries) {\n                $delay = $BaseDelaySeconds * [Math]::Pow(2, $attempt - 1)  # Exponential backoff\n                \n                Write-Warning \"Retriable error on attempt $attempt: $($_.Exception.Message)\"\n                Write-Host \"Waiting $delay seconds before retry...\" -ForegroundColor Yellow\n                \n                Start-Sleep -Seconds $delay\n                \n                # Execute recovery action if provided\n                if ($RecoveryAction) {\n                    try {\n                        Write-Host \"Executing recovery action...\" -ForegroundColor Cyan\n                        & $RecoveryAction\n                    }\n                    catch {\n                        Write-Warning \"Recovery action failed: $($_.Exception.Message)\"\n                    }\n                }\n            }\n            else {\n                if ($attempt -gt $MaxRetries) {\n                    Write-Error \"Operation failed after $MaxRetries retries. Last error: $($_.Exception.Message)\"\n                } else {\n                    Write-Error \"Non-retriable error: $($_.Exception.Message)\"\n                }\n                throw\n            }\n        }\n    } while ($attempt -le $MaxRetries)\n    \n    throw $lastError\n}\n```\n\n## Best Practices Summary\n\n### Code Quality\n- Always include comprehensive error handling\n- Implement proper logging and progress reporting\n- Use type safety where available (TypeScript interfaces, PowerShell parameter validation)\n- Follow consistent naming conventions\n\n### User Experience\n- Provide clear, actionable progress updates\n- Offer meaningful choices and customization options\n- Implement graceful degradation for failures\n- Allow users to pause, resume, or cancel long-running operations\n\n### Performance\n- Implement caching for expensive operations\n- Use asynchronous patterns where appropriate\n- Batch operations when possible\n- Monitor and optimize resource usage\n\n### Reliability\n- Implement retry logic with exponential backoff\n- Provide state persistence for resumability\n- Validate inputs and outputs\n- Include comprehensive test coverage\n\n### Maintainability\n- Use modular, composable design patterns\n- Document complex logic and decision points\n- Implement configurable behavior\n- Follow established coding standards",
  "rationale": "Provides concrete, executable code patterns for implementing robust AI agent behaviors and interactions",
  "priority": 80,
  "audience": "developers",
  "requirement": "recommended",
  "categories": [
    "agent-development",
    "best-practices",
    "code-patterns",
    "implementation",
    "practical-examples"
  ],
  "primaryCategory": "agent-development",
  "sourceHash": "6b81e5683550f85b32e9e6e64c84565a948b82c65b7c8f6082a7989d7df3de65",
  "schemaVersion": "3",
  "createdAt": "2025-09-12T12:15:19.959Z",
  "updatedAt": "2025-09-12T12:15:19.959Z",
  "riskScore": 40,
  "version": "1.0.0",
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-12T12:15:19.959Z",
      "summary": "initial import"
    }
  ],
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P4",
  "classification": "internal",
  "lastReviewedAt": "2025-09-12T12:15:19.960Z",
  "nextReviewDue": "2026-01-10T12:15:19.960Z",
  "reviewIntervalDays": 120,
  "semanticSummary": "# Practical Code Patterns for AI Agent Implementation"
}