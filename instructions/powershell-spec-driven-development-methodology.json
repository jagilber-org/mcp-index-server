{
  "id": "powershell-spec-driven-development-methodology",
  "title": "PowerShell Script Development using Spec-Driven Development Methodology",
  "body": "# PowerShell Script Development using Spec-Driven Development Methodology\n\n## Overview\nAdapt GitHub's Spec-Driven Development (SDD) methodology for PowerShell script development, emphasizing executable specifications that generate implementation rather than merely guiding it. This methodology transforms PowerShell development from code-first to specification-first approaches.\n\n## Core SDD Principles for PowerShell\n\n### 1. Specifications as the Lingua Franca\n- **PowerShell Intent**: Scripts start as clear, testable specifications describing what the script should accomplish\n- **User Stories**: Define automation scenarios in business terms before technical implementation\n- **Acceptance Criteria**: Measurable, testable outcomes for each PowerShell script functionality\n\n### 2. Executable Specifications\n- **Specification Structure**: Use structured templates that can generate working PowerShell code\n- **Parameter Definitions**: Define script parameters with validation, help text, and examples in specification\n- **Behavior Mapping**: Map user requirements directly to PowerShell cmdlet sequences and logic flows\n\n### 3. Test-First Implementation\n- **Pester Integration**: Generate Pester tests from specifications before writing implementation code\n- **Validation Scripts**: Create test scenarios that validate script behavior against specifications\n- **Continuous Validation**: Ensure specifications and implementation remain synchronized\n\n## SDD Workflow for PowerShell Development\n\n### Phase 1: Specification Creation\n\n#### PowerShell Script Specification Template\n```markdown\n# Script Specification: [SCRIPT-NAME]\n\n**Created**: [DATE]\n**Status**: Draft\n**Input**: User requirement: \"[REQUIREMENT]\"\n\n## User Scenarios & Testing\n\n### Primary User Story\nAs a [ROLE], I want to [ACTION] so that [BENEFIT].\n\n### Acceptance Scenarios\n1. **Given** [initial state], **When** [PowerShell script executed], **Then** [expected outcome]\n2. **Given** [error condition], **When** [script executed], **Then** [error handling behavior]\n\n### Edge Cases\n- What happens when [boundary condition]?\n- How does script handle [error scenario]?\n\n## Functional Requirements\n\n### Script Behavior\n- **SR-001**: Script MUST [specific capability]\n- **SR-002**: Script MUST validate [input parameters]\n- **SR-003**: Script MUST handle [error conditions]\n- **SR-004**: Script MUST provide [output format]\n- **SR-005**: Script MUST support [execution modes]\n\n### Parameter Requirements\n- **[ParameterName]**: [Type] - [Description] - [Validation Rules]\n- **[ParameterName]**: [Type] - [Description] - [Default Value]\n\n### Output Requirements\n- **Format**: [Object/Text/JSON/XML]\n- **Structure**: [Defined schema or format]\n- **Error Handling**: [How errors are reported]\n\n## Technical Constraints\n- **PowerShell Version**: [Minimum version required]\n- **Module Dependencies**: [Required modules]\n- **Execution Policy**: [Requirements]\n- **Platform Support**: [Windows/Linux/macOS]\n\n## Review Checklist\n- [ ] Requirements are testable and unambiguous\n- [ ] All parameters have validation rules\n- [ ] Error scenarios are defined\n- [ ] Output format is specified\n- [ ] No implementation details in specification\n```\n\n### Phase 2: Technical Planning\n\n#### PowerShell Implementation Plan Template\n```markdown\n# Implementation Plan: [SCRIPT-NAME]\n\n## Architecture Decisions\n\n### Module Structure\n- **Script Type**: [Simple Script/Advanced Function/Module]\n- **Dependencies**: [Required modules and versions]\n- **Error Handling**: [Strategy and patterns]\n\n### Parameter Design\n```powershell\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory=$true, HelpMessage=\"[Help text]\")]\n    [ValidateSet(\"Option1\", \"Option2\")]\n    [string]$ParameterName,\n    \n    [Parameter()]\n    [ValidateRange(1, 100)]\n    [int]$Count = 10\n)\n```\n\n### Implementation Phases\n\n#### Phase 1: Core Function Implementation\n- [ ] Parameter validation logic\n- [ ] Core business logic\n- [ ] Basic error handling\n\n#### Phase 2: Enhanced Features\n- [ ] Advanced parameter sets\n- [ ] Pipeline support\n- [ ] Verbose/Debug output\n\n#### Phase 3: Testing & Documentation\n- [ ] Pester tests implementation\n- [ ] Comment-based help\n- [ ] Usage examples\n\n### Test Implementation Strategy\n\n#### Unit Tests (Pester)\n```powershell\nDescribe \"[SCRIPT-NAME] Tests\" {\n    Context \"Parameter Validation\" {\n        It \"Should accept valid parameters\" {\n            # Test implementation\n        }\n        \n        It \"Should reject invalid parameters\" {\n            # Test implementation\n        }\n    }\n    \n    Context \"Core Functionality\" {\n        It \"Should perform expected operation\" {\n            # Test implementation\n        }\n    }\n    \n    Context \"Error Handling\" {\n        It \"Should handle [specific error condition]\" {\n            # Test implementation\n        }\n    }\n}\n```\n\n## Constitutional Compliance\n\n### PowerShell Constitution Articles\n\n#### Article I: Function-First Principle\nEvery script feature MUST begin as a reusable function with clear parameters and return values.\n\n#### Article II: Help Documentation Mandate\nAll functions MUST include complete comment-based help with examples and parameter descriptions.\n\n#### Article III: Test-First Imperative\nNo implementation code SHALL be written before:\n1. Pester tests are written and validated\n2. Tests are confirmed to FAIL (Red phase)\n3. Implementation makes tests PASS (Green phase)\n\n#### Article IV: Parameter Validation\nAll script parameters MUST include appropriate validation attributes and help text.\n\n#### Article V: Error Handling Standards\nScripts MUST handle errors gracefully with appropriate error records and actionable messages.\n\n#### Article VI: Pipeline Support\nWhere applicable, functions SHOULD support pipeline input and output.\n\n#### Article VII: Cross-Platform Compatibility\nScripts SHOULD work across PowerShell Core platforms unless platform-specific functionality is required.\n\n### Complexity Gates\n\n```markdown\n#### Simplicity Gate (Article I)\n- [ ] Single responsibility per function?\n- [ ] Minimal parameter complexity?\n- [ ] No premature optimization?\n\n#### Documentation Gate (Article II)\n- [ ] Complete comment-based help?\n- [ ] Parameter documentation?\n- [ ] Usage examples provided?\n\n#### Testing Gate (Article III)\n- [ ] Pester tests written first?\n- [ ] All scenarios covered?\n- [ ] Tests pass consistently?\n```\n\n## Implementation Generation\n\n### From Specification to Code\n\n1. **Parameter Generation**: Convert specification parameters to PowerShell parameter definitions\n2. **Logic Flow**: Map user scenarios to PowerShell logic structures\n3. **Test Generation**: Create Pester tests from acceptance scenarios\n4. **Documentation**: Generate comment-based help from specification\n\n### Example Transformation\n\n**Specification Requirement**:\n```\nSR-001: Script MUST validate Azure resource group exists before proceeding\n```\n\n**Generated Implementation**:\n```powershell\nfunction Test-AzureResourceGroup {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory=$true)]\n        [ValidateNotNullOrEmpty()]\n        [string]$ResourceGroupName\n    )\n    \n    try {\n        $rg = Get-AzResourceGroup -Name $ResourceGroupName -ErrorAction Stop\n        return $true\n    }\n    catch {\n        Write-Error \"Resource group '$ResourceGroupName' not found: $($_.Exception.Message)\"\n        return $false\n    }\n}\n```\n\n**Generated Test**:\n```powershell\nDescribe \"Test-AzureResourceGroup\" {\n    It \"Should return true for existing resource group\" {\n        Mock Get-AzResourceGroup { return @{Name = \"TestRG\"} }\n        Test-AzureResourceGroup -ResourceGroupName \"TestRG\" | Should -Be $true\n    }\n    \n    It \"Should return false for non-existing resource group\" {\n        Mock Get-AzResourceGroup { throw \"Resource group not found\" }\n        Test-AzureResourceGroup -ResourceGroupName \"NonExistentRG\" | Should -Be $false\n    }\n}\n```\n\n## Best Practices Integration\n\n### PowerShell Specific Patterns\n\n#### 1. Cmdlet Design Patterns\n```powershell\n# Follow PowerShell naming conventions\nVerb-Noun format (Get-Something, Set-Something, New-Something)\n\n# Support common parameters\n[CmdletBinding(SupportsShouldProcess, SupportsTransactions)]\n\n# Implement proper parameter sets\n[Parameter(ParameterSetName=\"ByName\")]\n[Parameter(ParameterSetName=\"ById\")]\n```\n\n#### 2. Error Handling Patterns\n```powershell\n# Use appropriate error actions\ntry {\n    Get-Item $Path -ErrorAction Stop\n}\ncatch [System.Management.Automation.ItemNotFoundException] {\n    Write-Error \"File not found: $Path\" -Category ObjectNotFound\n}\ncatch {\n    throw  # Re-throw unexpected errors\n}\n```\n\n#### 3. Output Patterns\n```powershell\n# Return structured objects\n[PSCustomObject]@{\n    Name = $name\n    Status = $status\n    Timestamp = Get-Date\n    Details = $details\n}\n\n# Support Format-Table/Format-List\n$result | Format-Table Name, Status, Timestamp\n```\n\n### Integration with MCP Tools\n\n#### PowerShell MCP Server Integration\n```powershell\n# Use MCP PowerShell server for syntax validation\n# Before implementation: validate specification-generated code\n$syntaxCheck = Invoke-MCPTool -Tool \"powershell-syntax-check\" -Code $generatedCode\n\n# Use controlled execution for testing\n$testResult = Invoke-MCPTool -Tool \"run-powershell\" -Script $testScript\n```\n\n#### Azure MCP Integration\n```powershell\n# Validate Azure operations in specifications\n$azureValidation = Invoke-MCPTool -Tool \"kusto\" -Query $validationQuery\n```\n\n## Maintenance and Evolution\n\n### Specification Versioning\n- **Version Control**: Track specification changes with semantic versioning\n- **Change Impact**: Assess how specification changes affect implementation\n- **Regeneration**: Use updated specifications to regenerate improved implementations\n\n### Continuous Improvement\n- **Feedback Loop**: Production metrics inform specification refinements\n- **Performance Optimization**: Specifications include performance requirements\n- **Security Updates**: Security findings update specification security requirements\n\n## Success Metrics\n\n### Development Velocity\n- Time from specification to working implementation\n- Reduction in implementation bugs through specification clarity\n- Faster onboarding of new team members through clear specifications\n\n### Quality Improvements\n- Consistency across PowerShell scripts through specification templates\n- Reduced support tickets through better documentation\n- Improved test coverage through specification-driven testing\n\n### Maintenance Benefits\n- Easier script updates through specification modifications\n- Clear change impact assessment\n- Reduced technical debt through architectural consistency\n\n## Integration with Repository Patterns\n\n### File Organization\n```\nscripts/\n├── specs/\n│   ├── 001-azure-vm-manager/\n│   │   ├── spec.md\n│   │   ├── plan.md\n│   │   └── tests.md\n│   └── 002-log-analyzer/\n│       ├── spec.md\n│       └── plan.md\n├── src/\n│   ├── azure-vm-manager.ps1\n│   └── log-analyzer.ps1\n└── tests/\n    ├── azure-vm-manager.Tests.ps1\n    └── log-analyzer.Tests.ps1\n```\n\n### Development Commands\n```powershell\n# Generate new script specification\n./tools/New-ScriptSpec.ps1 -Name \"azure-vm-manager\" -Description \"Manage Azure VMs\"\n\n# Generate implementation from specification\n./tools/New-ScriptFromSpec.ps1 -SpecPath \"specs/001-azure-vm-manager/spec.md\"\n\n# Validate specification compliance\n./tools/Test-SpecCompliance.ps1 -ScriptPath \"src/azure-vm-manager.ps1\"\n```\n\nThis SDD methodology for PowerShell development ensures scripts are:\n- **Specification-driven**: Clear requirements before implementation\n- **Test-first**: Comprehensive testing validates behavior\n- **Maintainable**: Structured approach enables easy updates\n- **Consistent**: Templates ensure uniform quality\n- **Documented**: Specifications serve as living documentation\n\nBy following these patterns, PowerShell development becomes more predictable, reliable, and aligned with business requirements while maintaining the flexibility and power that makes PowerShell effective for automation tasks.",
  "priority": 85,
  "audience": "all",
  "requirement": "recommended",
  "categories": [
    "best-practices",
    "development-workflow",
    "methodology",
    "powershell",
    "spec-driven-development"
  ],
  "sourceHash": "fa1fbc9b7cc4d5f7b9a2ce6d1dc85503335e3d550cedcd84d768b42b5743f35f",
  "schemaVersion": "3",
  "createdAt": "2025-09-05T15:27:08.772Z",
  "updatedAt": "2025-09-05T15:27:08.772Z",
  "riskScore": 35,
  "version": "1.0.0",
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P4",
  "classification": "internal",
  "lastReviewedAt": "2025-09-05T15:27:08.772Z",
  "nextReviewDue": "2026-01-03T15:27:08.772Z",
  "reviewIntervalDays": 120,
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-05T15:27:08.772Z",
      "summary": "initial import"
    }
  ],
  "semanticSummary": "# PowerShell Script Development using Spec-Driven Development Methodology",
  "primaryCategory": "best-practices"
}