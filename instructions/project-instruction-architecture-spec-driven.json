{
  "id": "project-instruction-architecture-spec-driven",
  "title": "Project Instruction Architecture using Spec-Driven Development Patterns",
  "body": "# Project Instruction Architecture using Spec-Driven Development Patterns\n\n## Overview\nImplement a comprehensive instruction architecture for software projects using Spec-Driven Development patterns adapted from GitHub's spec-kit methodology. This architecture ensures that project instructions are executable, maintainable, and directly generate implementation guidance rather than merely describing it.\n\n## Instruction Hierarchy and Authority\n\n### Constitutional Layer (Immutable Principles)\n```markdown\n# Project Constitution\n\n## Core Development Principles\n\n### I. Specification-First Development\nAll features MUST begin as executable specifications that generate implementation.\n\n### II. Instruction Authority Hierarchy\n1. Project Constitution (immutable)\n2. Local Project Instructions (project-specific)\n3. Technology Stack Instructions (language/framework specific)\n4. General Best Practice Instructions (external references)\n\n### III. Test-Driven Implementation\nNo implementation code SHALL be written before:\n1. Specifications are complete and validated\n2. Tests are written from specifications\n3. Tests are confirmed to FAIL (Red phase)\n\n### IV. Living Documentation Principle\nInstructions MUST remain synchronized with implementation through automated validation.\n\n### V. Instruction Versioning\nAll instruction changes MUST be versioned with clear change rationale and migration paths.\n```\n\n### Project-Specific Instructions Layer\n```markdown\n# Project-Specific Instructions\n\n## Technology Stack Integration\n- **Primary Language**: [PowerShell/TypeScript/C#]\n- **MCP Integration**: Mandatory for development tooling\n- **Testing Framework**: [Pester/Jest/xUnit]\n- **Deployment Strategy**: [Azure/Cloud/On-premises]\n\n## Project Architecture Patterns\n- **Module Structure**: Feature-based organization\n- **Configuration Management**: Environment-specific configs\n- **Error Handling**: Consistent patterns across all components\n- **Logging Strategy**: Structured logging with correlation IDs\n\n## Development Workflow\n1. **Feature Specification**: Create spec using project templates\n2. **Implementation Planning**: Generate technical plan from spec\n3. **Test Development**: Create tests from specification scenarios\n4. **Implementation**: Build feature to make tests pass\n5. **Documentation**: Update project instructions if needed\n```\n\n## Specification Templates and Patterns\n\n### Feature Specification Template\n```markdown\n# Feature Specification: [FEATURE-NAME]\n\n**Feature Branch**: `[###-feature-name]`\n**Created**: [DATE]\n**Status**: [Draft/Review/Approved/Implemented]\n**Priority**: [P0-Critical/P1-High/P2-Medium/P3-Low]\n\n## Executive Summary\n[One paragraph describing the feature and its business value]\n\n## User Stories and Acceptance Criteria\n\n### Primary User Story\nAs a [ROLE], I want to [ACTION] so that [BENEFIT].\n\n### Acceptance Scenarios\n1. **Given** [initial state], **When** [action], **Then** [expected outcome]\n2. **Given** [error condition], **When** [action], **Then** [error handling]\n3. **Given** [edge case], **When** [action], **Then** [boundary behavior]\n\n### Success Metrics\n- [Measurable outcome 1]\n- [Measurable outcome 2]\n- [Performance/Quality metric]\n\n## Functional Requirements\n\n### Core Functionality\n- **FR-001**: System MUST [specific requirement]\n- **FR-002**: System MUST validate [input/constraint]\n- **FR-003**: System MUST handle [error condition]\n- **FR-004**: System MUST provide [output/feedback]\n\n### Non-Functional Requirements\n- **NFR-001**: Performance - [specific metric and target]\n- **NFR-002**: Security - [specific security requirement]\n- **NFR-003**: Usability - [specific usability requirement]\n- **NFR-004**: Maintainability - [specific maintenance requirement]\n\n## Technical Constraints\n- **Technology Stack**: [Required technologies]\n- **Dependencies**: [External dependencies and versions]\n- **Platform Requirements**: [OS/Runtime requirements]\n- **Integration Points**: [Required integrations]\n\n## Review and Validation\n\n### Specification Completeness\n- [ ] All user scenarios defined and testable\n- [ ] Requirements are unambiguous and measurable\n- [ ] Success criteria are clearly defined\n- [ ] Technical constraints are documented\n- [ ] No implementation details in specification\n\n### Stakeholder Approval\n- [ ] Product Owner approval\n- [ ] Technical Lead approval\n- [ ] Architecture review completed\n- [ ] Security review completed (if required)\n```\n\n### Implementation Plan Template\n```markdown\n# Implementation Plan: [FEATURE-NAME]\n\n**Specification**: [Link to feature specification]\n**Implementation Branch**: `[###-feature-name]`\n**Estimated Effort**: [Story points/Hours]\n**Dependencies**: [Blocking items]\n\n## Architecture Decisions\n\n### Technology Choices\n- **Primary Technology**: [Language/Framework] - [Rationale]\n- **Testing Strategy**: [Framework/Approach] - [Rationale]\n- **Data Storage**: [Technology/Pattern] - [Rationale]\n- **Integration Pattern**: [Approach] - [Rationale]\n\n### Design Patterns\n- **Primary Patterns**: [Pattern names and usage]\n- **Error Handling**: [Strategy and implementation]\n- **Configuration**: [Management approach]\n- **Logging**: [Strategy and structured format]\n\n## Implementation Phases\n\n### Phase 1: Foundation (TDD Red Phase)\n- [ ] Create test infrastructure\n- [ ] Implement failing tests from specification\n- [ ] Validate test coverage completeness\n- [ ] Confirm all tests fail appropriately\n\n### Phase 2: Core Implementation (TDD Green Phase)\n- [ ] Implement minimum viable functionality\n- [ ] Make core tests pass\n- [ ] Handle basic error conditions\n- [ ] Validate against acceptance criteria\n\n### Phase 3: Enhancement and Polish (TDD Refactor Phase)\n- [ ] Refactor for maintainability\n- [ ] Add comprehensive error handling\n- [ ] Implement performance optimizations\n- [ ] Add comprehensive logging\n\n### Phase 4: Integration and Validation\n- [ ] Integration testing\n- [ ] End-to-end scenario validation\n- [ ] Performance testing\n- [ ] Security validation\n\n## Testing Strategy\n\n### Unit Testing\n```powershell/typescript/csharp\n# Example test structure based on specification\nDescribe \"[FEATURE-NAME] Core Functionality\" {\n    Context \"When [scenario from specification]\" {\n        It \"Should [expected behavior from acceptance criteria]\" {\n            # Test implementation\n        }\n    }\n    \n    Context \"Error Handling\" {\n        It \"Should [error behavior from specification]\" {\n            # Error test implementation\n        }\n    }\n}\n```\n\n### Integration Testing\n- [ ] API contract validation\n- [ ] External dependency interaction\n- [ ] End-to-end user scenario testing\n- [ ] Performance and load testing\n\n## Definition of Done\n\n### Implementation Criteria\n- [ ] All acceptance criteria met and validated\n- [ ] Test coverage meets project standards (>90%)\n- [ ] Code review completed and approved\n- [ ] Documentation updated (inline and external)\n- [ ] Performance requirements met\n- [ ] Security requirements validated\n\n### Quality Gates\n- [ ] No critical security vulnerabilities\n- [ ] Performance benchmarks met\n- [ ] Code quality metrics satisfied\n- [ ] Integration tests pass\n- [ ] Manual testing completed\n\n## Risk Assessment and Mitigation\n\n### Technical Risks\n- **Risk**: [Description] - **Probability**: [H/M/L] - **Impact**: [H/M/L]\n  - **Mitigation**: [Strategy]\n- **Risk**: [Description] - **Probability**: [H/M/L] - **Impact**: [H/M/L]\n  - **Mitigation**: [Strategy]\n\n### Dependencies and Blockers\n- **Dependency**: [Description] - **Owner**: [Person/Team] - **ETA**: [Date]\n- **Blocker**: [Description] - **Resolution Plan**: [Strategy]\n```\n\n## MCP Integration Patterns\n\n### MCP Tool Integration Architecture\n```markdown\n# MCP Integration Strategy\n\n## Tool Categories and Usage\n\n### Development Tools (mcp_powershell-mc_*)\n- **powershell-syntax-check**: Validate script syntax during development\n- **run-powershell**: Execute scripts in controlled environment\n- **server-stats**: Monitor development tool performance\n\n### Azure Operations (Azure MCP Server)\n- **kusto**: Query telemetry for validation and monitoring\n- **monitor**: Track performance metrics and alerts\n- **activity_log**: Audit and compliance tracking\n\n### Code Analysis (VS Code Tools)\n- **semantic_search**: Find related code and patterns\n- **list_code_usages**: Impact analysis for changes\n- **get_errors**: Code quality validation\n\n### Project Management (GitHub/Azure DevOps)\n- **create_issue**: Track implementation tasks\n- **build_get_status**: Monitor CI/CD pipeline health\n- **get_workflow_run_logs**: Debug deployment issues\n\n## Integration Patterns\n\n### Specification Validation\n```powershell\n# Validate PowerShell specifications using MCP tools\n$specValidation = @{\n    SyntaxCheck = Invoke-MCPTool -Tool \"powershell-syntax-check\" -Code $generatedCode\n    TestExecution = Invoke-MCPTool -Tool \"run-powershell\" -Script $testScript\n    CodeAnalysis = Invoke-MCPTool -Tool \"semantic_search\" -Query $analysisQuery\n}\n```\n\n### Automated Implementation Generation\n```powershell\n# Generate implementation from specification\nfunction New-ImplementationFromSpec {\n    param(\n        [string]$SpecificationPath,\n        [string]$OutputPath\n    )\n    \n    # Parse specification\n    $spec = Import-Specification $SpecificationPath\n    \n    # Generate code structure\n    $implementation = ConvertTo-Implementation $spec\n    \n    # Validate generated code\n    $validation = Invoke-MCPTool -Tool \"powershell-syntax-check\" -Code $implementation\n    \n    if ($validation.Success) {\n        $implementation | Out-File $OutputPath\n        Write-Output \"Implementation generated successfully\"\n    } else {\n        Write-Error \"Generated code failed validation: $($validation.Errors)\"\n    }\n}\n```\n\n### Continuous Validation\n```powershell\n# Validate specification-implementation alignment\nfunction Test-SpecificationCompliance {\n    param(\n        [string]$SpecPath,\n        [string]$ImplementationPath\n    )\n    \n    # Extract requirements from specification\n    $requirements = Get-SpecificationRequirements $SpecPath\n    \n    # Analyze implementation\n    $analysis = Invoke-MCPTool -Tool \"list_code_usages\" -SymbolName $requirements.Functions\n    \n    # Compare specification vs implementation\n    $compliance = Compare-SpecToImplementation $requirements $analysis\n    \n    return $compliance\n}\n```\n```\n\n## Project Organization Structure\n\n### Directory Structure\n```\nproject-root/\n├── .instructions/\n│   ├── constitution.md                    # Immutable principles\n│   ├── project-instructions.md            # Project-specific guidance\n│   ├── technology-stack-instructions.md   # Tech stack best practices\n│   └── local/\n│       ├── development-workflow.md        # Local development patterns\n│       ├── testing-standards.md          # Project testing requirements\n│       └── deployment-process.md         # Deployment procedures\n├── specs/\n│   ├── 001-feature-name/\n│   │   ├── specification.md               # Feature specification\n│   │   ├── implementation-plan.md         # Technical implementation plan\n│   │   ├── test-scenarios.md             # Test cases and scenarios\n│   │   └── architecture-decisions.md     # ADRs for feature\n│   └── 002-another-feature/\n│       └── [similar structure]\n├── src/\n│   ├── [implementation files]\n│   └── [generated from specifications]\n├── tests/\n│   ├── [test files matching specifications]\n│   └── [generated from test scenarios]\n├── tools/\n│   ├── spec-generator.ps1                # Generate specifications\n│   ├── implementation-generator.ps1      # Generate code from specs\n│   ├── compliance-validator.ps1          # Validate spec compliance\n│   └── instruction-updater.ps1          # Update project instructions\n└── docs/\n    ├── [generated documentation]\n    └── [architectural decisions]\n```\n\n### Instruction Synchronization\n```powershell\n# Automated instruction compliance checking\nfunction Test-InstructionCompliance {\n    param(\n        [string]$ProjectRoot = \".\" \n    )\n    \n    $complianceResults = @()\n    \n    # Check constitution compliance\n    $constitutionCompliance = Test-ConstitutionCompliance $ProjectRoot\n    $complianceResults += $constitutionCompliance\n    \n    # Check project instruction compliance\n    $projectCompliance = Test-ProjectInstructionCompliance $ProjectRoot\n    $complianceResults += $projectCompliance\n    \n    # Check specification-implementation alignment\n    $specCompliance = Test-SpecificationCompliance $ProjectRoot\n    $complianceResults += $specCompliance\n    \n    # Generate compliance report\n    $report = New-ComplianceReport $complianceResults\n    \n    return $report\n}\n\n# Update instructions based on project evolution\nfunction Update-ProjectInstructions {\n    param(\n        [string]$ChangeReason,\n        [string]$ImpactAssessment\n    )\n    \n    # Validate change against constitution\n    $constitutionConflict = Test-ConstitutionConflict $ChangeReason\n    \n    if ($constitutionConflict) {\n        Write-Error \"Proposed change conflicts with project constitution\"\n        return\n    }\n    \n    # Update project instructions\n    $instructionUpdate = New-InstructionUpdate -Reason $ChangeReason -Impact $ImpactAssessment\n    \n    # Version the change\n    $version = New-InstructionVersion $instructionUpdate\n    \n    # Notify stakeholders\n    Send-InstructionChangeNotification $version\n}\n```\n\n## Quality Assurance and Governance\n\n### Instruction Quality Gates\n```markdown\n## Instruction Quality Checklist\n\n### Content Quality\n- [ ] Instructions are specific and actionable\n- [ ] Examples are provided for complex concepts\n- [ ] Instructions can be validated programmatically\n- [ ] Instructions align with project constitution\n\n### Technical Accuracy\n- [ ] Code examples compile and execute correctly\n- [ ] Dependencies and prerequisites are specified\n- [ ] Version compatibility is documented\n- [ ] Platform-specific considerations are noted\n\n### Maintainability\n- [ ] Instructions are versioned with change logs\n- [ ] Migration paths are documented for changes\n- [ ] Ownership and review responsibilities are clear\n- [ ] Automated validation is in place\n```\n\n### Continuous Improvement Process\n```markdown\n## Instruction Evolution Process\n\n1. **Change Identification**: Identify gaps or improvements needed\n2. **Impact Assessment**: Analyze impact on existing implementations\n3. **Stakeholder Review**: Get approval from affected teams\n4. **Implementation**: Update instructions with proper versioning\n5. **Validation**: Ensure changes don't break existing compliance\n6. **Communication**: Notify teams of changes and migration needs\n7. **Monitoring**: Track adoption and effectiveness of changes\n```\n\n## Integration with Development Tools\n\n### VS Code Integration\n```json\n// .vscode/settings.json\n{\n  \"mcp.toolsets\": {\n    \"specDrivenDevelopment\": {\n      \"tools\": [\n        \"semantic_search\",\n        \"list_code_usages\", \n        \"powershell-syntax-check\",\n        \"run-powershell\"\n      ],\n      \"description\": \"Tools for spec-driven development workflow\",\n      \"icon\": \"tools\"\n    },\n    \"projectGovernance\": {\n      \"tools\": [\n        \"get_errors\",\n        \"file_search\",\n        \"grep_search\",\n        \"kusto\"\n      ],\n      \"description\": \"Project governance and compliance validation\",\n      \"icon\": \"shield\"\n    }\n  }\n}\n```\n\n### Automated Workflows\n```yaml\n# .github/workflows/instruction-compliance.yml\nname: Instruction Compliance Validation\n\non:\n  pull_request:\n    paths:\n      - 'src/**'\n      - 'specs/**'\n      - '.instructions/**'\n\njobs:\n  validate-compliance:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Validate Specification Compliance\n        run: |\n          ./tools/compliance-validator.ps1 -ProjectRoot .\n          \n      - name: Check Instruction Synchronization\n        run: |\n          ./tools/instruction-sync-check.ps1\n          \n      - name: Validate Implementation Against Specs\n        run: |\n          ./tools/spec-implementation-validator.ps1\n```\n\n## Success Metrics and Monitoring\n\n### Development Velocity Metrics\n- **Specification to Implementation Time**: Time from complete spec to working feature\n- **Instruction Compliance Rate**: Percentage of code following project instructions\n- **Specification Change Rate**: Frequency of specification updates vs implementation changes\n- **Test Coverage from Specifications**: Percentage of specification scenarios covered by tests\n\n### Quality Metrics\n- **Specification Accuracy**: How often specifications accurately predict implementation\n- **Instruction Effectiveness**: Reduction in common development errors\n- **Documentation Synchronization**: How well instructions track actual implementation\n- **Developer Onboarding Time**: Time for new developers to become productive\n\n### Continuous Improvement\n- **Instruction Usage Analytics**: Which instructions are most/least used\n- **Specification Pattern Analysis**: Which specification patterns work best\n- **Implementation Compliance Trends**: Are projects becoming more compliant over time\n- **Developer Feedback**: Qualitative feedback on instruction usefulness\n\nThis instruction architecture ensures that project guidance is not just documentation, but executable specifications that actively drive development quality, consistency, and maintainability while integrating seamlessly with modern development tools and workflows.",
  "priority": 88,
  "audience": "all",
  "requirement": "recommended",
  "categories": [
    "development-workflow",
    "governance",
    "instruction-management",
    "project-architecture",
    "spec-driven-development"
  ],
  "sourceHash": "1a62ca3c3b9cdb4fb69699200c1ad95601112f0bdc1ab3b9b0f7c4c9175bebb1",
  "schemaVersion": "3",
  "createdAt": "2025-09-05T15:27:08.774Z",
  "updatedAt": "2025-09-05T15:27:08.774Z",
  "riskScore": 32,
  "version": "1.0.0",
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P4",
  "classification": "internal",
  "lastReviewedAt": "2025-09-05T15:27:08.774Z",
  "nextReviewDue": "2026-01-03T15:27:08.774Z",
  "reviewIntervalDays": 120,
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-05T15:27:08.774Z",
      "summary": "initial import"
    }
  ],
  "semanticSummary": "# Project Instruction Architecture using Spec-Driven Development Patterns",
  "primaryCategory": "development-workflow"
}