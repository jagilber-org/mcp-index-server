{
  "id": "streaming-response-resumability-patterns",
  "title": "Streaming Response Patterns & Resumability",
  "body": "# Streaming Response Patterns & Resumability\n\n## Overview\nPatterns for handling streaming responses, resumable operations, and maintaining state across interruptions in long-running AI agent tasks.\n\n## Streaming Response Architecture\n\n### 1. Progressive Disclosure Pattern\n```typescript\n// TypeScript implementation example\ninterface StreamingResponse<T> {\n  id: string;\n  status: 'initializing' | 'streaming' | 'paused' | 'completed' | 'error';\n  progress: {\n    current: number;\n    total?: number;\n    percentage?: number;\n    phase: string;\n  };\n  data: T[];\n  metadata: {\n    startTime: Date;\n    lastUpdate: Date;\n    resumeToken?: string;\n  };\n}\n\n// PowerShell implementation example\nclass StreamingTaskManager {\n    [string]$TaskId\n    [string]$Status\n    [hashtable]$Progress\n    [array]$Results\n    [string]$ResumeToken\n    \n    [void]EmitUpdate([string]$phase, [object]$data) {\n        $this.Progress.phase = $phase\n        $this.Progress.lastUpdate = Get-Date\n        $this.Results += $data\n        \n        # Emit progress update\n        Write-Progress -Activity \"Processing $($this.TaskId)\" -Status $phase -PercentComplete $this.Progress.percentage\n        \n        # Generate resume token\n        $this.ResumeToken = $this.GenerateResumeToken()\n    }\n}\n```\n\n### 2. Chunked Processing Pattern\n```powershell\nfunction Invoke-StreamingProcess {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory)][array]$InputItems,\n        [int]$ChunkSize = 10,\n        [string]$ResumeToken = $null\n    )\n    \n    # Initialize or resume state\n    $state = if ($ResumeToken) {\n        Restore-ProcessingState -Token $ResumeToken\n    } else {\n        @{\n            ProcessedCount = 0\n            Results = @()\n            StartTime = Get-Date\n            TaskId = [guid]::NewGuid().ToString()\n        }\n    }\n    \n    try {\n        $totalItems = $InputItems.Count\n        $startIndex = $state.ProcessedCount\n        \n        for ($i = $startIndex; $i -lt $totalItems; $i += $ChunkSize) {\n            $chunk = $InputItems[$i..($i + $ChunkSize - 1)]\n            \n            # Process chunk\n            $chunkResults = Process-Chunk -Items $chunk -ChunkIndex ($i / $ChunkSize)\n            \n            # Update state\n            $state.Results += $chunkResults\n            $state.ProcessedCount = $i + $chunk.Count\n            $state.LastUpdate = Get-Date\n            \n            # Emit progress\n            $percentComplete = [math]::Round(($state.ProcessedCount / $totalItems) * 100, 2)\n            Write-Host \"Progress: $percentComplete% ($($state.ProcessedCount)/$totalItems)\" -ForegroundColor Green\n            \n            # Save state for resumability\n            $resumeToken = Save-ProcessingState -State $state\n            Write-Verbose \"Resume token: $resumeToken\"\n            \n            # Optional pause point\n            if ($CheckForPause) {\n                Write-Host \"Pausing at item $($state.ProcessedCount). Resume with: -ResumeToken '$resumeToken'\" -ForegroundColor Yellow\n                return @{\n                    Status = 'Paused'\n                    ResumeToken = $resumeToken\n                    PartialResults = $state.Results\n                    Progress = $percentComplete\n                }\n            }\n        }\n        \n        # Completion\n        return @{\n            Status = 'Completed'\n            Results = $state.Results\n            TotalProcessed = $state.ProcessedCount\n            Duration = (Get-Date) - $state.StartTime\n        }\n    }\n    catch {\n        # Save state on error for recovery\n        $resumeToken = Save-ProcessingState -State $state\n        throw \"Processing failed at item $($state.ProcessedCount). Resume with: -ResumeToken '$resumeToken'. Error: $($_.Exception.Message)\"\n    }\n}\n```\n\n### 3. State Persistence Patterns\n```powershell\nfunction Save-ProcessingState {\n    [CmdletBinding()]\n    param([hashtable]$State)\n    \n    $stateFile = \"$env:TEMP\\streaming_state_$($State.TaskId).json\"\n    $State | ConvertTo-Json -Depth 10 | Set-Content -Path $stateFile\n    \n    # Return base64 encoded token for easy transfer\n    $token = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($stateFile))\n    return $token\n}\n\nfunction Restore-ProcessingState {\n    [CmdletBinding()]\n    param([string]$Token)\n    \n    try {\n        $stateFile = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($Token))\n        \n        if (Test-Path $stateFile) {\n            $state = Get-Content $stateFile | ConvertFrom-Json -AsHashtable\n            Write-Host \"Resumed from $(Get-Date $state.LastUpdate)\" -ForegroundColor Cyan\n            return $state\n        } else {\n            throw \"State file not found: $stateFile\"\n        }\n    }\n    catch {\n        throw \"Failed to restore state from token: $($_.Exception.Message)\"\n    }\n}\n```\n\n## Real-Time Progress Communication\n\n### 4. Live Status Updates\n```powershell\nfunction Show-LiveProgress {\n    [CmdletBinding()]\n    param(\n        [string]$TaskId,\n        [int]$RefreshIntervalMs = 1000\n    )\n    \n    do {\n        $status = Get-TaskStatus -TaskId $TaskId\n        \n        # Clear and redraw progress\n        Clear-Host\n        Write-Host \"Task: $TaskId\" -ForegroundColor Cyan\n        Write-Host \"Status: $($status.Status)\" -ForegroundColor Yellow\n        Write-Host \"Progress: $($status.Progress.percentage)%\" -ForegroundColor Green\n        Write-Host \"Phase: $($status.Progress.phase)\" -ForegroundColor White\n        Write-Host \"Elapsed: $($status.Duration)\" -ForegroundColor Gray\n        \n        if ($status.Status -in @('completed', 'error')) {\n            break\n        }\n        \n        Start-Sleep -Milliseconds $RefreshIntervalMs\n    } while ($true)\n}\n```\n\n### 5. Event-Driven Updates\n```powershell\n# Event registration for progress updates\nRegister-ObjectEvent -InputObject $streamingTask -EventName 'ProgressUpdate' -Action {\n    $event = $Event.SourceEventArgs\n    \n    Write-Host \"[$($event.Timestamp)] $($event.Phase): $($event.Message)\" -ForegroundColor Green\n    \n    # Optional: Send to external monitoring\n    if ($SendToMonitoring) {\n        Send-MonitoringEvent -TaskId $event.TaskId -Progress $event.Progress -Status $event.Status\n    }\n}\n```\n\n## Error Recovery and Resilience\n\n### 6. Automatic Recovery Pattern\n```powershell\nfunction Invoke-ResilientStreaming {\n    [CmdletBinding()]\n    param(\n        [scriptblock]$ProcessingBlock,\n        [int]$MaxRetries = 3,\n        [int]$RetryDelaySeconds = 5,\n        [string]$ResumeToken = $null\n    )\n    \n    $retryCount = 0\n    \n    do {\n        try {\n            $result = Invoke-StreamingProcess @PSBoundParameters\n            \n            if ($result.Status -eq 'Completed') {\n                return $result\n            } elseif ($result.Status -eq 'Paused') {\n                Write-Host \"Task paused. Resume token: $($result.ResumeToken)\" -ForegroundColor Yellow\n                return $result\n            }\n        }\n        catch {\n            $retryCount++\n            \n            if ($retryCount -ge $MaxRetries) {\n                Write-Error \"Failed after $MaxRetries attempts: $($_.Exception.Message)\"\n                throw\n            }\n            \n            Write-Warning \"Attempt $retryCount failed: $($_.Exception.Message). Retrying in $RetryDelaySeconds seconds...\"\n            Start-Sleep -Seconds $RetryDelaySeconds\n            \n            # Extract resume token from error message if available\n            if ($_.Exception.Message -match \"Resume with: -ResumeToken '([^']+)'\") {\n                $ResumeToken = $Matches[1]\n                Write-Host \"Extracted resume token: $ResumeToken\" -ForegroundColor Cyan\n            }\n        }\n    } while ($retryCount -lt $MaxRetries)\n}\n```\n\n### 7. Checkpoint Strategy\n```powershell\nfunction Set-ProcessingCheckpoint {\n    [CmdletBinding()]\n    param(\n        [string]$TaskId,\n        [int]$IntervalItems = 50,\n        [string]$CheckpointDir = \"$env:TEMP\\checkpoints\"\n    )\n    \n    if (-not (Test-Path $CheckpointDir)) {\n        New-Item -Path $CheckpointDir -ItemType Directory -Force\n    }\n    \n    # Create checkpoint every N items\n    if ($script:ProcessedCount % $IntervalItems -eq 0) {\n        $checkpointFile = \"$CheckpointDir\\checkpoint_$TaskId_$($script:ProcessedCount).json\"\n        \n        $checkpoint = @{\n            TaskId = $TaskId\n            ProcessedCount = $script:ProcessedCount\n            Timestamp = Get-Date\n            PartialResults = $script:Results\n            NextResumePoint = $script:CurrentIndex + 1\n        }\n        \n        $checkpoint | ConvertTo-Json -Depth 10 | Set-Content -Path $checkpointFile\n        \n        # Cleanup old checkpoints (keep last 5)\n        Get-ChildItem \"$CheckpointDir\\checkpoint_$TaskId_*.json\" | \n            Sort-Object CreationTime -Descending | \n            Select-Object -Skip 5 | \n            Remove-Item -Force\n        \n        Write-Verbose \"Checkpoint saved: $checkpointFile\"\n    }\n}\n```\n\n## User Experience Patterns\n\n### 8. Interactive Streaming\n```powershell\nfunction Start-InteractiveStream {\n    [CmdletBinding()]\n    param([array]$Items)\n    \n    Write-Host \"Starting interactive streaming process. Commands:\"\n    Write-Host \"  'p' - Pause\"\n    Write-Host \"  'r' - Resume\"\n    Write-Host \"  's' - Status\"\n    Write-Host \"  'q' - Quit (saves state)\"\n    Write-Host \"\"\n    \n    $state = @{\n        Status = 'Running'\n        ProcessedCount = 0\n        Results = @()\n    }\n    \n    # Background processing\n    $job = Start-Job -ScriptBlock {\n        param($Items, $State)\n        \n        foreach ($item in $Items) {\n            # Check for pause signal\n            while ($using:state.Status -eq 'Paused') {\n                Start-Sleep -Milliseconds 100\n            }\n            \n            if ($using:state.Status -eq 'Stopped') {\n                break\n            }\n            \n            # Process item\n            $result = Process-Item $item\n            $using:state.Results += $result\n            $using:state.ProcessedCount++\n        }\n        \n        $using:state.Status = 'Completed'\n    } -ArgumentList $Items, $state\n    \n    # Interactive control loop\n    do {\n        $key = [Console]::ReadKey($true)\n        \n        switch ($key.KeyChar) {\n            'p' { \n                $state.Status = 'Paused'\n                Write-Host \"Paused at item $($state.ProcessedCount)\" -ForegroundColor Yellow\n            }\n            'r' { \n                $state.Status = 'Running'\n                Write-Host \"Resumed processing\" -ForegroundColor Green\n            }\n            's' {\n                Write-Host \"Status: $($state.Status), Processed: $($state.ProcessedCount)/$($Items.Count)\" -ForegroundColor Cyan\n            }\n            'q' {\n                $state.Status = 'Stopped'\n                $resumeToken = Save-ProcessingState -State $state\n                Write-Host \"Stopped. Resume token: $resumeToken\" -ForegroundColor Red\n                break\n            }\n        }\n    } while ($job.State -eq 'Running' -and $state.Status -ne 'Stopped')\n    \n    # Cleanup\n    if ($job.State -eq 'Running') {\n        Stop-Job $job\n    }\n    Remove-Job $job\n    \n    return $state\n}\n```\n\n## Integration Examples\n\n### 9. MCP Tool Streaming\n```powershell\nfunction Invoke-MCPStreamingOperation {\n    [CmdletBinding()]\n    param(\n        [string]$MCPTool,\n        [hashtable]$Parameters,\n        [string]$ResumeToken = $null\n    )\n    \n    # Initialize streaming context\n    $streamingContext = Initialize-StreamingContext -ResumeToken $ResumeToken\n    \n    try {\n        # Setup progress tracking\n        $progressParams = @{\n            Activity = \"MCP $MCPTool Operation\"\n            Status = \"Initializing...\"\n            Id = $streamingContext.TaskId\n        }\n        \n        Write-Progress @progressParams -PercentComplete 0\n        \n        # Call MCP tool with streaming support\n        $result = Invoke-MCPTool -Tool $MCPTool -Parameters $Parameters -StreamingCallback {\n            param($progress, $data)\n            \n            # Update progress\n            Write-Progress @progressParams -Status $progress.Phase -PercentComplete $progress.Percentage\n            \n            # Stream intermediate results\n            if ($data) {\n                Write-Output $data\n            }\n            \n            # Save state for resumability\n            Save-StreamingCheckpoint -Context $streamingContext -Progress $progress -Data $data\n        }\n        \n        Write-Progress @progressParams -Completed\n        return $result\n    }\n    catch {\n        # Save recovery state\n        $resumeToken = Export-StreamingState -Context $streamingContext\n        throw \"MCP operation failed. Resume with: -ResumeToken '$resumeToken'. Error: $($_.Exception.Message)\"\n    }\n}\n```\n\n### 10. Azure Resource Streaming\n```powershell\nfunction Get-AzureResourcesStreaming {\n    [CmdletBinding()]\n    param(\n        [string]$SubscriptionId,\n        [string[]]$ResourceTypes,\n        [string]$ResumeToken = $null\n    )\n    \n    # Resume or start fresh\n    $state = if ($ResumeToken) {\n        Restore-ProcessingState -Token $ResumeToken\n    } else {\n        @{\n            ProcessedSubscriptions = @()\n            ProcessedResourceTypes = @()\n            Results = @()\n            StartTime = Get-Date\n        }\n    }\n    \n    foreach ($resourceType in $ResourceTypes) {\n        if ($resourceType -in $state.ProcessedResourceTypes) {\n            Write-Host \"Skipping already processed resource type: $resourceType\" -ForegroundColor Gray\n            continue\n        }\n        \n        Write-Host \"Processing resource type: $resourceType\" -ForegroundColor Cyan\n        \n        # Stream resources in batches\n        $resources = Get-AzResource -ResourceType $resourceType -SubscriptionId $SubscriptionId\n        \n        foreach ($resource in $resources) {\n            # Emit resource immediately\n            Write-Output $resource\n            \n            # Add to state\n            $state.Results += $resource\n            \n            # Periodic state save\n            if ($state.Results.Count % 100 -eq 0) {\n                $resumeToken = Save-ProcessingState -State $state\n                Write-Verbose \"State saved. Items processed: $($state.Results.Count)\"\n            }\n        }\n        \n        $state.ProcessedResourceTypes += $resourceType\n    }\n    \n    Write-Host \"Streaming complete. Total resources: $($state.Results.Count)\" -ForegroundColor Green\n}\n```\n\n## Best Practices\n\n1. **State Management**: Always maintain serializable state that can be resumed\n2. **Progress Communication**: Provide meaningful progress updates with time estimates\n3. **Error Resilience**: Implement retry logic with exponential backoff\n4. **Resource Cleanup**: Ensure proper cleanup of temporary files and resources\n5. **User Control**: Provide pause/resume/cancel capabilities for long operations\n6. **Checkpoint Strategy**: Save state at regular intervals, not just on completion\n7. **Recovery Validation**: Test resume functionality with various failure scenarios\n\n## Performance Considerations\n\n- **Batch Size**: Optimize chunk size based on memory constraints and processing time\n- **State Persistence**: Balance checkpoint frequency with I/O overhead\n- **Memory Management**: Stream results rather than accumulating in memory\n- **Network Resilience**: Implement appropriate timeouts and retry policies\n- **Concurrency**: Use parallel processing where appropriate with proper coordination",
  "rationale": "Enables robust handling of long-running operations with proper user experience and error recovery",
  "priority": 80,
  "audience": "all",
  "requirement": "recommended",
  "categories": [
    "patterns",
    "resumability",
    "state-management",
    "streaming",
    "user-experience"
  ],
  "primaryCategory": "patterns",
  "sourceHash": "856ccebabd6d2d1b300aa2027a416ae253888b0e3cf5f8180716749f78fd8b1e",
  "schemaVersion": "3",
  "createdAt": "2025-09-12T12:11:48.134Z",
  "updatedAt": "2025-09-12T12:11:48.134Z",
  "riskScore": 40,
  "version": "1.0.0",
  "changeLog": [
    {
      "version": "1.0.0",
      "changedAt": "2025-09-12T12:11:48.134Z",
      "summary": "initial import"
    }
  ],
  "status": "approved",
  "owner": "unowned",
  "priorityTier": "P4",
  "classification": "internal",
  "lastReviewedAt": "2025-09-12T12:11:48.134Z",
  "nextReviewDue": "2026-01-10T12:11:48.134Z",
  "reviewIntervalDays": 120,
  "semanticSummary": "# Streaming Response Patterns & Resumability"
}