#!/usr/bin/env node
/**
 * Flake Gate
 * Purpose: Convert observational flake telemetry (generated by flake-sentinel + flake-trend)
 * into an enforcing quality gate. Designed to run in CI after flake-trend.mjs.
 *
 * Inputs (environment variables):
 *  FLAKE_GATE_ENABLED=1            --> Enable enforcement (otherwise script exits 0 immediately)
 *  FLAKE_GATE_MAX_FILES=number     --> Maximum distinct flaky test files allowed in window (default 0)
 *  FLAKE_GATE_MAX_OCCURRENCES=number -> Maximum total flaky occurrences allowed in window (default 0)
 *  FLAKE_GATE_ALLOW_NEW=1          --> If set, allow new flake files not seen before but still enforce occurrence cap
 *  FLAKE_GATE_BASELINE=json        --> Optional JSON list of known flaky test file baselines (e.g. from repo file)
 *  FLAKE_GATE_BASELINE_FILE=path   --> Path to JSON file containing array of allowed flaky test files
 *  FLAKE_HISTORY_FILE=path         --> Override path for flake-history.jsonl (default test-results/flake-history.jsonl)
 *  FLAKE_TREND_SUMMARY=path        --> Override path for flake-trend-summary.json (default test-results/flake-trend-summary.json)
 *  FLAKE_CURRENT_FILE=path         --> Override path for current run flaky-tests.json (default test-results/flaky-tests.json)
 *
 * Exit Codes:
 *  0 = Pass or disabled
 *  20 = Violated distinct file threshold
 *  21 = Violated occurrence threshold
 *  22 = Unauthorized new flaky file while new not allowed
 *  23 = Missing telemetry (treated as infrastructure issue)
 */
import fs from 'fs';
import path from 'path';

function readJSON(p){
  if(!p || !fs.existsSync(p)) return undefined;
  try { return JSON.parse(fs.readFileSync(p,'utf8')); } catch { return undefined; }
}

if(process.env.FLAKE_GATE_ENABLED !== '1'){
  console.log('[flake-gate] disabled (FLAKE_GATE_ENABLED!=1)');
  process.exit(0);
}

const summaryPath = process.env.FLAKE_TREND_SUMMARY || path.join('test-results','flake-trend-summary.json');
const currentPath = process.env.FLAKE_CURRENT_FILE || path.join('test-results','flaky-tests.json');

const summary = readJSON(summaryPath);
const current = readJSON(currentPath);

if(!summary || !current){
  console.error('[flake-gate] Missing telemetry summary or current run data');
  process.exit(23);
}

const maxFiles = Number(process.env.FLAKE_GATE_MAX_FILES ?? '0');
const maxOcc = Number(process.env.FLAKE_GATE_MAX_OCCURRENCES ?? '0');
const allowNew = process.env.FLAKE_GATE_ALLOW_NEW === '1';

let baseline = [];
if(process.env.FLAKE_GATE_BASELINE){
  try { const parsed = JSON.parse(process.env.FLAKE_GATE_BASELINE); if(Array.isArray(parsed)) baseline = parsed; } catch {/* ignore */}
}
if(process.env.FLAKE_GATE_BASELINE_FILE && fs.existsSync(process.env.FLAKE_GATE_BASELINE_FILE)){
  try { const parsed = JSON.parse(fs.readFileSync(process.env.FLAKE_GATE_BASELINE_FILE,'utf8')); if(Array.isArray(parsed)) baseline = parsed; } catch {/* ignore */}
}
// Auto-discover flake-baseline.json if still empty and file exists (structure: { files:[{file:string}] })
if(baseline.length === 0 && fs.existsSync('flake-baseline.json')){
  try {
    const auto = JSON.parse(fs.readFileSync('flake-baseline.json','utf8'));
    if(auto && Array.isArray(auto.files)){
      baseline = auto.files.map(f=> typeof f === 'string' ? f : f.file).filter(Boolean);
      console.log('[flake-gate] Loaded baseline from flake-baseline.json:', baseline);
    }
  } catch {/* ignore */}
}

const distinctFlaky = summary.distinctFlakyFiles ?? 0;
const totalOccurrences = summary.totalFlakyOccurrences ?? 0;
const currentFiles = Array.isArray(current.files) ? current.files.map(f=>f.file) : [];

// Check new files vs baseline
if(!allowNew && baseline.length){
  const newFiles = currentFiles.filter(f=>!baseline.includes(f));
  if(newFiles.length){
    console.error('[flake-gate] NEW flaky test files detected and not allowed:', newFiles);
    process.exit(22);
  }
}

if(distinctFlaky > maxFiles){
  console.error(`[flake-gate] Distinct flaky test files ${distinctFlaky} exceed threshold ${maxFiles}`);
  process.exit(20);
}
if(totalOccurrences > maxOcc){
  console.error(`[flake-gate] Total flaky occurrences ${totalOccurrences} exceed threshold ${maxOcc}`);
  process.exit(21);
}

console.log('[flake-gate] PASS', { distinctFlaky, totalOccurrences, maxFiles, maxOcc });
process.exit(0);
