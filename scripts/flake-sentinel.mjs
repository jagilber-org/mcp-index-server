#!/usr/bin/env node
/**
 * Flake Sentinel
 * Re-runs failing test files up to N times to classify flaky vs hard failures.
 *
 * Input: test-results/results.json (generated by jsonResultsReporter)
 * Output:
 *  - test-results/flaky-tests.json (array of flaky file objects)
 *  - nonzero exit if new hard failures OR new flaky tests (unless overridden by ALLOW_FLAKY)
 */
import fs from 'fs';
import { spawnSync } from 'child_process';

const MAX_RERUNS = parseInt(process.env.FLAKE_RERUNS || '2', 10); // additional attempts (so total attempts = 1 + MAX_RERUNS)
const ALLOW_FLAKY = process.env.ALLOW_FLAKY === '1';
const RESULTS_PATH = 'test-results/results.json';

function log(msg){ process.stdout.write(`[flake-sentinel] ${msg}\n`); }

if(!fs.existsSync(RESULTS_PATH)){
  log(`No results file at ${RESULTS_PATH}; nothing to do.`);
  process.exit(0);
}

const results = JSON.parse(fs.readFileSync(RESULTS_PATH,'utf-8'));

// We only have per-test failure details; derive failing files by unique file property
const failureEntries = results.testFailures || [];
const failingFiles = [...new Set(failureEntries.map(f=> f.file))];
if(failingFiles.length === 0){
  log('No failing files detected. Exiting clean.');
  process.exit(0);
}

log(`Initial failing files: ${failingFiles.join(', ')}`);

const flaky = [];
const hard = [];

for(const file of failingFiles){
  let passed = false;
  for(let attempt=1; attempt<=MAX_RERUNS; attempt++){
    log(`Re-running file attempt ${attempt}/${MAX_RERUNS} -> ${file}`);
    const run = spawnSync('npx', ['vitest','run', file, '--reporter=default','--silent'], { stdio: 'pipe', encoding: 'utf-8' });
    const stdout = run.stdout || '';
    const stderr = run.stderr || '';
    const combined = `${stdout}\n${stderr}`;
    const success = run.status === 0;
    fs.mkdirSync('test-results/reruns', { recursive: true });
    fs.writeFileSync(`test-results/reruns/${file.replace(/[^a-zA-Z0-9_.-]/g,'_')}.attempt${attempt}.log`, combined);
    if(success){
      passed = true;
      break;
    }
  }
  if(passed){
    flaky.push({ file, classification: 'flaky-pass-on-rerun' });
  } else {
    hard.push({ file, classification: 'hard-fail' });
  }
}

// Persist outputs
fs.writeFileSync('test-results/flaky-tests.json', JSON.stringify({ flaky, hard, reruns: MAX_RERUNS }, null, 2));

if(hard.length){
  log(`Hard failures remain: ${hard.map(h=>h.file).join(', ')}`);
}
if(flaky.length){
  log(`Flaky files detected: ${flaky.map(f=>f.file).join(', ')}`);
}

if(hard.length > 0 || (flaky.length > 0 && !ALLOW_FLAKY)){
  log('Exiting with failure due to hard failures or newly detected flaky tests.');
  process.exit(2);
}

log('All failures resolved via rerun and flakiness allowed. Exit 0.');
process.exit(0);
