<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Index Server Admin - MCP Index Server</title>
    <style>
    /* --- High-contrast dark theme overrides for Mermaid (ELK + default) --- */
    #graph-mermaid-svg .mermaid, #graph-mermaid-svg .mermaid svg { background:#0f1624 !important; }
    /* Grey background for nodes (request: replace white boxes) */
    #graph-mermaid-svg .mermaid .node rect,
    #graph-mermaid-svg .mermaid .node polygon,
    #graph-mermaid-svg .mermaid .node path,
    #graph-mermaid-svg .mermaid rect.label-container { fill:#3a4554 !important; stroke:#6b8cff !important; }
    /* Additional ELK-only hard override: some category nodes render with inline white fills; target via elk-layout-active */
    .elk-layout-active #graph-mermaid-svg .mermaid .node rect[fill],
    .elk-layout-active #graph-mermaid-svg .mermaid .node rect[style*='fill:#fff'],
    .elk-layout-active #graph-mermaid-svg .mermaid .node rect[style*='fill: #fff'],
    .elk-layout-active #graph-mermaid-svg .mermaid .node rect { fill:#3a4554 !important; }
    #graph-mermaid-svg .mermaid .cluster rect { fill:#273341 !important; stroke:#6b8cff !important; }
    #graph-mermaid-svg .mermaid .edgePaths path { stroke:#5479ff !important; }
    #graph-mermaid-svg .mermaid .edgeLabel rect { fill:#2f3947 !important; stroke:#6b8cff !important; }
    #graph-mermaid-svg .mermaid .label, #graph-mermaid-svg .mermaid text, #graph-mermaid-svg .mermaid .node text { fill:#e3ebf5 !important; font-weight:500; }
    #graph-mermaid-svg .mermaid .node:hover rect { stroke:#8fb2ff !important; }
    /* Make small edge label text slightly bolder for readability */
    #graph-mermaid-svg .mermaid .edgeLabel text { font-weight:600 !important; }
    /* Toolbar consistency */
    .graph-toolbar .form-input, .graph-toolbar select { background:#1f2a3a; color:#d0d7e2; border:1px solid #2d3b4f; border-radius:4px; padding:4px 6px; font-size:12px; }
    .graph-toolbar label { display:flex; align-items:center; gap:4px; background:#1f2a3a; color:#9fb5cc; padding:4px 6px; border:1px solid #2d3b4f; border-radius:4px; font-size:12px; }
    .graph-toolbar button.action-btn { padding:8px 14px; font-size:12px; }
    /* --------------------------------------------------------------------- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .admin-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .admin-header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .admin-header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .admin-nav {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .nav-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .nav-btn.active {
            background: linear-gradient(45deg, #764ba2, #667eea);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .admin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .admin-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .admin-card:hover {
            transform: translateY(-5px);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .card-icon {
            font-size: 1.5rem;
            margin-right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 500;
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }

        .status-healthy { background: #2ecc71; }
        .status-warning { background: #f39c12; }
        .status-critical { background: #e74c3c; }
    /* Treat failed same visual as critical but distinct semantic label */
    .status-failed { background: #e74c3c; }

        .action-btn {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .action-btn.danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .action-btn.warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .maintenance-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 600;
        }

        .maintenance-enabled {
            background: #ffe6e6;
            color: #c0392b;
            border: 2px solid #e74c3c;
        }

        .maintenance-disabled {
            background: #e6ffe6;
            color: #27ae60;
            border: 2px solid #2ecc71;
        }

        .config-form {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .form-input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .sessions-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .session-item {
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #f8f9fa;
        }

        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-id {
            font-family: monospace;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background: #ffe6e6;
            color: #c0392b;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #e74c3c;
        }

        .success {
            background: #e6ffe6;
            color: #27ae60;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #2ecc71;
        }

        @media (max-width: 768px) {
            .admin-nav {
                flex-direction: column;
                align-items: center;
            }
            
            .admin-grid {
                grid-template-columns: 1fr;
            }
            
            .nav-btn {
                width: 200px;
            }
        }
    .build-meta { margin-top:10px; font-size:0.85rem; color:#444; }
    .build-badge { display:inline-block; background:#222; color:#fff; padding:2px 6px; border-radius:10px; font-size:0.65rem; margin-left:6px; letter-spacing:0.5px; }
    
        /* Tool Metrics Styles */
        .tool-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .tool-metric-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: box-shadow 0.2s ease;
        }

        .tool-metric-card:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .tool-name {
            font-weight: 600;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }

        .tool-stats .stat-row {
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .tool-stats .stat-row:last-child {
            border-bottom: none;
        }

        .tool-stats .stat-label {
            font-size: 12px;
            color: #6c757d;
        }

        .tool-stats .stat-value {
            font-size: 12px;
            font-weight: 600;
        }

        .tool-stats .stat-value.small {
            font-size: 10px;
            color: #6c757d;
        }

        .tool-stats .stat-value.warning {
            color: #f39c12;
        }

        .tool-stats .stat-value.error {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <div class="admin-header">
            <h1>üõ°Ô∏è MCP Index Server Admin</h1>
            <div id="buildMeta" class="build-meta">Loading build metadata‚Ä¶</div>
            <div class="admin-nav">
                <button class="nav-btn active" onclick="showSection('overview')">üìä Overview</button>
                <button class="nav-btn" onclick="showSection('config')">‚öôÔ∏è Configuration</button>
                <button id="nav-sessions" class="nav-btn" onclick="showSection('sessions')">üë• Sessions</button>
                <button class="nav-btn" onclick="showSection('maintenance')">üîß Maintenance</button>
                <button class="nav-btn" onclick="showSection('monitoring')">üìà Monitoring</button>
                <button class="nav-btn" onclick="showSection('instructions')">üìö Instructions</button>
                <button class="nav-btn" onclick="showSection('graph')">üó∫Ô∏è Graph</button>
            </div>
        </div>

        <!-- Overview Section -->
        <div id="overview-section" class="admin-section">
            <div class="admin-grid">
                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üìä</div>
                        <div class="card-title">System Statistics</div>
                    </div>
                    <div id="system-stats" class="loading">Loading system statistics...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üíö</div>
                        <div class="card-title">System Health</div>
                    </div>
                    <div id="system-health" class="loading">Loading system health...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">‚ö°</div>
                        <div class="card-title">Performance</div>
                    </div>
                    <div id="performance-stats" class="loading">Loading performance data...</div>
                </div>

                <!-- Catalog Status merged into System Statistics card -->
            </div>
            
            <!-- Individual Tool Metrics -->
            <div class="admin-card" style="margin-top: 30px;">
                <div class="card-header">
                    <div class="card-icon">üîß</div>
                    <div class="card-title">Individual Tool Call Metrics</div>
                </div>
                <div id="tool-metrics" class="loading">Loading tool metrics...</div>
            </div>
        </div>
        <!-- Graph Section -->
        <div id="graph-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">üó∫Ô∏è</div>
                    <div class="card-title">Instruction Relationship Graph</div>
                </div>
                <div class="graph-toolbar" style="display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end; margin-bottom:12px;">
                    <label>Enrich <input id="graph-enrich" type="checkbox" checked></label>
                    <label>Categories <input id="graph-categories" type="checkbox" checked></label>
                    <label>Usage <input id="graph-usage" type="checkbox"></label>
                    <label>Edge Types
                        <input id="graph-edgeTypes" class="form-input" placeholder="(all or comma list)" style="width:150px;">
                    </label>
                    <label>Layout
                        <select id="graph-layout" class="form-input" style="width:110px;">
                            <option value="elk" selected>elk</option>
                            <option value="default">default</option>
                        </select>
                    </label>
                    <label>Theme
                        <select id="graph-theme" class="form-input" style="width:120px;" onchange="reloadGraphMermaid()">
                            <option value="dark" selected>dark</option>
                            <option value="default">default</option>
                            <option value="neutral">neutral</option>
                            <option value="forest">forest</option>
                            <option value="base">base</option>
                        </select>
                    </label>
                    <label>Debug <input id="graph-debug" type="checkbox"></label>
                    <button class="action-btn" onclick="reloadGraphMermaid()">üîÑ Refresh</button>
                    <button class="action-btn" onclick="copyMermaidSource()" style="background:linear-gradient(45deg,#3498db,#2980b9)">üìã Copy Source</button>
                    <button id="graph-edit-btn" class="action-btn" onclick="toggleGraphEdit()" style="background:linear-gradient(45deg,#e67e22,#d35400)">‚úèÔ∏è Edit</button>
                    <button id="graph-apply-btn" class="action-btn" onclick="applyGraphEdit()" style="display:none;background:linear-gradient(45deg,#27ae60,#1e8449)">üíæ Apply</button>
                    <button id="graph-cancel-btn" class="action-btn" onclick="cancelGraphEdit()" style="display:none;background:linear-gradient(45deg,#c0392b,#922b21)">‚Ü©Ô∏è Cancel</button>
                </div>
                <div id="graph-meta" style="font-size:12px; opacity:0.8; margin-bottom:2px; font-family:monospace;"></div>
                <div id="graph-meta2" style="font-size:11px; opacity:0.65; margin-bottom:6px; font-family:monospace;"></div>
                <div id="graph-mermaid-wrapper" style="background:#0f1624; color:#d0d7e2; border:1px solid #1f2a3a; border-radius:8px; padding:16px; overflow:auto; max-height:320px; position:relative;">
                    <div style="font-size:11px; opacity:0.65; margin-bottom:6px;">Mermaid Source (copy or edit; elk layout prepends frontmatter)</div>
                    <pre id="graph-mermaid" style="margin:0; white-space:pre; font-family:monospace; font-size:12px; line-height:1.25;">(loading graph...)</pre>
                </div>
                <div style="margin-top:8px; font-size:11px; opacity:0.65;">Mermaid source shown above. Rendered diagram below uses same code.</div>
            </div>
            <div class="admin-card" id="graph-render-card" style="margin-top:18px;">
                <div class="card-header">
                    <div class="card-icon">üß™</div>
                    <div class="card-title">Rendered Diagram</div>
                </div>
                <div id="graph-mermaid-rendered" style="background:#0f1624; color:#d0d7e2; border:1px solid #1f2a3a; border-radius:8px; padding:12px; overflow:auto; max-height:720px;">
                    <div id="graph-mermaid-svg" style="min-height:140px;">(diagram not loaded)</div>
                </div>
                <div style="margin-top:8px; font-size:11px; opacity:0.7;">Copy source (top) into <a href="https://mermaid.live" target="_blank" rel="noopener" style="color:#3498db;">Mermaid Live Editor</a> for advanced tweaks. Layout 'elk' leverages experimental ELK engine; fallback auto-applies legacy init directive if frontmatter unsupported.</div>
            </div>
        </div>

        <!-- Configuration Section -->
        <div id="config-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">‚öôÔ∏è</div>
                    <div class="card-title">Server Configuration</div>
                </div>
                <div id="config-form" class="loading">Loading configuration...</div>
            </div>
        </div>

        <!-- Sessions Section -->
        <div id="sessions-section" class="admin-section hidden">
            <div class="admin-grid" style="grid-template-columns:1fr;">
                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üë•</div>
                        <div class="card-title">Active Admin Sessions</div>
                    </div>
                    <div id="sessions-list" class="loading">Loading sessions...</div>
                    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                        <button class="action-btn" onclick="createTestSession()">Create Test Session</button>
                        <button class="action-btn" onclick="loadSessions()">üîÑ Refresh</button>
                    </div>
                </div>
                <div class="admin-card" style="margin-top:20px;">
                    <div class="card-header">
                        <div class="card-icon">üîå</div>
                        <div class="card-title">Active WebSocket Connections</div>
                    </div>
                    <div id="connections-list" class="loading">Loading connections...</div>
                </div>
                <div class="admin-card" style="margin-top:20px;">
                    <div class="card-header">
                        <div class="card-icon">üóÇÔ∏è</div>
                        <div class="card-title">Session History</div>
                    </div>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
                        <label style="font-size:12px;">Limit
                            <select id="session-history-limit" class="form-input" style="width:80px; padding:4px;" onchange="refreshSessionHistory()">
                                <option value="25">25</option>
                                <option value="50" selected>50</option>
                                <option value="100">100</option>
                                <option value="250">250</option>
                            </select>
                        </label>
                        <button class="action-btn" onclick="refreshSessionHistory()">üîÑ Refresh History</button>
                    </div>
                    <div id="session-history-list" class="loading">History not loaded...</div>
                </div>
            </div>
        </div>

        <!-- Maintenance Section -->
        <div id="maintenance-section" class="admin-section hidden">
            <div class="admin-grid">
                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üîß</div>
                        <div class="card-title">Maintenance Control</div>
                    </div>
                    <div id="maintenance-control" class="loading">Loading maintenance status...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üíæ</div>
                        <div class="card-title">System Operations</div>
                    </div>
                    <div class="action-buttons">
                        <button class="action-btn" onclick="performBackup()">üíæ Create Backup</button>
                        <button class="action-btn warning" onclick="clearCaches()">üóëÔ∏è Clear Caches</button>
                        <button class="action-btn danger" onclick="restartServer()">üîÑ Restart Server</button>
                    </div>
                    <div style="margin-top:14px;">
                        <div style="font-weight:600; font-size:13px; margin-bottom:6px; display:flex; align-items:center; gap:6px;">Restore Backup <button onclick="loadBackups()" class="action-btn" style="padding:4px 8px; font-size:11px;">Refresh</button></div>
                        <div id="backup-restore-area" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <select id="backup-select" class="form-input" style="min-width:340px; max-width:520px; width:100%; flex:1;">
                                <option value="">(no backups)</option>
                            </select>
                            <button class="action-btn" onclick="restoreSelectedBackup()">‚ôªÔ∏è Restore</button>
                            <span id="backup-restore-status" style="font-size:11px; opacity:0.75;"></span>
                        </div>
                        <div id="backup-list-meta" style="margin-top:6px; font-size:11px; opacity:0.6; min-height:14px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Monitoring Section -->
        <div id="monitoring-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">üìà</div>
                    <div class="card-title">Real-time Monitoring</div>
                </div>
                <div id="monitoring-data" class="loading">Loading monitoring data...</div>
            </div>
            <div class="admin-card" style="margin-top:20px;">
                <div class="card-header">
                    <div class="card-icon">üß™</div>
                    <div class="card-title">Synthetic Activity</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
                    <div>
                        <label class="form-label" style="font-size:12px;">Iterations</label>
                        <input id="synthetic-iterations" class="form-input" type="number" value="25" style="width:90px;" />
                    </div>
                    <div>
                        <label class="form-label" style="font-size:12px;">Concurrency</label>
                        <input id="synthetic-concurrency" class="form-input" type="number" value="3" style="width:90px;" />
                    </div>
                    <button id="synthetic-run-btn" class="action-btn" onclick="runSyntheticActivity()">Run Synthetic Activity</button>
                    <div id="synthetic-output" style="font-size:12px; opacity:0.85; min-height:20px; line-height:1.3; white-space:pre-wrap;"></div>
                </div>
                <div style="margin-top:8px; font-size:11px; opacity:0.7;">Executes random safe tools to exercise metrics & health. <span id="synthetic-last-meta" style="font-style:italic;"></span></div>
                                <div id="synthetic-traces-wrapper" style="margin-top:14px; display:none;">
                                    <div style="font-weight:600; font-size:13px; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                                        Per‚ÄëCall Trace
                                        <label style="font-size:11px; font-weight:400; display:flex; align-items:center; gap:4px;">
                                            <input id="synthetic-trace-toggle" type="checkbox" checked onchange="toggleSyntheticTraceVisibility()" /> show
                                        </label>
                                    </div>
                                    <div style="max-height:220px; overflow:auto; border:1px solid #eee; border-radius:4px;">
                                        <table style="width:100%; border-collapse:collapse; font-size:11px;">
                                            <thead style="position:sticky; top:0; background:#fafafa;">
                                                <tr>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">#</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Tool</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Success</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Duration</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Error</th>
                                                </tr>
                                            </thead>
                                            <tbody id="synthetic-traces-body"></tbody>
                                        </table>
                                    </div>
                                </div>
            </div>

            <!-- Log Viewer Section -->
            <div class="admin-card" style="margin-top:20px;">
                <div class="card-header">
                    <div class="card-icon">üìã</div>
                    <div class="card-title">Server Logs</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:15px;">
                    <div>
                        <label class="form-label" style="font-size:12px;">Lines</label>
                        <input id="log-lines" class="form-input" type="number" value="100" style="width:80px;" />
                    </div>
                    <button class="action-btn" onclick="loadLogs()">üîÑ Refresh</button>
                    <button id="log-tail-btn" class="action-btn" onclick="toggleLogTail()">‚ñ∂Ô∏è Start Tail</button>
                    <button class="action-btn" onclick="clearLogViewer()">üóëÔ∏è Clear</button>
                    <div id="log-status" style="font-size:12px; opacity:0.7; font-style:italic;"></div>
                </div>
                <!-- Log content container id expected by scripts (was log-viewer) -->
                <div id="log-content" style="
                    background: #f8f9fa; 
                    border: 1px solid #dee2e6; 
                    border-radius: 6px; 
                    padding: 12px; 
                    height: 400px; 
                    overflow-y: auto; 
                    font-family: 'Courier New', monospace; 
                    font-size: 12px; 
                    line-height: 1.4;
                    white-space: pre-wrap;
                    color: #333;
                ">
                    <div style="color: #666; font-style: italic;">Click "Refresh" to load server logs...</div>
                </div>
                <div style="margin-top:8px; font-size:11px; opacity:0.7;">
                    Real-time server log viewer. Set MCP_LOG_FILE to a path OR simply '1' (auto => logs/mcp-server.log).
                </div>
            </div>
        </div>

    <!-- Instruction Management Section -->
        <div id="instructions-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">üìö</div>
                    <div class="card-title">Instruction Catalog</div>
                </div>
                <div style="margin-bottom:15px; display:flex; gap:10px; flex-wrap:wrap;">
                    <button class="action-btn" onclick="loadInstructions()">üîÑ Refresh</button>
                    <button class="action-btn" onclick="showCreateInstruction()">‚ûï Create</button>
                    <input id="instruction-filter" placeholder="Filter by name..." class="form-input" style="flex:1; min-width:180px;" oninput="filterInstructions()" />
                    <select id="instruction-category-filter" class="form-input" style="width:130px;" onchange="filterInstructions()">
                        <option value="">All Categories</option>
                        <!-- Categories will be populated dynamically -->
                    </select>
                    <select id="instruction-size-filter" class="form-input" style="width:120px;" onchange="filterInstructions()">
                        <option value="">All Sizes</option>
                        <option value="small">small</option>
                        <option value="medium">medium</option>
                        <option value="large">large</option>
                    </select>
                    <select id="instruction-sort" class="form-input" style="width:150px;" onchange="filterInstructions()">
                        <option value="name-asc">Name A‚ÜíZ</option>
                        <option value="name-desc">Name Z‚ÜíA</option>
                        <option value="size-asc">Size ‚Üë</option>
                        <option value="size-desc">Size ‚Üì</option>
                        <option value="mtime-desc">Modified ‚Üì</option>
                        <option value="mtime-asc">Modified ‚Üë</option>
                        <option value="category">Category</option>
                    </select>
                </div>
                <div id="instructions-list" class="loading">Loading instructions...</div>
                <div id="instruction-pagination" style="margin-top:12px;"></div>
                <!-- Editor will be dynamically repositioned above the list when activated -->
                <div id="instruction-editor" class="hidden" style="margin-top:20px;">
                    <h3 id="instruction-editor-title" style="margin-bottom:10px;">New Instruction</h3>
                    <div class="form-group">
                        <label class="form-label">File Name (no extension)</label>
                        <input id="instruction-filename" class="form-input" placeholder="example-instruction" />
                    </div>
                    <div class="form-group" style="margin-top:10px;">
                        <label class="form-label">JSON Content</label>
                        <textarea id="instruction-content" class="form-input" style="min-height:260px; font-family:monospace; white-space:pre-wrap; word-wrap:break-word; overflow:auto;" oninput="updateInstructionEditorDiagnostics()" placeholder="{\n  \"id\": \"example\",\n  \"title\": \"Example Instruction\"\n}"></textarea>
                        <div id="instruction-diagnostics" style="margin-top:8px; font-size:12px; line-height:1.4; background:#f4f6fb; padding:8px 10px; border:1px solid #dbe2ec; border-radius:6px;">
                            <em>Editor idle.</em>
                        </div>
                        <div id="instruction-diff-container" class="hidden" style="margin-top:10px; max-height:240px; overflow:auto; border:1px solid #eee; border-radius:6px; background:#222; color:#ddd; font-family:monospace; font-size:12px; padding:8px;">
                            <div style="margin-bottom:6px; font-weight:600;">Diff (original vs current)</div>
                            <pre id="instruction-diff" style="white-space:pre; margin:0;"></pre>
                        </div>
                    </div>
                    <div style="margin-top:10px;">
                        <button class="action-btn" onclick="saveInstruction()">üíæ Save</button>
                        <button class="action-btn" style="background:linear-gradient(45deg,#3498db,#2980b9)" onclick="formatInstructionJson()">üßπ Format</button>
                        <button class="action-btn" style="background:linear-gradient(45deg,#8e44ad,#6c3483)" onclick="toggleInstructionDiff()">üîç Diff</button>
                        <button class="action-btn" style="background:linear-gradient(45deg,#16a085,#13856c)" onclick="applyInstructionTemplate()">üìê Template</button>
                        <button class="action-btn warning" onclick="cancelEditInstruction()">‚úñ Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Admin Panel JavaScript
        let currentSection = 'overview';
        let refreshInterval;
    // Track if /api/admin/stats responded successfully on most recent loadOverviewData()
    // Used to downgrade health display (memory/errors) when stats are missing.
    let statsAvailable = false;
    // WebSocket for live events (metrics + synthetic trace streaming)
    let dashboardSocket = null;
    let lastSyntheticRunId = null;
    function initDashboardSocket(){
        try {
            if (dashboardSocket && dashboardSocket.readyState === WebSocket.OPEN) return;
            const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
            dashboardSocket = new WebSocket(`${proto}://${location.host}/ws`);
            dashboardSocket.onopen = ()=>{/* noop */};
            dashboardSocket.onmessage = ev => {
                try {
                    const msg = JSON.parse(ev.data);
                    if (msg.type === 'synthetic_trace' && msg.data) {
                        handleSyntheticTrace(msg.data);
                    }
                } catch {/* ignore */}
            };
            dashboardSocket.onclose = ()=>{ setTimeout(initDashboardSocket, 4000); };
        } catch(e){ console.warn('ws init failed', e); }
    }
    function handleSyntheticTrace(data){
        if (!data || !data.runId) return;
        // If new run starts while traces visible, auto-clear
        if (lastSyntheticRunId && data.runId !== lastSyntheticRunId) {
            const body = document.getElementById('synthetic-traces-body');
            if (body) body.innerHTML='';
        }
        lastSyntheticRunId = data.runId;
        const body = document.getElementById('synthetic-traces-body');
        if (!body) return;
        const clr = data.success ? '#0a0' : '#a00';
        const err = data.error ? String(data.error).slice(0,80) : '';
        const skipped = data.skipped ? ' (skipped)' : '';
        const tr = document.createElement('tr');
        tr.innerHTML = `<td style="padding:2px 4px; border-bottom:1px solid #eee;">${data.seq}</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee; font-family:monospace;">${data.method}${skipped}</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${clr};">${data.success?'‚úì':'‚úó'}</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee;">${data.durationMs}ms</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${data.error?'#b55':'#666'};">${err}</td>`;
        body.appendChild(tr);
        const wrap = document.getElementById('synthetic-traces-wrapper');
        if (wrap && wrap.style.display === 'none') wrap.style.display='block';
    }

        // Initialize admin panel
        document.addEventListener('DOMContentLoaded', function() {
            showSection('overview');
            startAutoRefresh();
            // Attempt to auto-create a dashboard admin session if none exists for this browser tab
            try { maybeEnsureAdminSession(); } catch(e) { console.warn('auto session create failed', e); }
            initDashboardSocket();
        });

        function showSection(section) {
            // Hide all sections
            document.querySelectorAll('.admin-section').forEach(s => s.classList.add('hidden'));

            // Show selected section if present
            const activeSection = document.getElementById(section + '-section');
            if (activeSection) activeSection.classList.remove('hidden');

            // Update nav buttons without relying on implicit event
            document.querySelectorAll('.nav-btn').forEach(btn => {
                const isTarget = btn.getAttribute('onclick')?.includes(`showSection('${section}')`);
                if (isTarget) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            currentSection = section;
            loadSectionData(section);
        }

        function loadSectionData(section) {
            switch(section) {
                case 'overview':
                    loadOverviewData();
                    break;
                case 'graph':
                    reloadGraphMermaid();
                    break;
                case 'config':
                    loadConfiguration();
                    break;
                case 'sessions':
                    loadSessions();
                    break;
                case 'maintenance':
                    loadMaintenanceStatus();
                    loadBackups();
                    break;
                case 'monitoring':
                    loadMonitoringData();
                    ensureMonitoringPoll();
                    break;
                case 'instructions':
                    loadInstructions();
                    break;
            }
        }

        let graphOriginalSource = '';
        let graphEditing = false;

        async function reloadGraphMermaid(){
            const enrichEl = document.getElementById('graph-enrich');
            const categoriesEl = document.getElementById('graph-categories');
            const usageEl = document.getElementById('graph-usage');
            const edgeTypesEl = document.getElementById('graph-edgeTypes');
            const layoutSel = document.getElementById('graph-layout');
            const themeSel = document.getElementById('graph-theme');
            const debugEnabled = !!document.getElementById('graph-debug')?.checked;
            const enrich = enrichEl && 'checked' in enrichEl ? enrichEl.checked : false;
            const categories = categoriesEl && 'checked' in categoriesEl ? categoriesEl.checked : false;
            const usage = usageEl && 'checked' in usageEl ? usageEl.checked : false;
            const edgeTypesRaw = edgeTypesEl && 'value' in edgeTypesEl ? (edgeTypesEl.value || '').trim() : '';
            let layout = (layoutSel && 'value' in layoutSel) ? layoutSel.value : 'elk';
            const theme = (themeSel && 'value' in themeSel) ? themeSel.value : 'dark';
            const params = new URLSearchParams();
            if(enrich) params.set('enrich','1');
            if(categories) params.set('categories','1');
            if(usage) params.set('usage','1');
            if(edgeTypesRaw) params.set('edgeTypes', edgeTypesRaw);
            const target = document.getElementById('graph-mermaid');
            const metaEl = document.getElementById('graph-meta');
            const metaEl2 = document.getElementById('graph-meta2');
            if(target) target.textContent = '(loading graph...)';
            try {
                if(debugEnabled) graphLog('fetching mermaid graph', { query: params.toString(), requestedLayout: layout });
                const res = await fetch('/api/graph/mermaid?'+params.toString());
                const data = await res.json();
                if(data?.success && data.mermaid){
                    let mermaidSource = data.mermaid;
                    const effectiveLayout = layout === 'elk' ? 'elk' : 'default';
                    if(effectiveLayout === 'elk') await ensureMermaidElk();
                    // Build unified frontmatter config (theme + optional layout)
                    const configLines = [];
                    if(theme) configLines.push(`  theme: ${theme}`);
                    if(effectiveLayout === 'elk') configLines.push('  layout: elk');
                    if(configLines.length){
                        mermaidSource = `---\nconfig:\n${configLines.join('\n')}\n---\n` + mermaidSource;
                    }
                    graphOriginalSource = mermaidSource;
                    if(target) target.textContent = mermaidSource;
                    if(metaEl) metaEl.textContent = `schema=v${data.meta?.graphSchemaVersion} nodes=${data.meta?.nodeCount} edges=${data.meta?.edgeCount}`;
                    if(metaEl2){
                        const attempts = window.mermaid?.__elkDebug?.attempts || [];
                        const last = attempts.length ? attempts[attempts.length-1] : null;
                        const attemptInfo = last ? `${last.state}:${(last.url||'').split('/').slice(-1)[0]}` : '';
                        const mermaidVersion = (window.mermaid && (window.mermaid.version || window.mermaid.mermaidAPI?.getConfig?.()?.version)) || 'unknown';
                        metaEl2.textContent = `layout=${effectiveLayout} elkRegistered=${!!window.mermaid?.mcpElkRegistered} elkState=${window.mermaid?.__elkDebug?.state||'n/a'}${attemptInfo? ' last='+attemptInfo:''} mermaid=${mermaidVersion}`;
                    }
                    // Attempt visual render best-effort
                    try {
                        await ensureMermaid();
                        if(effectiveLayout === 'elk' && !window.mermaid?.mcpElkRegistered){
                            await ensureMermaidElk(); // late retry if initial registration raced
                        }
                        if(window.mermaid){
                            let renderCode = mermaidSource;
                            let svg;
                            try {
                                ({ svg } = await window.mermaid.render('graphMermaidSvg', renderCode));
                            } catch(inner){
                                // Fallback legacy init directive if frontmatter unsupported for elk
                                if(effectiveLayout === 'elk'){
                                    if(debugEnabled) graphLog('frontmatter elk failed; attempting legacy init directive');
                                    const alt = `%%{init: { 'flowchart': { 'layout': 'elk' } }}%%\n` + data.mermaid;
                                    ({ svg } = await window.mermaid.render('graphMermaidSvg', alt));
                                } else throw inner;
                            }
                            const legacyHost = document.getElementById('graph-mermaid-svg');
                            if(legacyHost){ legacyHost.innerHTML = svg; }
                            // Toggle elk-specific styling class on the render card
                            try {
                                const renderCard = document.getElementById('graph-render-card');
                                if(renderCard){
                                    if(effectiveLayout === 'elk') renderCard.classList.add('elk-layout-active');
                                    else renderCard.classList.remove('elk-layout-active');
                                }
                            } catch { /* ignore */ }
                            const renderedWrap = document.getElementById('graph-mermaid-rendered');
                            if(renderedWrap){ renderedWrap.style.display = 'block'; }
                            if(debugEnabled) graphLog('render complete',{ effectiveLayout, elkRegistered: !!window.mermaid?.mcpElkRegistered });
                        }
                    } catch(err){
                        // eslint-disable-next-line no-console
                        console.warn('[admin][mermaid-render-failed]', err);
                        if(debugEnabled) graphLog('render error', { error: err?.message });
                    }
                } else {
                    if(target) target.textContent = '(graph unavailable)';
                    if(debugEnabled) graphLog('graph api returned no data');
                }
            } catch(e){
                if(target) target.textContent = '(graph load error)';
                if(debugEnabled) graphLog('graph load error', { error: e?.message });
            }
        }

        function copyMermaidSource(){
            const el = document.getElementById('graph-mermaid');
            if(!el) return;
            const txt = el.textContent || '';
            navigator.clipboard.writeText(txt).then(()=>{
                const metaEl = document.getElementById('graph-meta');
                if(metaEl){
                    const prev = metaEl.textContent;
                    metaEl.textContent = (prev? prev+' | ': '') + 'copied';
                    setTimeout(()=>{ metaEl.textContent = prev || ''; }, 1500);
                }
            }).catch(()=>{});
        }

        function toggleGraphRaw(){
            // Deprecated: raw & rendered now always visible in split view. Keep no-op for backward compatibility.
            return;
        }

        function toggleGraphEdit(){
            if(graphEditing){
                cancelGraphEdit();
                return;
            }
            const target = document.getElementById('graph-mermaid');
            if(!target) return;
            graphEditing = true;
            target.setAttribute('contenteditable','true');
            target.style.outline = '1px solid #3498db';
            document.getElementById('graph-edit-btn').style.display='none';
            document.getElementById('graph-apply-btn').style.display='inline-block';
            document.getElementById('graph-cancel-btn').style.display='inline-block';
        }

        function applyGraphEdit(){
            const target = document.getElementById('graph-mermaid');
            if(!target) return;
            const code = target.textContent || '';
            (async ()=>{
                try {
                    await ensureMermaid();
                    const { svg } = await window.mermaid.render('graphMermaidSvg', code);
                    const legacyHost = document.getElementById('graph-mermaid-svg');
                    if(legacyHost){ legacyHost.innerHTML = svg; }
                } catch(e){
                    // eslint-disable-next-line no-alert
                    alert('Render failed: '+ e.message);
                }
            })();
            cancelGraphEdit(true);
        }

        function cancelGraphEdit(keep){
            if(!graphEditing) return;
            const target = document.getElementById('graph-mermaid');
            if(target){
                target.removeAttribute('contenteditable');
                target.style.outline='none';
                if(!keep) target.textContent = graphOriginalSource;
            }
            graphEditing = false;
            document.getElementById('graph-edit-btn').style.display='inline-block';
            document.getElementById('graph-apply-btn').style.display='none';
            document.getElementById('graph-cancel-btn').style.display='none';
        }

        // Lazy mermaid loader (enhanced with cache bust + stale v10 reload safeguard)
        let mermaidLoading = null;
        let mermaidElkLoading = null; // ensures elk layout plugin is loaded & registered
        const MERMAID_VERSION_TARGET = '11';
        function mermaidNeedsReload(force){
            if(force) return true;
            if(!window.mermaid) return true;
            const ver = window.mermaid.version || window.mermaid.mermaidAPI?.getConfig?.()?.version || '';
            if(ver.startsWith('10.')) return true;
            return false;
        }
        async function ensureMermaid(force){
            if(mermaidNeedsReload(force)){
                if(window.mermaid && (force || !window.mermaid.registerLayoutLoaders)){
                    try { [...document.querySelectorAll('script[src*="mermaid"]')].forEach(s=>s.remove()); } catch{}
                    try { delete window.mermaid; } catch{}
                    mermaidLoading = null;
                }
            }
            if(window.mermaid && !force) return;
            if(mermaidLoading) return mermaidLoading;
            mermaidLoading = new Promise((resolve,reject)=>{
                const s = document.createElement('script');
                const cb = Date.now().toString().slice(-7);
                s.src = `https://cdn.jsdelivr.net/npm/mermaid@${MERMAID_VERSION_TARGET}/dist/mermaid.min.js?cb=${cb}`;
                s.onload = ()=>{ try {
                    window.mermaid.initialize({
                        startOnLoad:false,
                        theme:'dark',
                        themeVariables:{
                            primaryColor:'#273341',
                            primaryBorderColor:'#6b8cff',
                            primaryTextColor:'#e3ebf5',
                            lineColor:'#5479ff',
                            secondaryColor:'#1b2530',
                            tertiaryColor:'#273341'
                        }
                    });
                    resolve(null);
                } catch(e){ reject(e); } };
                s.onerror = (e)=>reject(e instanceof Error? e : new Error('mermaid load failed'));
                document.head.appendChild(s);
            });
            return mermaidLoading;
        }

        // Load @mermaid-js/layout-elk plugin and register. Safe to call multiple times.
        async function ensureMermaidElk(){
            await ensureMermaid();
            if(window.mermaid && !window.mermaid.registerLayoutLoaders && !window.mermaid.__reloadedOnce){
                window.mermaid.__reloadedOnce = true; // one forced refresh upgrade attempt
                await ensureMermaid(true);
            }
            if(window.mermaid?.mcpElkRegistered) return; // already good
            if(mermaidElkLoading) return mermaidElkLoading;
            mermaidElkLoading = new Promise((resolve)=>{
                const debugEnabled = !!document.getElementById('graph-debug')?.checked;
                // First try locally bundled copy (produced by build script) for air‚Äëgapped/corporate networks.
                // For 0.2.x we ship ESM build; we'll attempt dynamic import for local copy
                const localElk = './mermaid-layout-elk.esm.min.mjs';
                // 0.2.x exposes only ESM builds; use dynamic import for all sources.
                const urls = [
                    localElk,
                    'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs',
                    'https://unpkg.com/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs',
                    'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@latest/dist/mermaid-layout-elk.esm.min.mjs'
                ];
                const elkDebug = (window.mermaid.__elkDebug = window.mermaid.__elkDebug || { attempts:[], state:'init' });
                function setState(s, extra){ elkDebug.state = s; if(extra) elkDebug.attempts.push({ state:s, ...extra }); if(debugEnabled) graphLog('elk '+s, extra); }
                let idx = 0;
                const preKeys = debugEnabled ? Object.keys(window) : [];
                function tryNext(){
                    if(window.mermaid?.mcpElkRegistered){ setState('registered-skip'); return resolve(null); }
                    if(idx >= urls.length){ setState('exhausted'); return resolve(null); }
                    const url = urls[idx++];
                    setState('loading', { url });
                    (async ()=>{
                        const timeoutMs = 6000;
                        const timeout = setTimeout(()=>{ if(!window.mermaid?.mcpElkRegistered){ setState('load-timeout', { url, timeoutMs }); tryNext(); } }, timeoutMs);
                        try {
                            const mod = await import(url);
                            setState('loaded', { url, esm:true, keys:Object.keys(mod||{}) });
                            // Export shape: default is an array of { name, loader, algorithm }
                            let descriptorArray = null;
                            let mapCandidate = null;
                            if(mod){
                                descriptorArray = (mod.default && Array.isArray(mod.default)) ? mod.default : (Array.isArray(mod) ? mod : null);
                                if(descriptorArray){
                                    const obj = {};
                                    for(const item of descriptorArray){ if(item?.name && item?.loader){ obj[item.name] = item.loader; } }
                                    if(Object.keys(obj).length) mapCandidate = obj;
                                }
                            }
                            if(!descriptorArray && !mapCandidate){ setState('candidate-missing', { url, esm:true }); return tryNext(); }
                            let registered = false;
                            let attemptedForms = [];
                            function finalizeSuccess(layoutList, mode){
                                window.mermaid.mcpElkRegistered = true;
                                if(!elkDebug.state.startsWith('registered')) setState(mode, { layouts: layoutList, esm:true });
                                try { window.mermaid.initialize({
                                    startOnLoad:false,
                                    theme:'dark',
                                    themeVariables:{
                                        primaryColor:'#273341',
                                        primaryBorderColor:'#6b8cff',
                                        primaryTextColor:'#e3ebf5',
                                        lineColor:'#5479ff',
                                        secondaryColor:'#1b2530',
                                        tertiaryColor:'#273341'
                                    }
                                }); } catch { /* ignore */ }
                            }
                            if(window.mermaid?.registerLayoutLoaders){
                                // Try array form first (likely expected in v11+)
                                if(descriptorArray){
                                    try {
                                        attemptedForms.push('array');
                                        window.mermaid.registerLayoutLoaders(descriptorArray);
                                        registered = true;
                                        finalizeSuccess(descriptorArray.map(d=>d.name).filter(Boolean),'registered-array');
                                    } catch(eArray){
                                        setState('register-array-error', { message:eArray?.message, esm:true });
                                        // Fallback to object map if available
                                        if(mapCandidate){
                                            try {
                                                attemptedForms.push('map');
                                                window.mermaid.registerLayoutLoaders(mapCandidate);
                                                registered = true;
                                                finalizeSuccess(Object.keys(mapCandidate),'registered-map');
                                            } catch(eMap){
                                                setState('register-error', { message:eMap?.message, esm:true, attempted:attemptedForms });
                                            }
                                        }
                                    }
                                } else if(mapCandidate){
                                    try {
                                        attemptedForms.push('map');
                                        window.mermaid.registerLayoutLoaders(mapCandidate);
                                        registered = true;
                                        finalizeSuccess(Object.keys(mapCandidate),'registered-map');
                                    } catch(eOnly){
                                        setState('register-error', { message:eOnly?.message, esm:true, attempted:attemptedForms });
                                    }
                                }
                            } else if(window.mermaid?.mermaidAPI){
                                // Legacy fallback: inject into mermaidAPI.layoutLoaders if structure exists (v10 style)
                                try {
                                    const api = window.mermaid.mermaidAPI;
                                    const loadersToMerge = mapCandidate || (descriptorArray ? descriptorArray.reduce((acc,it)=>{ if(it?.name && it?.loader) acc[it.name]=it.loader; return acc; },{}) : {});
                                    api.layoutLoaders = { ...(api.layoutLoaders||{}), ...loadersToMerge };
                                    registered = true;
                                    finalizeSuccess(Object.keys(loadersToMerge),'registered-legacy');
                                } catch(e){ setState('register-error-legacy', { message:e?.message, esm:true }); }
                            } else {
                                setState('register-missing', { message:'registerLayoutLoaders unavailable', esm:true });
                            }
                            // If neither path succeeded but we had candidates, record failure clearly
                            if(!registered && (descriptorArray || mapCandidate)){
                                setState('register-failed', { forms: attemptedForms, haveArray: !!descriptorArray, haveMap: !!mapCandidate });
                            }
                        } catch(e){ setState('load-error', { url, message:e?.message, esm:true }); }
                        finally { clearTimeout(timeout); if(window.mermaid?.mcpElkRegistered) resolve(null); else tryNext(); }
                    })();
                }
                tryNext();
            });
            return mermaidElkLoading;
        }

        // Simple debug logger (conditionally outputs & annotates meta2)
        function graphLog(message, data){
            try {
                const enabled = false; // debug UI removed
                if(!enabled) return; // keep structure for potential future re-enable
                // Console output
                if(data !== undefined) {
                    // eslint-disable-next-line no-console
                    console.log('[graph-debug]', message, data);
                } else {
                    // eslint-disable-next-line no-console
                    console.log('[graph-debug]', message);
                }
                // Append short line to meta2 (rolling 6 lines)
                const meta2 = document.getElementById('graph-meta2');
                if(meta2){
                    const now = new Date().toISOString().split('T')[1].replace('Z','');
                    const line = data ? `${now} ${message} ${JSON.stringify(data).slice(0,160)}` : `${now} ${message}`;
                    const existing = meta2.getAttribute('data-log') ? JSON.parse(meta2.getAttribute('data-log')) : [];
                    existing.push(line);
                    while(existing.length > 6) existing.shift();
                    meta2.setAttribute('data-log', JSON.stringify(existing));
                    meta2.textContent = (meta2.textContent.split('\n')[0] || meta2.textContent) + '\n' + existing.join('\n');
                }
            } catch{ /* ignore */ }
        }

        async function loadOverviewData() {
            try {
                const [statsRes, maintenanceRes, healthRes] = await Promise.all([
                    fetch('/api/admin/stats').catch(e => e),
                    fetch('/api/admin/maintenance').catch(e => e),
                    fetch('/api/health').catch(e => e)
                ]);

                const [statsData, maintenanceData, healthData] = await Promise.all([
                    statsRes?.json ? statsRes.json().catch(() => ({})) : {},
                    maintenanceRes?.json ? maintenanceRes.json().catch(() => ({})) : {},
                    healthRes?.json ? healthRes.json().catch(() => ({})) : {}
                ]);

                if (statsData?.success && statsData.stats) {
                    statsAvailable = true;
                    displaySystemStats(statsData.stats);
                } else {
                    statsAvailable = false;
                    const statsEl = document.getElementById('system-stats');
                    if (statsEl) statsEl.innerHTML = '<div class="error-message">Stats unavailable</div>';
                }

                // Maintenance summary (safe-guarded: function may be a no-op if not yet implemented)
                if (maintenanceData?.success && maintenanceData.maintenance) {
                    if (typeof displayMaintenanceInfo === 'function') {
                        try { displayMaintenanceInfo(maintenanceData.maintenance); } catch(e) { console.warn('displayMaintenanceInfo failed:', e); }
                    }
                }

                // Accept multiple health status variants: legacy 'ok' plus basic endpoint 'healthy'/'degraded'
                if (healthData && (healthData.success || ['ok','healthy','degraded'].includes(healthData.status))) {
                    displaySystemHealth(healthData.systemHealth || healthData.maintenance?.systemHealth || healthData);
                }
            } catch (error) {
                console.error('Error loading overview data:', error);
                showError('Failed to load overview data');
            }
        }

        function displaySystemStats(stats) {
            // retain last stats for resource trend re-renders
            try { window.lastSystemStats = stats; } catch(e) { /* ignore */ }
            const html = `
                <div class="stat-row">
                    <span class="stat-label">Uptime</span>
                    <span class="stat-value">${formatUptime(stats.uptime)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Connections (WS)</span>
                    <span class="stat-value">${stats.activeConnections}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Admin Sessions</span>
                    <span class="stat-value">${stats.adminActiveSessions ?? '0'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Requests</span>
                    <span class="stat-value">${stats.totalRequests.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Error Rate</span>
                    <span class="stat-value">${stats.errorRate.toFixed(2)}%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Response Time</span>
                    <span class="stat-value">${stats.avgResponseTime.toFixed(1)}ms</span>
                </div>
                <hr style="opacity:.15;margin:6px 0;"/>
                <div class="stat-row">
                    <span class="stat-label" style="opacity:.8">Catalog Total</span>
                    <span class="stat-value">${stats.catalogStats?.totalInstructions ?? '‚Äî'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label" style="opacity:.8">Catalog Version</span>
                    <span class="stat-value">${stats.catalogStats?.version ?? '‚Äî'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label" style="opacity:.8">Schema Version</span>
                    <span class="stat-value">${stats.catalogStats?.schemaVersion ?? 'unknown'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label" style="opacity:.8">Last Updated</span>
                    <span class="stat-value">${stats.catalogStats?.lastUpdated ? new Date(stats.catalogStats.lastUpdated).toLocaleString() : 'N/A'}</span>
                </div>
            `;
            document.getElementById('system-stats').innerHTML = html;

            // Performance + Resource trend stats (merged)
            // We'll augment with last resource samples (if available via window.__resourceSamples from fetch loop)
            const perfParts = [];
            perfParts.push(`
                <div class="stat-row">
                    <span class="stat-label">Total Connections</span>
                    <span class="stat-value">${stats.totalConnections.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Error Rate</span>
                    <span class="stat-value">${stats.errorRate.toFixed(2)}%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Response Time</span>
                    <span class="stat-value">${stats.avgResponseTime.toFixed(1)}ms</span>
                </div>`);
            try {
                if(window.__resourceTrendCache){
                    const t = window.__resourceTrendCache;
                    perfParts.push(`
                        <div class="stat-row">
                            <span class="stat-label">Window</span>
                            <span class="stat-value">${t.windowSec}s (${t.sampleCount} samples)</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Memory Usage</span>
                            <span class="stat-value">${formatBytes(stats.memoryUsage.heapUsed)} / ${formatBytes(stats.memoryUsage.heapTotal)}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Memory Min‚ÜíMax</span>
                            <span class="stat-value">${formatBytes(t.minHeap || 0)} ‚Üí ${formatBytes(t.maxHeap || 0)}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Latest CPU</span>
                            <span class="stat-value">${t.latestCpu.toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">CPU Min‚ÜíMax</span>
                            <span class="stat-value">${(t.minCpu??0).toFixed(1)}% ‚Üí ${(t.maxCpu??0).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Latest Heap</span>
                            <span class="stat-value">${(t.latestHeap/1024/1024).toFixed(2)} MB</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">CPU Slope</span>
                            <span class="stat-value">${t.cpuSlope.toFixed(3)} %/s</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Mem Slope</span>
                            <span class="stat-value">${(t.memSlope/1024).toFixed(2)} KB/s</span>
                        </div>
                        <!-- CPU/Mem spark lines moved to System Health card -->`);
                }
            } catch(e) { /* ignore */ }
            document.getElementById('performance-stats').innerHTML = perfParts.join('');

            // Catalog stats merged; no separate rendering

            // Display individual tool metrics
            displayToolMetrics(stats);
        }

        function displayToolMetrics(stats) {
            const toolMetricsEl = document.getElementById('tool-metrics');
            if (!toolMetricsEl || !stats.toolMetrics) {
                if (toolMetricsEl) toolMetricsEl.innerHTML = '<div class="error-message">Tool metrics unavailable</div>';
                return;
            }

            const tools = Object.entries(stats.toolMetrics);
            if (tools.length === 0) {
                toolMetricsEl.innerHTML = '<div class="stat-row"><span class="stat-label">No tool calls recorded yet</span></div>';
                return;
            }

            // Sort tools by call count (most used first)
            tools.sort(([,a], [,b]) => b.callCount - a.callCount);

            let html = '<div class="tool-metrics-grid">';
            
            tools.forEach(([toolName, metrics]) => {
                const avgResponseTime = metrics.callCount > 0 ? (metrics.totalResponseTime / metrics.callCount).toFixed(1) : '0.0';
                const successRate = metrics.callCount > 0 ? ((metrics.successCount / metrics.callCount) * 100).toFixed(1) : '100.0';
                const lastCalledStr = metrics.lastCalled ? new Date(metrics.lastCalled).toLocaleString() : 'Never';
                
                html += `
                    <div class="tool-metric-card">
                        <div class="tool-name">${toolName}</div>
                        <div class="tool-stats">
                            <div class="stat-row">
                                <span class="stat-label">Total Calls</span>
                                <span class="stat-value">${metrics.callCount.toLocaleString()}</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Success Rate</span>
                                <span class="stat-value ${parseFloat(successRate) < 95 ? 'warning' : ''}">${successRate}%</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Avg Response</span>
                                <span class="stat-value">${avgResponseTime}ms</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Errors</span>
                                <span class="stat-value ${metrics.errorCount > 0 ? 'error' : ''}">${metrics.errorCount}</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Last Called</span>
                                <span class="stat-value small">${lastCalledStr}</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            toolMetricsEl.innerHTML = html;
        }

        // Lightweight overview-level maintenance display (optional)
        // Intentionally minimal to avoid blocking overview rendering.
        // If an element with id 'maintenance-overview' exists, populate it; otherwise no-op.
        function displayMaintenanceInfo(maintenance) {
            try {
                const el = document.getElementById('maintenance-overview');
                if (!el || !maintenance) return; // Safe no-op if overview element not present
                const mode = maintenance.maintenanceMode ? 'ENABLED' : 'Disabled';
                el.innerHTML = `
                    <div class="stat-row">
                        <span class="stat-label">Maintenance Mode</span>
                        <span class="stat-value ${maintenance.maintenanceMode ? 'maintenance-enabled' : 'maintenance-disabled'}">${mode}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Last Backup</span>
                        <span class="stat-value">${maintenance.lastBackup ? new Date(maintenance.lastBackup).toLocaleString() : 'Never'}</span>
                    </div>`;
            } catch (err) {
                console.warn('displayMaintenanceInfo error:', err);
            }
        }

        function displaySystemHealth(health) {
            // Defensive normalization: /api/health returns { status, checks, uptime, timestamp } (no issues/recommendations)
            // while richer maintenance/system health objects may include arrays. Avoid assuming presence.
            if(!health || typeof health !== 'object') {
                document.getElementById('system-health').innerHTML = '<div class="error-message">Health data unavailable</div>';
                return;
            }
            const normalized = {
                status: (health.status || 'unknown').toString(),
                issues: Array.isArray(health.issues) ? health.issues : [],
                recommendations: Array.isArray(health.recommendations) ? health.recommendations : [],
                uptime: typeof health.uptime === 'number' ? health.uptime : (typeof health.server?.uptime === 'number' ? health.server.uptime : undefined),
                checks: health.checks || {}
            };
            // Inject CPU check if not present using last resource cache / stats
            try {
                if(!normalized.checks.cpu){
                    let cpuVal = undefined;
                    if(window.__resourceTrendCache && typeof window.__resourceTrendCache.latestCpu === 'number') cpuVal = window.__resourceTrendCache.latestCpu;
                    else if(window.lastSystemStats && window.lastSystemStats.cpuUsage && typeof window.lastSystemStats.cpuUsage.percent==='number') cpuVal = window.lastSystemStats.cpuUsage.percent;
                    if(typeof cpuVal === 'number'){
                        // simple thresholds: <50 ok, 50-80 warn (ok), >80 fail
                        normalized.checks.cpu = cpuVal < 85; // treat >85 as fail
                        if(cpuVal >=85 && !normalized.issues.some(i=>/high cpu/i.test(i))) normalized.issues.push('High CPU usage');
                    }
                }
            } catch{/*ignore*/}
            // Uptime regression styling escalation: if an issue contains 'Uptime regression' force critical indicator
            let statusOverride = normalized.status;
            if (normalized.issues.some(i => /uptime regression/i.test(i))) {
                statusOverride = 'critical';
            }

            // If stats are unavailable, force failure semantics for memory/errors checks.
            if (!statsAvailable) {
                // Ensure checks for memory & errors exist and are marked as failed
                if (normalized.checks) {
                    normalized.checks.memory = false;
                    normalized.checks.errors = false;
                } else {
                    normalized.checks = { memory: false, errors: false };
                }
                if (!normalized.issues.some(i => /statistics unavailable/i.test(i))) {
                    normalized.issues.push('Statistics unavailable');
                }
                // Only override to failed if not already critical (critical remains highest severity)
                if (statusOverride !== 'critical') {
                    statusOverride = 'failed';
                }
            }
            const statusClass = `status-${statusOverride}`;
            let html = `
                <div class="stat-row">
                    <span class="stat-label">Overall Status</span>
                    <span class="stat-value">
                        ${statusOverride.toUpperCase()}
                        <span class="${statusClass} status-indicator"></span>
                    </span>
                </div>
            `;

            // Show basic check breakdown if present
            try {
                const checkKeys = Object.keys(normalized.checks);
                if(checkKeys.length){
                    html += '<div style="margin-top:10px;"><strong>Checks:</strong><ul style="margin-left:20px; margin-top:5px;">' +
                        checkKeys.map(k => `<li style=\"color:${normalized.checks[k]?'#2ecc71':'#e74c3c'};\">${k}: ${normalized.checks[k]?'ok':'fail'}</li>`).join('') + '</ul></div>';
                }
            } catch { /* ignore */ }

            // Add CPU trend information if available
            if (health.cpuTrend) {
                html += `
                    <div style="margin-top: 10px;">
                        <strong>CPU Trend:</strong> 
                        <span style="color: ${health.cpuTrend === 'stable' ? '#2ecc71' : health.cpuTrend === 'increasing' ? '#f39c12' : '#e74c3c'};">
                            ${health.cpuTrend}
                        </span>
                    </div>
                `;
            }

            // Add memory trend information if available
            if (health.memoryTrend) {
                const formatGrowthRate = (rate) => {
                    if (Math.abs(rate) < 1024) return `${rate.toFixed(0)} B/min`;
                    if (Math.abs(rate) < 1024 * 1024) return `${(rate / 1024).toFixed(1)} KB/min`;
                    return `${(rate / (1024 * 1024)).toFixed(1)} MB/min`;
                };
                
                html += `
                    <div style="margin-top: 10px;">
                        <strong>Memory Trend:</strong> 
                        <span style="color: ${health.memoryTrend === 'stable' ? '#2ecc71' : health.memoryTrend === 'increasing' ? '#f39c12' : '#e74c3c'};">
                            ${health.memoryTrend}
                        </span>
                        ${health.memoryGrowthRate ? ` (${formatGrowthRate(health.memoryGrowthRate)})` : ''}
                    </div>
                `;
            }

            if (normalized.issues.length > 0) {
                html += `
                    <div style="margin-top: 15px;">
                        <strong>Issues:</strong>
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            ${normalized.issues.map(issue => `<li style="color: #e74c3c;">${issue}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            if (normalized.recommendations.length > 0) {
                html += `
                    <div style="margin-top: 15px;">
                        <strong>Recommendations:</strong>
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            ${normalized.recommendations.map(rec => `<li style="color: #f39c12;">${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Append CPU / Memory spark lines (moved from performance card)
            try {
                if (window.__resourceTrendCache) {
                    const t = window.__resourceTrendCache;
                    const sparkHtml = `
                        <div style="margin-top:14px;">
                            <div style="font-weight:600; font-size:12px; margin-bottom:4px; opacity:.8;">Resource Trend</div>
                            <div style="display:flex; flex-direction:column; gap:6px;">
                                <div style="display:flex; flex-direction:column;">
                                    <span style="font-size:11px; opacity:.65;">CPU Spark (last ${Math.min(40, t.sampleCount || 0)} samples)</span>
                                    <span style="font-family:monospace; font-size:14px; background:#14171c; padding:4px 6px; border-radius:4px; overflow:hidden;">${t.spark || ''}</span>
                                    <span style="font-size:11px; opacity:.55;">Latest ${t.latestCpu?.toFixed ? t.latestCpu.toFixed(1) : '0'}% ‚Ä¢ Min ${(t.minCpu??0).toFixed(1)}% ‚Ä¢ Max ${(t.maxCpu??0).toFixed(1)}%</span>
                                </div>
                                <div style="display:flex; flex-direction:column;">
                                    <span style="font-size:11px; opacity:.65;">Mem Spark (heap)</span>
                                    <span style="font-family:monospace; font-size:14px; background:#14171c; padding:4px 6px; border-radius:4px; overflow:hidden;">${t.memSpark || ''}</span>
                                    <span style="font-size:11px; opacity:.55;">Latest ${(t.latestHeap/1024/1024).toFixed(2)} MB ‚Ä¢ Min ${(t.minHeap/1024/1024).toFixed(2)} MB ‚Ä¢ Max ${(t.maxHeap/1024/1024).toFixed(2)} MB</span>
                                </div>
                            </div>
                        </div>`;
                    html += sparkHtml;
                }
            } catch {/* ignore */}

            document.getElementById('system-health').innerHTML = html;
            try { window.lastSystemHealth = health; } catch {/* ignore */}
        }

        // --- Backup / Restore ---
        async function loadBackups() {
            try {
                const sel = document.getElementById('backup-select');
                const meta = document.getElementById('backup-list-meta');
                if (!sel) return;
                sel.innerHTML = '<option value="">Loading...</option>';
                const res = await fetch('/api/admin/maintenance/backups');
                if (!res.ok) throw new Error('list failed');
                const data = await res.json();
                const backups = (data.backups || []).slice(0, 200);
                if (!backups.length) {
                    sel.innerHTML = '<option value="">(no backups)</option>';
                    if (meta) meta.textContent = 'No backups available';
                    return;
                }
                sel.innerHTML = backups.map(b => {
                    const label = `${b.id}  ‚Ä¢  ${b.instructionCount} files  ‚Ä¢  ${b.schemaVersion || 'schema?'}  ‚Ä¢  ${new Date(b.createdAt).toLocaleString()}`;
                    return `<option value="${b.id}">${label}</option>`;
                }).join('');
                if (meta) meta.textContent = `${backups.length} backup(s)`;
            } catch (err) {
                console.warn('loadBackups error', err);
                const sel = document.getElementById('backup-select');
                if (sel) sel.innerHTML = '<option value="">(error loading)</option>';
            }
        }

        async function restoreSelectedBackup() {
            try {
                const sel = document.getElementById('backup-select');
                const statusEl = document.getElementById('backup-restore-status');
                if (!sel || !sel.value) { if (statusEl) statusEl.textContent = 'Select a backup first'; return; }
                const choice = sel.value;
                if (!confirm(`Restore backup ${choice}? Current instructions will be safety-backed up first.`)) return;
                statusEl.textContent = 'Restoring...';
                const res = await fetch('/api/admin/maintenance/restore', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ backupId: choice }) });
                const data = await res.json();
                if (data.success) {
                    statusEl.textContent = `Restored ${choice} (${data.restored || 0} files)`;
                    // Re-load stats & instructions to reflect changes
                    loadOverviewData();
                    if (currentSection === 'instructions') loadInstructions();
                } else {
                    statusEl.textContent = `Restore failed: ${data.error || data.message || 'unknown'}`;
                }
            } catch (err) {
                const statusEl = document.getElementById('backup-restore-status');
                if (statusEl) statusEl.textContent = 'Error restoring backup';
            }
        }

                async function loadSessions() {
            try {
                let sessionsCount = 0;
                let connectionsCount = 0;
                // Admin logical sessions
                const response = await fetch('/api/admin/sessions');
                const data = await response.json();
                if (data.success) {
                    displaySessions(data.sessions);
                    sessionsCount = Array.isArray(data.sessions) ? data.sessions.length : 0;
                    // If no sessions were active, attempt auto-create then reload once
                    if (sessionsCount === 0) {
                        try {
                            const created = await maybeEnsureAdminSession(true);
                            if (created) {
                                // Re-fetch sessions after creation
                                const r2 = await fetch('/api/admin/sessions');
                                const d2 = await r2.json();
                                if (d2.success) { displaySessions(d2.sessions); sessionsCount = d2.sessions.length; }
                            }
                        } catch(e) { /* ignore */ }
                    }
                } else {
                    showError('Failed to load sessions');
                }
                // Active websocket connections
                try {
                    const connRes = await fetch('/api/admin/connections');
                    const connData = await connRes.json();
                    const connEl = document.getElementById('connections-list');
                    if (connData.success && connEl) {
                        connectionsCount = Array.isArray(connData.connections) ? connData.connections.length : 0;
                        if (!connectionsCount) {
                            connEl.innerHTML = '<div class="empty-state">No active websocket connections</div>';
                        } else {
                            const fmt = (ms) => {
                                if (ms == null) return '‚Äî';
                                if (ms < 1000) return ms + ' ms';
                                const s = ms / 1000;
                                if (s < 60) return s.toFixed(1) + ' s';
                                const m = Math.floor(s / 60);
                                const rs = Math.floor(s % 60);
                                return m + 'm ' + rs + 's';
                            };
                            connEl.innerHTML = '<table class="session-table"><thead><tr><th>ID</th><th>Connected</th><th>Duration</th></tr></thead><tbody>' +
                                connData.connections.map(c => {
                                    const connected = c.connectedAt ? new Date(c.connectedAt).toLocaleTimeString() : '‚Äî';
                                    return `<tr><td>${escapeHtml(c.id)}</td><td>${connected}</td><td>${fmt(c.durationMs)}</td></tr>`;
                                }).join('') + '</tbody></table>';
                        }
                    } else if (connEl) {
                        connEl.innerHTML = '<div class="error-message">Failed to load active connections</div>';
                    }
                } catch (e) {
                    const connEl = document.getElementById('connections-list');
                    if (connEl) connEl.innerHTML = '<div class="error-message">Error loading active connections</div>';
                }

                // Auto-load session history (now part of Sessions section)
                try { if (typeof loadSessionHistory === 'function') loadSessionHistory(parseInt((document.getElementById('session-history-limit')||{value:'50'}).value,10)); } catch {}
                // Update nav badge with latest counts
                window.__lastSessionsCount = sessionsCount;
                window.__lastConnectionsCount = connectionsCount;
                updateSessionsNavBadge();
            } catch (error) {
                console.error('Error loading sessions:', error);
                showError('Failed to load sessions');
            }
        }

        function updateSessionsNavBadge(){
            const navBtn = document.getElementById('nav-sessions');
            if(!navBtn) return;
            const s = window.__lastSessionsCount ?? 0;
            const c = window.__lastConnectionsCount ?? 0;
            let badge = navBtn.querySelector('.nav-badge');
            if(!badge){
                badge = document.createElement('span');
                badge.className = 'nav-badge';
                badge.style.cssText = 'margin-left:6px; background:#444; color:#fff; padding:2px 6px; border-radius:10px; font-size:11px; font-weight:500;';
                navBtn.appendChild(badge);
            }
            badge.textContent = `${s}/${c}`; // sessions / connections
            badge.title = `Admin sessions: ${s} | Websocket connections: ${c}`;
        }

        // Auto-session creation logic; stores created session id in sessionStorage to avoid duplicates per tab.
        async function maybeEnsureAdminSession(onlyIfRequested) {
            try {
                if (typeof sessionStorage === 'undefined') return false;
                const existing = sessionStorage.getItem('mcp_admin_session_id');
                // If we already have a session id and we're NOT being explicitly
                // asked to ensure one, skip creating a new one.
                if (existing && !onlyIfRequested) return false;
                // Previous logic bailed out even when the server had zero sessions but
                // the tab held a stale session id (after server restart). That prevented
                // auto recreation. Now, when onlyIfRequested is true we will attempt
                // creation even if a stale id exists; we simply overwrite it.
                const res = await fetch('/api/admin/sessions', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ userId: 'dashboard_auto' }) });
                const data = await res.json().catch(()=>({}));
                if (data.success && data.session && data.session.id) {
                    sessionStorage.setItem('mcp_admin_session_id', data.session.id);
                    return true;
                }
            } catch (e) { /* ignore */ }
            return false;
        }

        // ===== Session History (NEW) =====
        async function loadSessionHistory(limit = 50) {
            try {
                const res = await fetch('/api/admin/sessions/history?limit=' + limit);
                const data = await res.json();
                if (!data.success) throw new Error();
                renderSessionHistory(data.history || []);
            } catch (err) {
                const el = document.getElementById('session-history-list');
                if (el) el.innerHTML = '<div class="error">Failed to load session history</div>';
            }
        }

        function renderSessionHistory(history) {
            const el = document.getElementById('session-history-list');
            if (!el) return;
            if (!history.length) { el.innerHTML = '<p>No history entries</p>'; return; }
            el.innerHTML = history.map(h => `
                <div class="session-item" style="background:#fff;">
                  <div class="session-header">
                    <span class="session-id" style="background:#ececec;">${h.id}</span>
                    <span style="font-size:11px; opacity:0.7;">${h.terminationReason || 'active'}</span>
                  </div>
                  <div class="stat-row"><span class="stat-label">Started</span><span class="stat-value">${h.startTime ? new Date(h.startTime).toLocaleString() : '‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">Ended</span><span class="stat-value">${h.endTime ? new Date(h.endTime).toLocaleString() : '‚Äî'}</span></div>
                </div>`).join('');
        }

        function refreshSessionHistory() {
            const limitSel = document.getElementById('session-history-limit');
            const limit = parseInt(limitSel.value, 10) || 50;
            loadSessionHistory(limit);
        }

                // ===== Synthetic Activity (TRACE-ENABLED) =====
                function toggleSyntheticTraceVisibility(){
                    const wrap = document.getElementById('synthetic-traces-wrapper');
                    const chk = document.getElementById('synthetic-trace-toggle');
                    if(!wrap||!chk) return;
                    wrap.style.display = chk.checked ? 'block':'none';
                }
                async function runSyntheticActivity() {
                    const iter = parseInt(document.getElementById('synthetic-iterations').value, 10) || 10;
                    const conc = parseInt(document.getElementById('synthetic-concurrency').value, 10) || 2;
                    const wantTrace = document.getElementById('synthetic-trace-toggle')?.checked !== false; // default true
                    const btn = document.getElementById('synthetic-run-btn');
                    const output = document.getElementById('synthetic-output');
                    btn.disabled = true; btn.textContent = 'Running‚Ä¶';
                    output.textContent = 'Executing synthetic activity...';
                    const tracesBody = document.getElementById('synthetic-traces-body');
                    if(tracesBody) tracesBody.innerHTML = '';
                    // Accelerate monitoring poll during run
                    let previousInterval = monitoringInterval;
                    if (monitoringInterval) { clearInterval(monitoringInterval); monitoringInterval=null; }
                    monitoringInterval = setInterval(()=>{
                        if (document.getElementById('monitoring-section')?.classList.contains('hidden')) return;
                        loadMonitoringData();
                        updateActiveSyntheticRequests();
                    }, 1000); // fast poll while running
                    let statusTimer = setInterval(updateActiveSyntheticRequests, 1000);
                    try {
                        const url = '/api/admin/synthetic/activity?debug=1'+(wantTrace?'&trace=1&stream=1':'');
                        const res = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ iterations: iter, concurrency: conc }) });
                        const rawText = await res.text();
                        let data = null; try { data = JSON.parse(rawText); } catch { /* ignore */ }
                        if (!res.ok || !data) {
                            throw new Error(data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${res.status} (non-JSON)`);
                        }
                        if (!data.success) {
                            throw new Error(data.error || data.message || 'Unknown failure');
                        }
                        const metaLine = `Executed ${data.executed}/${data.iterationsRequested} (errors:${data.errors}) in ${data.durationMs}ms @c=${data.concurrency} tools:${data.availableCount}`;
                        output.textContent = metaLine + (data.available ? `\nSample: ${data.available.slice(0,5).join(', ')}` : '');
                        const lastMeta = document.getElementById('synthetic-last-meta');
                        if (lastMeta) lastMeta.textContent = `Last run: ${new Date().toLocaleTimeString()} ${metaLine}`;
                        if (wantTrace && tracesBody) {
                            if (Array.isArray(data.traces) && data.traces.length) {
                                const rows = data.traces.map((t,i)=>{
                                    const clr = t.success ? '#0a0' : '#a00';
                                    const err = t.error ? String(t.error).slice(0,80) : '';
                                    const skipped = t.skipped ? ' (skipped)' : '';
                                    return `<tr>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee;">${i+1}</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee; font-family:monospace;">${t.method}${skipped}</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${clr};">${t.success?'‚úì':'‚úó'}</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee;">${t.durationMs}ms</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${t.error?'#b55':'#666'};">${err}</td>
                                    </tr>`;
                                }).join('');
                                tracesBody.innerHTML = rows;
                            } else {
                                const reason = data.traceReason || 'no traces captured';
                                tracesBody.innerHTML = `<tr><td colspan="5" style="padding:4px; font-style:italic;">${reason}</td></tr>`;
                            }
                            document.getElementById('synthetic-traces-wrapper').style.display = 'block';
                        }
                        // Refresh overview + monitoring for updated metrics
                        loadOverviewData();
                        loadMonitoringData();
                    } catch (err) {
                        const emsg = (err && err.message) || 'unknown error';
                        output.textContent = `Synthetic activity failed: ${emsg}`;
                        if (/No safe tools/i.test(emsg)) {
                            output.textContent += '\nHint: Ensure server started after tool handlers registered (import order)';
                        }
                    } finally {
                        btn.disabled = false; btn.textContent = 'Run Synthetic Activity';
                        // Restore slower poll cadence
                        if (monitoringInterval) { clearInterval(monitoringInterval); monitoringInterval=null; }
                        if (statusTimer) { clearInterval(statusTimer); statusTimer=null; }
                        if (!previousInterval) { // restart default if monitoring tab visible
                            ensureMonitoringPoll();
                        }
                        // One last status refresh to clear active counter
                        updateActiveSyntheticRequests();
                    }
                }

                // Fetch active synthetic request count and inject into monitoring panel if present
                async function updateActiveSyntheticRequests(){
                    try {
                        const res = await fetch('/api/admin/synthetic/status');
                        const data = await res.json();
                        if (!data.success) return;
                        const active = data.activeRequests || 0;
                        // Find monitoring panel metric list and append/update a synthetic active row
                        const container = document.getElementById('monitoring-data');
                        if (container && container.innerHTML.includes('Throughput')) {
                            const id = 'active-synth-requests-row';
                            let el = document.getElementById(id);
                            if (!el) {
                                const div = document.createElement('div');
                                div.className='stat-row';
                                div.id = id;
                                div.innerHTML = '<span class="stat-label">Active Synthetic Requests</span><span class="stat-value">0</span>';
                                container.insertBefore(div, container.firstChild.nextSibling); // after first row
                                el = div;
                            }
                            const valSpan = el.querySelector('.stat-value');
                            if (valSpan) valSpan.textContent = String(active);
                        }
                    } catch { /* ignore */ }
                }

        function displaySessions(sessions) {
            if (sessions.length === 0) {
                document.getElementById('sessions-list').innerHTML = '<p>No active admin sessions</p>';
                return;
            }

            const html = sessions.map(session => `
                <div class="session-item">
                    <div class="session-header">
                        <span class="session-id">${session.id}</span>
                        <button class="action-btn danger" onclick="terminateSession('${session.id}')">Terminate</button>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">User ID</span>
                        <span class="stat-value">${session.userId}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">IP Address</span>
                        <span class="stat-value">${session.ipAddress}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Start Time</span>
                        <span class="stat-value">${new Date(session.startTime).toLocaleString()}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Last Activity</span>
                        <span class="stat-value">${new Date(session.lastActivity).toLocaleString()}</span>
                    </div>
                </div>
            `).join('');

            document.getElementById('sessions-list').innerHTML = html;
        }

        async function createTestSession() {
            try {
                const response = await fetch('/api/admin/sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: 'test_admin_' + Date.now() })
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess('Test session created successfully');
                    loadSessions();
                } else {
                    showError('Failed to create test session');
                }
            } catch (error) {
                console.error('Error creating test session:', error);
                showError('Failed to create test session');
            }
        }

        async function terminateSession(sessionId) {
            try {
                const response = await fetch(`/api/admin/sessions/${sessionId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess('Session terminated successfully');
                    loadSessions();
                } else {
                    showError('Failed to terminate session');
                }
            } catch (error) {
                console.error('Error terminating session:', error);
                showError('Failed to terminate session');
            }
        }

        async function loadMaintenanceStatus() {
            try {
                const response = await fetch('/api/admin/maintenance');
                const data = await response.json();

                if (data.success) {
                    displayMaintenanceStatus(data.maintenance);
                } else {
                    showError('Failed to load maintenance status');
                }
            } catch (error) {
                console.error('Error loading maintenance status:', error);
                showError('Failed to load maintenance status');
            }
        }

        function displayMaintenanceStatus(maintenance) {
            const statusClass = maintenance.maintenanceMode ? 'maintenance-enabled' : 'maintenance-disabled';
            const statusText = maintenance.maintenanceMode ? 'MAINTENANCE MODE ENABLED' : 'NORMAL OPERATION';
            
            let html = `
                <div class="maintenance-status ${statusClass}">
                    ${statusText}
                </div>
                <div class="stat-row">
                    <span class="stat-label">Last Backup</span>
                    <span class="stat-value">${maintenance.lastBackup ? new Date(maintenance.lastBackup).toLocaleString() : 'Never'}</span>
                </div>
                <div style="margin-top:10px; font-weight:600; font-size:13px;">Backups</div>
                                <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-top:4px;">
                                    <button class="action-btn" style="padding:4px 8px; font-size:11px;" onclick="selectLatestBackup()">Select Latest</button>
                                    <button class="action-btn danger" style="padding:4px 8px; font-size:11px;" onclick="deleteSelectedBackup()">Delete Selected</button>
                                    <button class="action-btn warning" style="padding:4px 8px; font-size:11px;" onclick="promptPruneBackups()">Prune‚Ä¶</button>
                                    <input id="backup-search" type="text" placeholder="Filter (id / schema)" oninput="filterBackupRows()" style="flex:1; min-width:160px; padding:4px 6px; background:#1c1e22; border:1px solid #2d2f33; border-radius:4px; color:#d0d4d8; font-size:12px;" />
                                    <span id="backup-filter-count" style="font-size:11px; opacity:.65;"></span>
                                </div>
                                <div id="backup-list-full" style="margin-top:6px; font-size:12px; line-height:1.25; max-height:260px; overflow:auto; border:1px solid #2d2f33; border-radius:4px; padding:6px; background:#1c1e22;">
                                    Loading backups...
                                </div>
            `;

            if (!maintenance.maintenanceMode) {
                html += `<button class="action-btn warning" onclick="toggleMaintenanceMode(true)">Enable Maintenance Mode</button>`;
            } else {
                html += `<button class="action-btn" onclick="toggleMaintenanceMode(false)">Disable Maintenance Mode</button>`;
            }

            document.getElementById('maintenance-control').innerHTML = html;

            // Async load & render full backup list (separate from restore dropdown)
            (async () => {
                const container = document.getElementById('backup-list-full');
                if(!container) return;
                try {
                    const res = await fetch('/api/admin/maintenance/backups');
                    if(!res.ok) throw new Error('request failed');
                    const data = await res.json();
                    const backups = Array.isArray(data.backups) ? data.backups : [];
                    if(backups.length === 0){
                        container.innerHTML = '<div style="opacity:0.6;">(no backups)</div>';
                        return;
                    }
                    // Helper to format size
                    const fmtSize = (n) => {
                        if(!n) return '0 B';
                        const units = ['B','KB','MB','GB'];
                        let u=0, v=n;
                        while(v >= 1024 && u < units.length-1){ v/=1024; u++; }
                        return v.toFixed(v>=100||u===0?0:1)+' '+units[u];
                    };
                    let table = '<table id="backup-table" style="width:100%; border-collapse:collapse; font-size:11px;">';
                    table += '<thead><tr style="text-align:left; background:#25272b;"><th style="padding:4px;">ID</th><th style="padding:4px;">Created</th><th style="padding:4px;">Files</th><th style="padding:4px;">Size</th><th style="padding:4px;">Schema</th></tr></thead><tbody>';
                    backups.forEach(b => {
                        const created = b.createdAt ? new Date(b.createdAt).toLocaleString() : '‚Äî';
                        table += `<tr data-backup-id="${b.id}" style="cursor:pointer; border-top:1px solid #2d2f33;">
                            <td style="padding:4px; white-space:nowrap;">${b.id}</td>
                            <td style="padding:4px; white-space:nowrap;">${created}</td>
                            <td style="padding:4px;">${b.instructionCount ?? 0}</td>
                            <td style="padding:4px;">${fmtSize(b.sizeBytes||0)}</td>
                            <td style="padding:4px;">${b.schemaVersion || '‚Äî'}</td>
                        </tr>`;
                    });
                    table += '</tbody></table>';
                    table += '<div style="margin-top:4px; opacity:0.55;">Click a row to select it for restore. Use filter box to narrow results.</div>';
                    container.innerHTML = table;
                    // Row click -> select in restore dropdown (if present)
                    container.querySelectorAll('tr[data-backup-id]').forEach(row => {
                        row.addEventListener('click', () => {
                            const id = row.getAttribute('data-backup-id');
                            const sel = document.getElementById('backup-select');
                            if(sel){ sel.value = id; }
                            // simple highlight
                            container.querySelectorAll('tr[data-backup-id]').forEach(r => r.style.background='');
                            row.style.background = '#2a3038';
                            window.__lastSelectedBackupId = id;
                        });
                    });
                    window.__allBackupRows = backups.map(b => ({ id: b.id, schema: b.schemaVersion || '', created: b.createdAt, count: b.instructionCount }));
                    updateBackupFilterCount();
                } catch(err){
                    container.innerHTML = '<div style="color:#e74c3c;">Error loading backups</div>';
                }
            })();
        }

        function selectLatestBackup(){
            const table = document.getElementById('backup-table');
            if(!table) return;
            const first = table.querySelector('tbody tr[data-backup-id]');
            if(first){ first.click(); }
        }

        async function deleteSelectedBackup(){
            const sel = document.getElementById('backup-select');
            const id = (sel && sel.value) || window.__lastSelectedBackupId;
            if(!id){ alert('Select a backup first'); return; }
            if(!confirm(`Delete backup ${id}? This cannot be undone.`)) return;
            try {
                const res = await fetch(`/api/admin/maintenance/backup/${encodeURIComponent(id)}`, { method:'DELETE' });
                const data = await res.json();
                if(data.success){ showSuccess(`Deleted ${id}`); loadMaintenanceStatus(); loadBackups(); }
                else { showError(data.error || 'Delete failed'); }
            } catch(e){ showError('Delete failed'); }
        }

        function promptPruneBackups(){
            const retainStr = prompt('Retain how many newest backups? (0 = delete all)', '10');
            if(retainStr == null) return;
            const retain = parseInt(retainStr,10);
            if(isNaN(retain) || retain < 0){ alert('Enter a non-negative number'); return; }
            pruneBackups(retain);
        }

        async function pruneBackups(retain){
            try {
                const res = await fetch('/api/admin/maintenance/backups/prune', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ retain })});
                const data = await res.json();
                if(data.success){ showSuccess(data.message || 'Pruned'); loadMaintenanceStatus(); loadBackups(); }
                else { showError(data.error || 'Prune failed'); }
            } catch(e){ showError('Prune failed'); }
        }

        function filterBackupRows(){
            const q = (document.getElementById('backup-search')||{value:''}).value.trim().toLowerCase();
            const table = document.getElementById('backup-table');
            if(!table){ return; }
            let visible = 0, total = 0;
            table.querySelectorAll('tbody tr[data-backup-id]').forEach(tr => {
                total++;
                const id = tr.getAttribute('data-backup-id') || '';
                const schema = (tr.cells[4]?.textContent||'');
                const match = !q || id.toLowerCase().includes(q) || schema.toLowerCase().includes(q);
                tr.style.display = match ? '' : 'none';
                if(match) visible++;
            });
            updateBackupFilterCount(visible, total);
        }

        function updateBackupFilterCount(visible, total){
            const el = document.getElementById('backup-filter-count');
            if(!el) return;
            if(visible == null || total == null){
                // initial derive if table present
                const table = document.getElementById('backup-table');
                if(!table){ el.textContent=''; return; }
                const rows = table.querySelectorAll('tbody tr[data-backup-id]');
                total = rows.length; visible = Array.from(rows).filter(r=>r.style.display!=='none').length;
            }
            el.textContent = `${visible}/${total}`;
        }

        async function toggleMaintenanceMode(enable) {
            try {
                const response = await fetch('/api/admin/maintenance/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        enabled: enable, 
                        message: enable ? 'Admin panel maintenance' : undefined 
                    })
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(data.message);
                    loadMaintenanceStatus();
                } else {
                    showError('Failed to toggle maintenance mode');
                }
            } catch (error) {
                console.error('Error toggling maintenance mode:', error);
                showError('Failed to toggle maintenance mode');
            }
        }

        async function performBackup() {
            try {
                showSuccess('Backup started...');
                const response = await fetch('/api/admin/maintenance/backup', {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(`Backup completed: ${data.backupId}`);
                    loadMaintenanceStatus();
                } else {
                    showError('Backup failed');
                }
            } catch (error) {
                console.error('Error performing backup:', error);
                showError('Backup failed');
            }
        }

        async function clearCaches() {
            try {
                const response = await fetch('/api/admin/cache/clear', {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(`Caches cleared: ${data.cleared.join(', ')}`);
                } else {
                    showError('Failed to clear caches');
                }
            } catch (error) {
                console.error('Error clearing caches:', error);
                showError('Failed to clear caches');
            }
        }

        async function restartServer() {
            if (!confirm('Are you sure you want to restart the server? This may temporarily interrupt service.')) {
                return;
            }

            try {
                showSuccess('Server restart initiated...');
                const response = await fetch('/api/admin/restart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ component: 'all' })
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(data.message);
                } else {
                    showError('Server restart failed');
                }
            } catch (error) {
                console.error('Error restarting server:', error);
                showError('Server restart failed');
            }
        }

                async function loadConfiguration() {
                        try {
                                const res = await fetch('/api/admin/config');
                                const data = await res.json();
                                if (!data.success) throw new Error('Failed to load config');
                                const cfg = data.config;
                                const flags = data.featureFlags || {};
                                const flagKeys = Object.keys(flags).sort();
                                const flagsHtml = flagKeys.length ? flagKeys.map(k=>`<div class="form-group" style="display:flex;align-items:center;gap:12px;">
                                    <label class="form-label" style="flex:1;">${k}</label>
                                    <select class="form-input" data-flag="${k}" style="max-width:160px;">
                                        <option value="1" ${flags[k]?'selected':''}>Enabled</option>
                                        <option value="0" ${!flags[k]?'selected':''}>Disabled</option>
                                    </select>
                                </div>`).join('') : '<div style="opacity:0.7;">No feature flags detected</div>';
                                const html = `
                                    <form onsubmit="return updateConfiguration(event)">
                                        <div class="form-group">
                                            <label class="form-label">Max Connections</label>
                                            <input class="form-input" type="number" id="cfg-maxConnections" value="${cfg.serverSettings.maxConnections}" />
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Request Timeout (ms)</label>
                                            <input class="form-input" type="number" id="cfg-requestTimeout" value="${cfg.serverSettings.requestTimeout}" />
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Verbose Logging</label>
                                            <select class="form-input" id="cfg-verbose"> <option value="1" ${cfg.serverSettings.enableVerboseLogging ? 'selected':''}>Enabled</option><option value="0" ${!cfg.serverSettings.enableVerboseLogging ? 'selected':''}>Disabled</option></select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Enable Mutation</label>
                                            <select class="form-input" id="cfg-mutation"> <option value="1" ${cfg.serverSettings.enableMutation ? 'selected':''}>Enabled</option><option value="0" ${!cfg.serverSettings.enableMutation ? 'selected':''}>Disabled</option></select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Rate Limit Window (ms)</label>
                                            <input class="form-input" type="number" id="cfg-windowMs" value="${cfg.serverSettings.rateLimit.windowMs}" />
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Rate Limit Max Requests</label>
                                            <input class="form-input" type="number" id="cfg-maxRequests" value="${cfg.serverSettings.rateLimit.maxRequests}" />
                                        </div>
                                        <div style="margin-top:10px;">
                                            <button class="action-btn" type="submit">üíæ Save Config</button>
                                        </div>
                                    </form>
                                    <hr/>
                                    <h3 style="margin-top:10px;">Feature Flags</h3>
                                    <div>${flagsHtml}</div>`;
                                document.getElementById('config-form').innerHTML = html;
                        } catch (e) {
                                document.getElementById('config-form').innerHTML = '<div class="error">Failed to load configuration</div>';
                        }
                }

        async function updateConfiguration(ev) {
            ev.preventDefault();
            const flagSelects = document.querySelectorAll('[data-flag]');
            const featureFlags = {};
                        flagSelects.forEach(function(sel){ featureFlags[sel.getAttribute('data-flag')] = sel.value === '1'; });
            const updates = {
                serverSettings: {
                    maxConnections: parseInt(document.getElementById('cfg-maxConnections').value),
                    requestTimeout: parseInt(document.getElementById('cfg-requestTimeout').value),
                    enableVerboseLogging: document.getElementById('cfg-verbose').value === '1',
                    enableMutation: document.getElementById('cfg-mutation').value === '1',
                    rateLimit: {
                        windowMs: parseInt(document.getElementById('cfg-windowMs').value),
                        maxRequests: parseInt(document.getElementById('cfg-maxRequests').value)
                    }
                },
                featureFlags
            };
                        try {
                                const res = await fetch('/api/admin/config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(updates)});
                                const data = await res.json();
                                if (data.success) { showSuccess('Configuration updated'); loadConfiguration(); } else { showError(data.error || 'Update failed'); }
                        } catch (e) { showError('Update failed'); }
                        return false;
                }

        async function loadMonitoringData() {
            try {
                const [perfRes, sysRes, alertsRes] = await Promise.all([
                    fetch('/api/performance/detailed').catch(e=>e),
                    fetch('/api/system/health').catch(e=>e),
                    fetch('/api/alerts/active').catch(e=>e)
                ]);
                const [perfData, sysData, alertsData] = await Promise.all([
                    perfRes?.json ? perfRes.json().catch(()=>({})) : {},
                    sysRes?.json ? sysRes.json().catch(()=>({})) : {},
                    alertsRes?.json ? alertsRes.json().catch(()=>({})) : {}
                ]);
                const perf = perfData.data || {};
                const sys = sysData.data || {};
                const alerts = (alertsData.data || []).slice(0,5);
                const html = `
                  <div class="stat-row"><span class="stat-label">Throughput (rpm)</span><span class="stat-value">${perf.requestThroughput ?? '‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">Avg Response</span><span class="stat-value">${perf.averageResponseTime?.toFixed ? perf.averageResponseTime.toFixed(1)+'ms':'‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">P95</span><span class="stat-value">${perf.p95ResponseTime ?? '‚Äî'}ms</span></div>
                  <div class="stat-row"><span class="stat-label">Error Rate</span><span class="stat-value">${perf.errorRate?.toFixed ? perf.errorRate.toFixed(2)+'%':'‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">Active Connections</span><span class="stat-value">${perf.concurrentConnections ?? '‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">System Health</span><span class="stat-value">${sys.status || '‚Äî'}</span></div>
                  <div style="margin-top:10px;">
                    <strong>Active Alerts (${alerts.length})</strong>
                    <ul style="margin-left:20px;">${alerts.map(a=>`<li>${a.type} (${a.severity}) - ${a.message}</li>`).join('') || '<li>No active alerts</li>'}</ul>
                  </div>`;
                document.getElementById('monitoring-data').innerHTML = html;
                                // Update nav badge if sessions already loaded
                                updateSessionsNavBadge();
            } catch (e) {
                document.getElementById('monitoring-data').innerHTML = '<div class="error">Failed to load monitoring data</div>';
            }
        }

                // Periodic refresh when Monitoring tab visible
                let monitoringInterval = null;
                function ensureMonitoringPoll(){
                    if (document.getElementById('monitoring-section')?.classList.contains('hidden')) return;
                    if (monitoringInterval) return; // already
                    monitoringInterval = setInterval(()=>{
                        if (document.getElementById('monitoring-section')?.classList.contains('hidden')) { clearInterval(monitoringInterval); monitoringInterval=null; return; }
                        loadMonitoringData();
                    }, 5000);
                }

        // ===== Log Viewer =====
        let logEventSource = null;
        let logTailing = false;

    async function loadLogs() {
            try {
                const lines = document.getElementById('log-lines').value || 100;
                // Prefer JSON shape; fall back to raw if server older
                let logsArray = [];
                let rawMode = false;
                let response = await fetch(`/api/logs?lines=${lines}`);
                if (response.ok) {
                    const ct = response.headers.get('content-type') || '';
                    if (ct.includes('application/json')) {
                        try {
                            const data = await response.json();
                            if (Array.isArray(data.logs)) {
                                logsArray = data.logs;
                            } else if (typeof data === 'object') {
                                // attempt common legacy shape
                                logsArray = Object.values(data).filter(v=>typeof v === 'string');
                            }
                        } catch {
                            rawMode = true;
                        }
                    } else {
                        rawMode = true;
                    }
                }
                if (rawMode) {
                    // Re-fetch explicitly requesting raw text
                    response = await fetch(`/api/logs?lines=${lines}&raw=1`);
                    const txt = await response.text();
                    logsArray = txt.split(/\r?\n/);
                }
                const rendered = logsArray.join('\n');
                document.getElementById('log-content').innerHTML = `<pre>${escapeHtml(rendered)}</pre>`;
                
                // Auto-scroll to bottom if tailing
                if (logTailing) {
                    const logContent = document.getElementById('log-content');
                    logContent.scrollTop = logContent.scrollHeight;
                }
            } catch (error) {
                console.error('Failed to load logs:', error);
                document.getElementById('log-content').innerHTML = '<div class="error">Failed to load logs</div>';
            }
        }

        function toggleLogTail() {
            // ID in markup is log-tail-btn (previous mismatch prevented toggling)
            const button = document.getElementById('log-tail-btn');
            
            if (logTailing) {
                // Stop tailing
                if (logEventSource) {
                    logEventSource.close();
                    logEventSource = null;
                }
                logTailing = false;
                button.textContent = '‚ñ∂Ô∏è Start Tail';
                button.className = 'action-btn';
            } else {
                // Start tailing
                logTailing = true;
                button.textContent = '‚èπ Stop Tail';
                button.className = 'action-btn warning';
                
                // Start EventSource for real-time logs
                logEventSource = new EventSource('/api/logs/stream');
                
                logEventSource.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.line) {
                            const logContent = document.getElementById('log-content');
                            const pre = logContent.querySelector('pre') || document.createElement('pre');
                            
                            if (!logContent.querySelector('pre')) {
                                logContent.innerHTML = '';
                                logContent.appendChild(pre);
                            }
                            
                            pre.textContent += data.line + '\n';
                            
                            // Auto-scroll to bottom
                            logContent.scrollTop = logContent.scrollHeight;
                            
                            // Limit log display to prevent memory issues
                            const lines = pre.textContent.split('\n');
                            const maxLines = 2000;
                            if (lines.length > maxLines) {
                                pre.textContent = lines.slice(-maxLines).join('\n');
                            }
                        }
                    } catch (error) {
                        console.error('Error processing log stream:', error);
                    }
                };
                
                logEventSource.onerror = function(error) {
                    console.error('Log stream error:', error);
                    // Auto-reconnect on error
                    setTimeout(() => {
                        if (logTailing) {
                            toggleLogTail();
                            setTimeout(() => toggleLogTail(), 1000);
                        }
                    }, 2000);
                };
            }
        }

        function clearLogViewer() {
            document.getElementById('log-content').innerHTML = '<div class="info">Log viewer cleared</div>';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ===== Instruction Management =====
        let instructionEditing = null;
                // Pagination state
                let allInstructions = [];
                let instructionPage = 1;
                let instructionPageSize = 25; // default page size

                function getInstructionPageSizes() { return [10,25,50,100, 'All']; }

                function buildInstructionPaginationControls(totalFiltered) {
                        const container = document.getElementById('instruction-pagination');
                        if (!container) return;
                        const total = totalFiltered;
                        const pageSize = instructionPageSize === 'All' ? total : instructionPageSize;
                        const totalPages = pageSize === 0 ? 1 : Math.max(1, Math.ceil(total / pageSize));
                        if (instructionPage > totalPages) instructionPage = totalPages; // clamp

                        const disablePrev = instructionPage <= 1;
                        const disableNext = instructionPage >= totalPages;

                        const sizeOptions = getInstructionPageSizes().map(s => `<option value="${s}" ${s===instructionPageSize? 'selected':''}>${s}</option>`).join('');
                        container.innerHTML = `
                            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                                <label style="display:flex; align-items:center; gap:4px;">Page Size:
                                    <select id="instruction-page-size" class="form-input" style="width:auto; padding:4px;">${sizeOptions}</select>
                                </label>
                                <div style="display:flex; align-items:center; gap:4px;">
                                    <button class="action-btn" onclick="changeInstructionPage('first')" ${disablePrev?'disabled':''}>‚èÆ First</button>
                                    <button class="action-btn" onclick="changeInstructionPage('prev')" ${disablePrev?'disabled':''}>‚óÄ Prev</button>
                                    <span style="font-size:12px;">Page ${instructionPage} / ${totalPages}</span>
                                    <button class="action-btn" onclick="changeInstructionPage('next')" ${disableNext?'disabled':''}>Next ‚ñ∂</button>
                                    <button class="action-btn" onclick="changeInstructionPage('last')" ${disableNext?'disabled':''}>Last ‚è≠</button>
                                </div>
                                <span style="margin-left:auto; font-size:12px; opacity:0.8;">Filtered: ${total} total</span>
                            </div>`;
                        const sizeSelect = document.getElementById('instruction-page-size');
                        sizeSelect.onchange = () => {
                                instructionPageSize = sizeSelect.value === 'All' ? 'All' : parseInt(sizeSelect.value,10);
                                instructionPage = 1; // reset to first page when size changes
                                renderInstructionList(allInstructions);
                        };
                }

                function changeInstructionPage(dir) {
                        const totalFiltered = getFilteredInstructions(allInstructions).length;
                        const pageSizeVal = instructionPageSize === 'All' ? totalFiltered : instructionPageSize;
                        const totalPages = pageSizeVal === 0 ? 1 : Math.max(1, Math.ceil(totalFiltered / pageSizeVal));
                        if (dir === 'first') instructionPage = 1;
                        else if (dir === 'prev' && instructionPage > 1) instructionPage--;
                        else if (dir === 'next' && instructionPage < totalPages) instructionPage++;
                        else if (dir === 'last') instructionPage = totalPages;
                        renderInstructionList(allInstructions);
                }

                // Instruction filtering & sorting enhancements
                function getFilteredInstructions(list) {
                    const nameFilter = (document.getElementById('instruction-filter').value || '').toLowerCase();
                    const categoryFilter = (document.getElementById('instruction-category-filter')?.value || '');
                    const sizeFilter = (document.getElementById('instruction-size-filter')?.value || '');
                    let filtered = list.filter(i => i.name.toLowerCase().includes(nameFilter));
                    if (categoryFilter) {
                        filtered = filtered.filter(i => {
                            if (i.category === categoryFilter) return true;
                            if (Array.isArray(i.categories) && i.categories.includes(categoryFilter)) return true;
                            return false;
                        });
                    }
                    if (sizeFilter) filtered = filtered.filter(i => i.sizeCategory === sizeFilter);
                    const sortSelect = document.getElementById('instruction-sort');
                    const sortVal = sortSelect ? sortSelect.value : 'name-asc';
                    const cmp = (a,b, key, dir='asc') => {
                        if (a[key] === b[key]) return 0;
                        return (a[key] < b[key] ? -1 : 1) * (dir === 'asc' ? 1 : -1);
                    };
                    switch(sortVal) {
                        case 'name-desc': filtered.sort((a,b)=>cmp(a,b,'name','desc')); break;
                        case 'size-asc': filtered.sort((a,b)=>cmp(a,b,'size','asc')); break;
                        case 'size-desc': filtered.sort((a,b)=>cmp(a,b,'size','desc')); break;
                        case 'mtime-asc': filtered.sort((a,b)=>cmp(a,b,'mtime','asc')); break;
                        case 'mtime-desc': filtered.sort((a,b)=>cmp(a,b,'mtime','desc')); break;
                        case 'category': filtered.sort((a,b)=>cmp(a,b,'category','asc') || cmp(a,b,'name','asc')); break;
                        default: // name-asc
                            filtered.sort((a,b)=>cmp(a,b,'name','asc'));
                    }
                    return filtered;
                }

    /* Removed legacy duplicate loadInstructions; unified enhanced version defined later */

        async function loadInstructionCategories() {
            try {
                const res = await fetch('/api/instructions/categories');
                if(!res.ok) throw new Error('http '+res.status);
                const data = await res.json();
                // Accept shapes: {success:true,categories:[{name,count}]}, {success:true,data:{categories:[...]}}
                let cats = data.categories || data.data?.categories || [];
                if(Array.isArray(cats) && cats.length && typeof cats[0] === 'string') {
                    cats = cats.map(n=>({ name:n, count: undefined }));
                }
                if(!Array.isArray(cats)) cats = [];
                const select = document.getElementById('instruction-category-filter');
                if(select){
                    select.innerHTML = '<option value="">All Categories</option>';
                    cats.forEach(cat => {
                        if(!cat || !cat.name) return;
                        const option = document.createElement('option');
                        option.value = cat.name;
                        option.textContent = cat.count != null ? `${cat.name} (${cat.count})` : cat.name;
                        select.appendChild(option);
                    });
                }
                return cats.map(c=>c.name);
            } catch (e) {
                console.warn('Failed to load instruction categories:', e);
                return [];
            }
        }

        function renderInstructionList(instructions) {
                        const filtered = getFilteredInstructions(instructions);
            if (filtered.length === 0) {
                document.getElementById('instructions-list').innerHTML = '<p>No instructions found</p>';
                                buildInstructionPaginationControls(0);
                return;
            }
                        const totalFiltered = filtered.length;
                        let pageItems = filtered;
                        if (instructionPageSize !== 'All') {
                                const start = (instructionPage - 1) * instructionPageSize;
                                const end = start + instructionPageSize;
                                pageItems = filtered.slice(start, end);
                        }
                        const rows = pageItems.map(instr => {
                            const rawSummary = (instr.semanticSummary || '').trim();
                            let short = rawSummary.slice(0, 160);
                            if (rawSummary.length > 160) short += '‚Ä¶';
                            const safeSummary = escapeHtml(short);
                            return `
                <div class="session-item" style="background:#fff;">
                    <div class="session-header">
                        <span class="session-id" style="background:#dfe6f1;">${instr.name}</span>
                        <div>
                           <button class="action-btn" onclick="editInstruction('${instr.name}')">‚úè Edit</button>
                           <button class="action-btn danger" onclick="deleteInstruction('${instr.name}')">üóë Delete</button>
                        </div>
                    </div>
                    <div class="stat-row"><span class="stat-label">Category</span><span class="stat-value">${instr.category || '‚Äî'}</span></div>
                    <div class="stat-row"><span class="stat-label">Size</span><span class="stat-value">${instr.size} bytes (${instr.sizeCategory})</span></div>
                    <div class="stat-row"><span class="stat-label">Modified</span><span class="stat-value">${new Date(instr.mtime).toLocaleString()}</span></div>
                    <div class="stat-row" style="align-items:flex-start;">
                        <span class="stat-label" style="padding-top:2px;">Summary</span>
                        <span class="stat-value" style="font-weight:400; white-space:normal; line-height:1.3; max-width:520px;">
                            ${safeSummary || '<span style=\"opacity:.5;\">‚Äî</span>'}
                        </span>
                    </div>
                </div>`;
                        }).join('');
            document.getElementById('instructions-list').innerHTML = rows;
                        buildInstructionPaginationControls(totalFiltered);
        }

        function filterInstructions() {
                        instructionPage = 1; // reset to first page on filter change
                        renderInstructionList(allInstructions);
        }

        function showCreateInstruction() {
            instructionEditing = null;
            document.getElementById('instruction-editor-title').textContent = 'New Instruction';
            document.getElementById('instruction-filename').value = '';
            document.getElementById('instruction-filename').disabled = false;
            document.getElementById('instruction-content').value = '{\n  "description": "New instruction"\n}';
            ensureInstructionEditorAtTop();
            const ed = document.getElementById('instruction-editor');
            ed.classList.remove('hidden');
            // Smooth scroll to make editor visible at top
            try { ed.scrollIntoView({ behavior:'smooth', block:'start' }); } catch {}
            document.getElementById('instruction-filename').focus();
            instructionOriginalContent = document.getElementById('instruction-content').value;
            updateInstructionEditorDiagnostics();
        }

        async function editInstruction(name) {
            const editor = document.getElementById('instruction-editor');
            const filenameEl = document.getElementById('instruction-filename');
            const contentEl = document.getElementById('instruction-content');
            let attempts = 0;
            const maxAttempts = 2; // one retry after initial attempt
            let lastError;
            while (attempts < maxAttempts) {
                try {
                    attempts++;
                    // lightweight loading indicator
                    if (contentEl && attempts === 1) {
                        contentEl.value = '// Loading ' + name + '...';
                    }
                    const res = await fetch('/api/instructions/' + encodeURIComponent(name));
                    if (!res.ok) throw new Error('http ' + res.status);
                    const data = await res.json();
                    if (data.success === false && !data.content && !data.data?.content) throw new Error('server reported failure');
                    if (!data.content && data.data?.content) data.content = data.data.content;
                    if (!data.content) throw new Error('missing content');
                    instructionEditing = name;
                    document.getElementById('instruction-editor-title').textContent = 'Edit Instruction: ' + name;
                    filenameEl.value = name;
                    filenameEl.disabled = true;
                    const pretty = JSON.stringify(data.content, null, 2);
                    contentEl.value = pretty;
                    ensureInstructionEditorAtTop();
                    editor.classList.remove('hidden');
                    try { editor.scrollIntoView({ behavior:'smooth', block:'start' }); } catch {}
                    instructionOriginalContent = pretty;
                    updateInstructionEditorDiagnostics();
                    return; // success
                } catch (e) {
                    lastError = e;
                    // brief delay before retry to allow file system settle or server warm path
                    if (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 120));
                        continue;
                    }
                }
            }
            console.warn('editInstruction failed after retries', lastError);
            showError('Failed to load instruction');
        }

        function cancelEditInstruction() {
            document.getElementById('instruction-editor').classList.add('hidden');
            const diff = document.getElementById('instruction-diff-container');
            if(diff) diff.classList.add('hidden');
            instructionOriginalContent='';
        }

        // Reposition editor just below the toolbar (before the instruction list) when activated
        function ensureInstructionEditorAtTop(){
            try {
                const editor = document.getElementById('instruction-editor');
                const list = document.getElementById('instructions-list');
                if(!editor || !list) return;
                const parent = list.parentElement; // card body
                // The toolbar is the element immediately before instructions-list (with buttons + filters)
                if(parent && parent.contains(list)){
                    // Insert editor right BEFORE instructions-list so it appears at top
                    if(editor.nextElementSibling !== list){
                        parent.insertBefore(editor, list);
                    }
                }
            } catch {/* ignore */}
        }

        // --- Instruction Editor Helpers (added patch) ---
        let instructionOriginalContent = '';
        let instructionDiffVisible = false;

        function safeParseInstruction(raw){
            try { return JSON.parse(raw); } catch { return null; }
        }

        function updateInstructionEditorDiagnostics(){
            const ta = document.getElementById('instruction-content');
            const diag = document.getElementById('instruction-diagnostics');
            if(!ta||!diag) return;
            const raw = ta.value;
            if(!raw.trim()){ diag.innerHTML = '<em>Empty.</em>'; return; }
            const parsed = safeParseInstruction(raw);
            if(!parsed){
                diag.innerHTML = '<span style="color:#c0392b;">Invalid JSON</span>'; 
            } else {
                const size = raw.length;
                const cats = Array.isArray(parsed.categories)? parsed.categories.length : 0;
                const schemaVer = parsed.schemaVersion || parsed.schema || '?';
                const changed = instructionOriginalContent && raw !== instructionOriginalContent;
                diag.innerHTML = `Size: ${size} chars ‚Ä¢ Categories: ${cats} ‚Ä¢ Schema: ${schemaVer} ${changed?'<span style="color:#f39c12;">(modified)</span>':''}`;
            }
            if(instructionDiffVisible) refreshInstructionDiff();
        }

        function refreshInstructionDiff(){
            const diffWrap = document.getElementById('instruction-diff-container');
            const diffPre = document.getElementById('instruction-diff');
            const ta = document.getElementById('instruction-content');
            if(!diffWrap||!diffPre||!ta) return;
            if(!instructionOriginalContent){ diffPre.textContent='(no baseline)'; return; }
            if(ta.value === instructionOriginalContent){ diffPre.textContent='(no changes)'; return; }
            // Simple line diff (not optimal but lightweight)
            const before = instructionOriginalContent.split(/\r?\n/);
            const after = ta.value.split(/\r?\n/);
            const max = Math.max(before.length, after.length);
            const out = [];
            for(let i=0;i<max;i++){
                const a = before[i];
                const b = after[i];
                if(a === b){
                    if(a !== undefined) out.push('  ' + a);
                } else {
                    if(a !== undefined) out.push('- ' + a);
                    if(b !== undefined) out.push('+ ' + b);
                }
            }
            diffPre.textContent = out.join('\n');
        }

        function toggleInstructionDiff(){
            instructionDiffVisible = !instructionDiffVisible;
            const wrap = document.getElementById('instruction-diff-container');
            if(!wrap) return; 
            if(instructionDiffVisible){
                wrap.classList.remove('hidden');
                refreshInstructionDiff();
            } else {
                wrap.classList.add('hidden');
            }
        }

        async function saveInstruction(){
            const nameEl = document.getElementById('instruction-filename');
            const ta = document.getElementById('instruction-content');
            if(!nameEl||!ta) return;
            const raw = ta.value;
            const parsed = safeParseInstruction(raw);
            if(!parsed){ showError('Cannot save: invalid JSON'); return; }
            // Auto-upgrade template schemaVersion if legacy 1.x
            if(parsed && parsed.schemaVersion && /^1(\.|$)/.test(String(parsed.schemaVersion))){
                parsed.schemaVersion = '2';
            }
            const body = { content: parsed };
            let url = '/api/instructions';
            let method = 'POST';
            if(instructionEditing){
                url += '/' + encodeURIComponent(instructionEditing);
                method = 'PUT';
            } else {
                body.name = nameEl.value.trim();
                if(!body.name){ showError('Provide file name'); return; }
            }
            try {
                const res = await fetch(url, { method, headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                const data = await res.json();
                if(!res.ok || !data.success){ throw new Error(data.error || data.message || 'Save failed'); }
                showSuccess(instructionEditing? 'Instruction updated':'Instruction created');
                instructionOriginalContent = JSON.stringify(parsed, null, 2);
                ta.value = instructionOriginalContent; // normalized pretty
                if(!instructionEditing) instructionEditing = body.name;
                updateInstructionEditorDiagnostics();
                loadInstructions();
            } catch(e){ showError(e.message || 'Save failed'); }
        }

        async function loadInstructions() {
            const listEl = document.getElementById('instructions-list');
            listEl.innerHTML = 'Loading...';
            try {
                // Load categories first to populate the dropdown (ignore errors; we'll derive later if needed)
                const catNames = await loadInstructionCategories();
                const res = await fetch('/api/instructions');
                if(!res.ok) throw new Error('http '+res.status);
                const data = await res.json();
                // Accept shapes: {success:true,instructions:[...]}, {data:{instructions:[...]}}, or legacy {instructions:[...]}
                if (!('success' in data) && !('data' in data) && !('instructions' in data)) throw new Error('unrecognized instructions payload');
                const rawList = data.instructions || data.data?.instructions || [];
                allInstructions = Array.isArray(rawList) ? rawList : [];
                try { console.log('[dashboard] fetched instructions:', allInstructions.length); } catch {}
                // If categories endpoint failed / returned empty, derive from instruction list
                if(!catNames.length) {
                    try {
                        const select = document.getElementById('instruction-category-filter');
                        if(select){
                            const derived = Array.from(new Set(allInstructions.flatMap(i=> [i.category, ...(Array.isArray(i.categories)? i.categories: [])]).filter(Boolean))).sort();
                            derived.forEach(n=>{
                                const opt = document.createElement('option');
                                opt.value = n; opt.textContent = n; select.appendChild(opt);
                            });
                        }
                    } catch(_) { /* ignore */ }
                }
                instructionPage = 1; // reset page whenever we reload
                renderInstructionList(allInstructions);
            } catch (e) {
                console.warn('loadInstructions error', e);
                listEl.innerHTML = '<div class="error">Failed to load instructions</div>';
            }
        }
        
            // Re-introduced after patch: formatInstructionJson utility (was accidentally truncated)
            function formatInstructionJson(){
                const ta = document.getElementById('instruction-content');
                if(!ta) return;
                try {
                    const parsed = JSON.parse(ta.value);
                    ta.value = JSON.stringify(parsed, null, 2);
                    updateInstructionEditorDiagnostics();
                } catch { showError('Cannot format: invalid JSON'); }
            }

        function applyInstructionTemplate(){
            const ta = document.getElementById('instruction-content');
            if(!ta) return;
            // Preserve user edits unless they confirm replacement
            if(ta.value.trim() && !confirm('Replace current content with template?')) return;
            const now = new Date().toISOString();
            const template = {
                id: 'sample-instruction',
                title: 'Sample Instruction',
                body: 'Detailed instruction content here.\nAdd multi-line guidance and steps.',
                priority: 50,
                audience: 'all',
                requirement: 'optional',
                categories: ['general'],
                primaryCategory: 'general',
                reviewIntervalDays: 180,
                schemaVersion: '3',
                description: 'Describe purpose and scope.',
                meta: {
                    category: 'general',
                    categories: ['general'],
                    semanticSummary: 'Sample scaffold for new instruction schema v2.'
                },
                owner: 'you@example.com',
                tags: ['sample','template'],
                governance: { version: 1 },
                metadata: { createdBy: 'admin-ui', createdAt: now, updatedAt: now }
            };
            ta.value = JSON.stringify(template, null, 2);
            updateInstructionEditorDiagnostics();
        }

        // ===== Resource Trend (CPU/Mem) Long-Term History (merged into Performance card) =====
        (function initResourceTrendMerge(){
            async function fetchResourceTrends(){
                try {
                    const res = await fetch('/api/system/resources?limit=300');
                    if(!res.ok) throw new Error('http '+res.status);
                    const json = await res.json();
                    const samples = json?.data?.samples || [];
                    const trend = json?.data?.trend || { cpuSlope:0, memSlope:0 };
                    if(samples.length === 0){
                        window.__resourceTrendCache = { windowSec:0, sampleCount:0, latestCpu:0, latestHeap:0, cpuSlope:0, memSlope:0, spark:'' };
                        // trigger re-render next stats update
                        return;
                    }
                    const latest = samples[samples.length-1];
                    const first = samples[0];
                    const durationSec = ((latest.timestamp - first.timestamp)/1000).toFixed(0);
                    const tail = samples.slice(-40);
                    const spark = tail.map(s=>{
                        const v = Math.min(100, Math.max(0, s.cpuPercent));
                        const idx = Math.round(v/12.5);
                        const blocks = ['‚ñÅ','‚ñÇ','‚ñÉ','‚ñÑ','‚ñÖ','‚ñÜ','‚ñá','‚ñà'];
                        return blocks[Math.min(blocks.length-1, idx)];
                    }).join('');
                    const minCpu = tail.reduce((m,s)=> s.cpuPercent<m? s.cpuPercent:m, tail[0].cpuPercent);
                    const maxCpu = tail.reduce((m,s)=> s.cpuPercent>m? s.cpuPercent:m, tail[0].cpuPercent);
                    // Memory spark (scale heap delta relative to max in window)
                    const maxHeap = tail.reduce((m,s)=> s.heapUsed>m?s.heapUsed:m,0) || 1;
                    const minHeap = tail.reduce((m,s)=> s.heapUsed<m?s.heapUsed:m, tail[0].heapUsed);
                    const memSpark = tail.map(s=>{
                        const ratio = Math.min(1, Math.max(0, s.heapUsed / maxHeap));
                        const idx = Math.round(ratio*7);
                        const blocks = ['‚ñÅ','‚ñÇ','‚ñÉ','‚ñÑ','‚ñÖ','‚ñÜ','‚ñá','‚ñà'];
                        return blocks[Math.min(blocks.length-1, idx)];
                    }).join('');
                    window.__resourceTrendCache = {
                        windowSec: durationSec,
                        sampleCount: samples.length,
                        latestCpu: latest.cpuPercent,
                        latestHeap: latest.heapUsed,
                        minCpu,
                        maxCpu,
                        minHeap,
                        maxHeap,
                        cpuSlope: trend.cpuSlope || 0,
                        memSlope: trend.memSlope || 0,
                        spark,
                        memSpark
                    };
                    // Re-render performance card if stats already loaded
                    try {
                        if(typeof window.lastSystemStats === 'object') displaySystemStats(window.lastSystemStats);
                        if(typeof window.lastSystemHealth === 'object') displaySystemHealth(window.lastSystemHealth);
                    } catch(e){/*ignore*/}
                } catch(e){
                    // ignore failures; card will just show base stats
                }
            }
            // periodic fetch
            fetchResourceTrends();
            setInterval(fetchResourceTrends, 10000);
        })();

        async function deleteInstruction(name) {
            if (!confirm('Delete instruction ' + name + '?')) return;
            try {
                const res = await fetch('/api/instructions/' + encodeURIComponent(name), { method:'DELETE' });
                const data = await res.json();
                if (data.success) { showSuccess('Deleted'); loadInstructions(); } else { showError(data.error || 'Delete failed'); }
            } catch { showError('Delete failed'); }
        }

        function startAutoRefresh() {
            refreshInterval = setInterval(() => {
                if (currentSection === 'overview') {
                    loadOverviewData();
                } else if (currentSection === 'sessions') {
                    loadSessions();
                } else if (currentSection === 'maintenance') {
                    loadMaintenanceStatus();
                }
            }, 30000); // Refresh every 30 seconds
    }
    // Build metadata loader
    (async function fetchBuildMeta(){
            try {
        // Cache bust query param to avoid any intermediary caching of status response
        const r = await fetch('/api/status?t=' + Date.now());
                const j = await r.json();
                const el = document.getElementById('buildMeta');
                const ver = j.version || '?.?.?';
                const commit = j.build ? `<span class=\"build-badge\">${j.build}</span>` : '';
                const bt = j.buildTime ? new Date(j.buildTime).toLocaleString() : 'unknown';
                el.innerHTML = `Version <strong>${ver}</strong> ${commit} ‚Ä¢ Built ${bt}`;
            } catch { const el = document.getElementById('buildMeta'); if(el) el.textContent='Build metadata unavailable'; }
        })();

        function showError(message) {
            // Remove existing notifications
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.admin-container').insertBefore(errorDiv, document.querySelector('.admin-container').firstChild.nextSibling);
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            // Remove existing notifications
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
            
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.admin-container').insertBefore(successDiv, document.querySelector('.admin-container').firstChild.nextSibling);
            
            setTimeout(() => successDiv.remove(), 5000);
        }

        // Utility functions
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (days > 0) return `${days}d ${hours}h ${minutes}m`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }

        function formatBytes(bytes) {
            const sizes = ['B', 'KB', 'MB', 'GB'];
            if (bytes === 0) return '0 B';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
        }
        function escapeHtml(str) {
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
    </script>
</body>
</html>
