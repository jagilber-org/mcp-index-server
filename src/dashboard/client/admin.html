<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Index Server Admin - MCP Index Server</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .admin-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .admin-header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .admin-header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .admin-nav {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .nav-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .nav-btn.active {
            background: linear-gradient(45deg, #764ba2, #667eea);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .admin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .admin-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .admin-card:hover {
            transform: translateY(-5px);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .card-icon {
            font-size: 1.5rem;
            margin-right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 500;
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }

        .status-healthy { background: #2ecc71; }
        .status-warning { background: #f39c12; }
        .status-critical { background: #e74c3c; }
    /* Treat failed same visual as critical but distinct semantic label */
    .status-failed { background: #e74c3c; }

        .action-btn {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .action-btn.danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .action-btn.warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .maintenance-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 600;
        }

        .maintenance-enabled {
            background: #ffe6e6;
            color: #c0392b;
            border: 2px solid #e74c3c;
        }

        .maintenance-disabled {
            background: #e6ffe6;
            color: #27ae60;
            border: 2px solid #2ecc71;
        }

        .config-form {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .form-input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .sessions-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .session-item {
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #f8f9fa;
        }

        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-id {
            font-family: monospace;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background: #ffe6e6;
            color: #c0392b;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #e74c3c;
        }

        .success {
            background: #e6ffe6;
            color: #27ae60;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #2ecc71;
        }

        @media (max-width: 768px) {
            .admin-nav {
                flex-direction: column;
                align-items: center;
            }
            
            .admin-grid {
                grid-template-columns: 1fr;
            }
            
            .nav-btn {
                width: 200px;
            }
        }
    .build-meta { margin-top:10px; font-size:0.85rem; color:#444; }
    .build-badge { display:inline-block; background:#222; color:#fff; padding:2px 6px; border-radius:10px; font-size:0.65rem; margin-left:6px; letter-spacing:0.5px; }
    
        /* Tool Metrics Styles */
        .tool-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .tool-metric-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: box-shadow 0.2s ease;
        }

        .tool-metric-card:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .tool-name {
            font-weight: 600;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }

        .tool-stats .stat-row {
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .tool-stats .stat-row:last-child {
            border-bottom: none;
        }

        .tool-stats .stat-label {
            font-size: 12px;
            color: #6c757d;
        }

        .tool-stats .stat-value {
            font-size: 12px;
            font-weight: 600;
        }

        .tool-stats .stat-value.small {
            font-size: 10px;
            color: #6c757d;
        }

        .tool-stats .stat-value.warning {
            color: #f39c12;
        }

        .tool-stats .stat-value.error {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <div class="admin-header">
            <h1>üõ°Ô∏è MCP Index Server Admin</h1>
            <div id="buildMeta" class="build-meta">Loading build metadata‚Ä¶</div>
            <div class="admin-nav">
                <button class="nav-btn active" onclick="showSection('overview')">üìä Overview</button>
                <button class="nav-btn" onclick="showSection('config')">‚öôÔ∏è Configuration</button>
                <button id="nav-sessions" class="nav-btn" onclick="showSection('sessions')">üë• Sessions</button>
                <button class="nav-btn" onclick="showSection('maintenance')">üîß Maintenance</button>
                <button class="nav-btn" onclick="showSection('monitoring')">üìà Monitoring</button>
                <button class="nav-btn" onclick="showSection('instructions')">üìö Instructions</button>
            </div>
        </div>

        <!-- Overview Section -->
        <div id="overview-section" class="admin-section">
            <div class="admin-grid">
                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üìä</div>
                        <div class="card-title">System Statistics</div>
                    </div>
                    <div id="system-stats" class="loading">Loading system statistics...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üíö</div>
                        <div class="card-title">System Health</div>
                    </div>
                    <div id="system-health" class="loading">Loading system health...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">‚ö°</div>
                        <div class="card-title">Performance</div>
                    </div>
                    <div id="performance-stats" class="loading">Loading performance data...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üìö</div>
                        <div class="card-title">Catalog Status</div>
                    </div>
                    <div id="catalog-stats" class="loading">Loading catalog information...</div>
                </div>
            </div>
            
            <!-- Individual Tool Metrics -->
            <div class="admin-card" style="margin-top: 30px;">
                <div class="card-header">
                    <div class="card-icon">üîß</div>
                    <div class="card-title">Individual Tool Call Metrics</div>
                </div>
                <div id="tool-metrics" class="loading">Loading tool metrics...</div>
            </div>
        </div>

        <!-- Configuration Section -->
        <div id="config-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">‚öôÔ∏è</div>
                    <div class="card-title">Server Configuration</div>
                </div>
                <div id="config-form" class="loading">Loading configuration...</div>
            </div>
        </div>

        <!-- Sessions Section -->
        <div id="sessions-section" class="admin-section hidden">
            <div class="admin-grid" style="grid-template-columns:1fr;">
                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üë•</div>
                        <div class="card-title">Active Admin Sessions</div>
                    </div>
                    <div id="sessions-list" class="loading">Loading sessions...</div>
                    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                        <button class="action-btn" onclick="createTestSession()">Create Test Session</button>
                        <button class="action-btn" onclick="loadSessions()">üîÑ Refresh</button>
                    </div>
                </div>
                <div class="admin-card" style="margin-top:20px;">
                    <div class="card-header">
                        <div class="card-icon">üîå</div>
                        <div class="card-title">Active WebSocket Connections</div>
                    </div>
                    <div id="connections-list" class="loading">Loading connections...</div>
                </div>
                <div class="admin-card" style="margin-top:20px;">
                    <div class="card-header">
                        <div class="card-icon">üóÇÔ∏è</div>
                        <div class="card-title">Session History</div>
                    </div>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
                        <label style="font-size:12px;">Limit
                            <select id="session-history-limit" class="form-input" style="width:80px; padding:4px;" onchange="refreshSessionHistory()">
                                <option value="25">25</option>
                                <option value="50" selected>50</option>
                                <option value="100">100</option>
                                <option value="250">250</option>
                            </select>
                        </label>
                        <button class="action-btn" onclick="refreshSessionHistory()">üîÑ Refresh History</button>
                    </div>
                    <div id="session-history-list" class="loading">History not loaded...</div>
                </div>
            </div>
        </div>

        <!-- Maintenance Section -->
        <div id="maintenance-section" class="admin-section hidden">
            <div class="admin-grid">
                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üîß</div>
                        <div class="card-title">Maintenance Control</div>
                    </div>
                    <div id="maintenance-control" class="loading">Loading maintenance status...</div>
                </div>

                <div class="admin-card">
                    <div class="card-header">
                        <div class="card-icon">üíæ</div>
                        <div class="card-title">System Operations</div>
                    </div>
                    <div class="action-buttons">
                        <button class="action-btn" onclick="performBackup()">üíæ Create Backup</button>
                        <button class="action-btn warning" onclick="clearCaches()">üóëÔ∏è Clear Caches</button>
                        <button class="action-btn danger" onclick="restartServer()">üîÑ Restart Server</button>
                    </div>
                    <div style="margin-top:14px;">
                        <div style="font-weight:600; font-size:13px; margin-bottom:6px; display:flex; align-items:center; gap:6px;">Restore Backup <button onclick="loadBackups()" class="action-btn" style="padding:4px 8px; font-size:11px;">Refresh</button></div>
                        <div id="backup-restore-area" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <select id="backup-select" class="form-input" style="min-width:260px; max-width:320px;">
                                <option value="">(no backups)</option>
                            </select>
                            <button class="action-btn" onclick="restoreSelectedBackup()">‚ôªÔ∏è Restore</button>
                            <span id="backup-restore-status" style="font-size:11px; opacity:0.75;"></span>
                        </div>
                        <div id="backup-list-meta" style="margin-top:6px; font-size:11px; opacity:0.6; min-height:14px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Monitoring Section -->
        <div id="monitoring-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">üìà</div>
                    <div class="card-title">Real-time Monitoring</div>
                </div>
                <div id="monitoring-data" class="loading">Loading monitoring data...</div>
            </div>
            <div class="admin-card" style="margin-top:20px;">
                <div class="card-header">
                    <div class="card-icon">üß™</div>
                    <div class="card-title">Synthetic Activity</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
                    <div>
                        <label class="form-label" style="font-size:12px;">Iterations</label>
                        <input id="synthetic-iterations" class="form-input" type="number" value="25" style="width:90px;" />
                    </div>
                    <div>
                        <label class="form-label" style="font-size:12px;">Concurrency</label>
                        <input id="synthetic-concurrency" class="form-input" type="number" value="3" style="width:90px;" />
                    </div>
                    <button id="synthetic-run-btn" class="action-btn" onclick="runSyntheticActivity()">Run Synthetic Activity</button>
                    <div id="synthetic-output" style="font-size:12px; opacity:0.85; min-height:20px; line-height:1.3; white-space:pre-wrap;"></div>
                </div>
                <div style="margin-top:8px; font-size:11px; opacity:0.7;">Executes random safe tools to exercise metrics & health. <span id="synthetic-last-meta" style="font-style:italic;"></span></div>
                                <div id="synthetic-traces-wrapper" style="margin-top:14px; display:none;">
                                    <div style="font-weight:600; font-size:13px; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                                        Per‚ÄëCall Trace
                                        <label style="font-size:11px; font-weight:400; display:flex; align-items:center; gap:4px;">
                                            <input id="synthetic-trace-toggle" type="checkbox" checked onchange="toggleSyntheticTraceVisibility()" /> show
                                        </label>
                                    </div>
                                    <div style="max-height:220px; overflow:auto; border:1px solid #eee; border-radius:4px;">
                                        <table style="width:100%; border-collapse:collapse; font-size:11px;">
                                            <thead style="position:sticky; top:0; background:#fafafa;">
                                                <tr>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">#</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Tool</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Success</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Duration</th>
                                                    <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">Error</th>
                                                </tr>
                                            </thead>
                                            <tbody id="synthetic-traces-body"></tbody>
                                        </table>
                                    </div>
                                </div>
            </div>

            <!-- Log Viewer Section -->
            <div class="admin-card" style="margin-top:20px;">
                <div class="card-header">
                    <div class="card-icon">üìã</div>
                    <div class="card-title">Server Logs</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:15px;">
                    <div>
                        <label class="form-label" style="font-size:12px;">Lines</label>
                        <input id="log-lines" class="form-input" type="number" value="100" style="width:80px;" />
                    </div>
                    <button class="action-btn" onclick="loadLogs()">üîÑ Refresh</button>
                    <button id="log-tail-btn" class="action-btn" onclick="toggleLogTail()">‚ñ∂Ô∏è Start Tail</button>
                    <button class="action-btn" onclick="clearLogViewer()">üóëÔ∏è Clear</button>
                    <div id="log-status" style="font-size:12px; opacity:0.7; font-style:italic;"></div>
                </div>
                <!-- Log content container id expected by scripts (was log-viewer) -->
                <div id="log-content" style="
                    background: #f8f9fa; 
                    border: 1px solid #dee2e6; 
                    border-radius: 6px; 
                    padding: 12px; 
                    height: 400px; 
                    overflow-y: auto; 
                    font-family: 'Courier New', monospace; 
                    font-size: 12px; 
                    line-height: 1.4;
                    white-space: pre-wrap;
                    color: #333;
                ">
                    <div style="color: #666; font-style: italic;">Click "Refresh" to load server logs...</div>
                </div>
                <div style="margin-top:8px; font-size:11px; opacity:0.7;">
                    Real-time server log viewer. Set MCP_LOG_FILE to a path OR simply '1' (auto => logs/mcp-server.log).
                </div>
            </div>
        </div>

    <!-- Instruction Management Section -->
        <div id="instructions-section" class="admin-section hidden">
            <div class="admin-card">
                <div class="card-header">
                    <div class="card-icon">üìö</div>
                    <div class="card-title">Instruction Catalog</div>
                </div>
                <div style="margin-bottom:15px; display:flex; gap:10px; flex-wrap:wrap;">
                    <button class="action-btn" onclick="loadInstructions()">üîÑ Refresh</button>
                    <button class="action-btn" onclick="showCreateInstruction()">‚ûï Create</button>
                    <input id="instruction-filter" placeholder="Filter by name..." class="form-input" style="flex:1; min-width:180px;" oninput="filterInstructions()" />
                    <select id="instruction-category-filter" class="form-input" style="width:130px;" onchange="filterInstructions()">
                        <option value="">All Categories</option>
                        <!-- Categories will be populated dynamically -->
                    </select>
                    <select id="instruction-size-filter" class="form-input" style="width:120px;" onchange="filterInstructions()">
                        <option value="">All Sizes</option>
                        <option value="small">small</option>
                        <option value="medium">medium</option>
                        <option value="large">large</option>
                    </select>
                    <select id="instruction-sort" class="form-input" style="width:150px;" onchange="filterInstructions()">
                        <option value="name-asc">Name A‚ÜíZ</option>
                        <option value="name-desc">Name Z‚ÜíA</option>
                        <option value="size-asc">Size ‚Üë</option>
                        <option value="size-desc">Size ‚Üì</option>
                        <option value="mtime-desc">Modified ‚Üì</option>
                        <option value="mtime-asc">Modified ‚Üë</option>
                        <option value="category">Category</option>
                    </select>
                </div>
                <div id="instructions-list" class="loading">Loading instructions...</div>
                <div id="instruction-pagination" style="margin-top:12px;"></div>
                <div id="instruction-editor" class="hidden" style="margin-top:20px;">
                    <h3 id="instruction-editor-title" style="margin-bottom:10px;">New Instruction</h3>
                    <div class="form-group">
                        <label class="form-label">File Name (no extension)</label>
                        <input id="instruction-filename" class="form-input" placeholder="example-instruction" />
                    </div>
                    <div class="form-group" style="margin-top:10px;">
                        <label class="form-label">JSON Content</label>
                        <textarea id="instruction-content" class="form-input" style="min-height:260px; font-family:monospace; white-space:pre; overflow:auto;" oninput="updateInstructionEditorDiagnostics()"></textarea>
                        <div id="instruction-diagnostics" style="margin-top:8px; font-size:12px; line-height:1.4; background:#f4f6fb; padding:8px 10px; border:1px solid #dbe2ec; border-radius:6px;">
                            <em>Editor idle.</em>
                        </div>
                        <div id="instruction-diff-container" class="hidden" style="margin-top:10px; max-height:240px; overflow:auto; border:1px solid #eee; border-radius:6px; background:#222; color:#ddd; font-family:monospace; font-size:12px; padding:8px;">
                            <div style="margin-bottom:6px; font-weight:600;">Diff (original vs current)</div>
                            <pre id="instruction-diff" style="white-space:pre; margin:0;"></pre>
                        </div>
                    </div>
                    <div style="margin-top:10px;">
                        <button class="action-btn" onclick="saveInstruction()">üíæ Save</button>
                        <button class="action-btn" style="background:linear-gradient(45deg,#3498db,#2980b9)" onclick="formatInstructionJson()">üßπ Format</button>
                        <button class="action-btn" style="background:linear-gradient(45deg,#8e44ad,#6c3483)" onclick="toggleInstructionDiff()">üîç Diff</button>
                        <button class="action-btn" style="background:linear-gradient(45deg,#16a085,#13856c)" onclick="applyInstructionTemplate()">üìê Template</button>
                        <button class="action-btn warning" onclick="cancelEditInstruction()">‚úñ Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Admin Panel JavaScript
        let currentSection = 'overview';
        let refreshInterval;
    // Track if /api/admin/stats responded successfully on most recent loadOverviewData()
    // Used to downgrade health display (memory/errors) when stats are missing.
    let statsAvailable = false;
    // WebSocket for live events (metrics + synthetic trace streaming)
    let dashboardSocket = null;
    let lastSyntheticRunId = null;
    function initDashboardSocket(){
        try {
            if (dashboardSocket && dashboardSocket.readyState === WebSocket.OPEN) return;
            const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
            dashboardSocket = new WebSocket(`${proto}://${location.host}/ws`);
            dashboardSocket.onopen = ()=>{/* noop */};
            dashboardSocket.onmessage = ev => {
                try {
                    const msg = JSON.parse(ev.data);
                    if (msg.type === 'synthetic_trace' && msg.data) {
                        handleSyntheticTrace(msg.data);
                    }
                } catch {/* ignore */}
            };
            dashboardSocket.onclose = ()=>{ setTimeout(initDashboardSocket, 4000); };
        } catch(e){ console.warn('ws init failed', e); }
    }
    function handleSyntheticTrace(data){
        if (!data || !data.runId) return;
        // If new run starts while traces visible, auto-clear
        if (lastSyntheticRunId && data.runId !== lastSyntheticRunId) {
            const body = document.getElementById('synthetic-traces-body');
            if (body) body.innerHTML='';
        }
        lastSyntheticRunId = data.runId;
        const body = document.getElementById('synthetic-traces-body');
        if (!body) return;
        const clr = data.success ? '#0a0' : '#a00';
        const err = data.error ? String(data.error).slice(0,80) : '';
        const skipped = data.skipped ? ' (skipped)' : '';
        const tr = document.createElement('tr');
        tr.innerHTML = `<td style="padding:2px 4px; border-bottom:1px solid #eee;">${data.seq}</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee; font-family:monospace;">${data.method}${skipped}</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${clr};">${data.success?'‚úì':'‚úó'}</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee;">${data.durationMs}ms</td>
            <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${data.error?'#b55':'#666'};">${err}</td>`;
        body.appendChild(tr);
        const wrap = document.getElementById('synthetic-traces-wrapper');
        if (wrap && wrap.style.display === 'none') wrap.style.display='block';
    }

        // Initialize admin panel
        document.addEventListener('DOMContentLoaded', function() {
            showSection('overview');
            startAutoRefresh();
            // Attempt to auto-create a dashboard admin session if none exists for this browser tab
            try { maybeEnsureAdminSession(); } catch(e) { console.warn('auto session create failed', e); }
            initDashboardSocket();
        });

        function showSection(section) {
            // Hide all sections
            document.querySelectorAll('.admin-section').forEach(s => s.classList.add('hidden'));

            // Show selected section if present
            const activeSection = document.getElementById(section + '-section');
            if (activeSection) activeSection.classList.remove('hidden');

            // Update nav buttons without relying on implicit event
            document.querySelectorAll('.nav-btn').forEach(btn => {
                const isTarget = btn.getAttribute('onclick')?.includes(`showSection('${section}')`);
                if (isTarget) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            currentSection = section;
            loadSectionData(section);
        }

        function loadSectionData(section) {
            switch(section) {
                case 'overview':
                    loadOverviewData();
                    break;
                case 'config':
                    loadConfiguration();
                    break;
                case 'sessions':
                    loadSessions();
                    break;
                case 'maintenance':
                    loadMaintenanceStatus();
                    loadBackups();
                    break;
                case 'monitoring':
                    loadMonitoringData();
                    ensureMonitoringPoll();
                    break;
                case 'instructions':
                    loadInstructions();
                    break;
            }
        }

        async function loadOverviewData() {
            try {
                const [statsRes, maintenanceRes, healthRes] = await Promise.all([
                    fetch('/api/admin/stats').catch(e => e),
                    fetch('/api/admin/maintenance').catch(e => e),
                    fetch('/api/health').catch(e => e)
                ]);

                const [statsData, maintenanceData, healthData] = await Promise.all([
                    statsRes?.json ? statsRes.json().catch(() => ({})) : {},
                    maintenanceRes?.json ? maintenanceRes.json().catch(() => ({})) : {},
                    healthRes?.json ? healthRes.json().catch(() => ({})) : {}
                ]);

                if (statsData?.success && statsData.stats) {
                    statsAvailable = true;
                    displaySystemStats(statsData.stats);
                } else {
                    statsAvailable = false;
                    const statsEl = document.getElementById('system-stats');
                    if (statsEl) statsEl.innerHTML = '<div class="error-message">Stats unavailable</div>';
                }

                // Maintenance summary (safe-guarded: function may be a no-op if not yet implemented)
                if (maintenanceData?.success && maintenanceData.maintenance) {
                    if (typeof displayMaintenanceInfo === 'function') {
                        try { displayMaintenanceInfo(maintenanceData.maintenance); } catch(e) { console.warn('displayMaintenanceInfo failed:', e); }
                    }
                }

                // Accept multiple health status variants: legacy 'ok' plus basic endpoint 'healthy'/'degraded'
                if (healthData && (healthData.success || ['ok','healthy','degraded'].includes(healthData.status))) {
                    displaySystemHealth(healthData.systemHealth || healthData.maintenance?.systemHealth || healthData);
                }
            } catch (error) {
                console.error('Error loading overview data:', error);
                showError('Failed to load overview data');
            }
        }

        function displaySystemStats(stats) {
            const html = `
                <div class="stat-row">
                    <span class="stat-label">Uptime</span>
                    <span class="stat-value">${formatUptime(stats.uptime)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Connections (WS)</span>
                    <span class="stat-value">${stats.activeConnections}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Admin Sessions</span>
                    <span class="stat-value">${stats.adminActiveSessions ?? '0'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Requests</span>
                    <span class="stat-value">${stats.totalRequests.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Error Rate</span>
                    <span class="stat-value">${stats.errorRate.toFixed(2)}%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Response Time</span>
                    <span class="stat-value">${stats.avgResponseTime.toFixed(1)}ms</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Memory Usage</span>
                    <span class="stat-value">${formatBytes(stats.memoryUsage.heapUsed)} / ${formatBytes(stats.memoryUsage.heapTotal)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">CPU Usage</span>
                    <span class="stat-value">${stats.cpuUsage ? stats.cpuUsage.percent.toFixed(1) + '%' : 'N/A'}</span>
                </div>
            `;
            document.getElementById('system-stats').innerHTML = html;

            // Performance stats
            const perfHtml = `
                <div class="stat-row">
                    <span class="stat-label">Total Connections</span>
                    <span class="stat-value">${stats.totalConnections.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Error Rate</span>
                    <span class="stat-value">${stats.errorRate.toFixed(2)}%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Response Time</span>
                    <span class="stat-value">${stats.avgResponseTime.toFixed(1)}ms</span>
                </div>
            `;
            document.getElementById('performance-stats').innerHTML = perfHtml;

            // Catalog stats
            const catalogHtml = `
                <div class="stat-row">
                    <span class="stat-label">Total Instructions</span>
                    <span class="stat-value">${stats.catalogStats.totalInstructions}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Version</span>
                    <span class="stat-value">${stats.catalogStats.version}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Schema Version</span>
                    <span class="stat-value">${stats.catalogStats.schemaVersion || 'unknown'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Last Updated</span>
                    <span class="stat-value">${stats.catalogStats.lastUpdated ? new Date(stats.catalogStats.lastUpdated).toLocaleString() : 'N/A'}</span>
                </div>
            `;
            const catalogEl = document.getElementById('catalog-stats');
            if (catalogEl) catalogEl.innerHTML = catalogHtml;

            // Display individual tool metrics
            displayToolMetrics(stats);
        }

        function displayToolMetrics(stats) {
            const toolMetricsEl = document.getElementById('tool-metrics');
            if (!toolMetricsEl || !stats.toolMetrics) {
                if (toolMetricsEl) toolMetricsEl.innerHTML = '<div class="error-message">Tool metrics unavailable</div>';
                return;
            }

            const tools = Object.entries(stats.toolMetrics);
            if (tools.length === 0) {
                toolMetricsEl.innerHTML = '<div class="stat-row"><span class="stat-label">No tool calls recorded yet</span></div>';
                return;
            }

            // Sort tools by call count (most used first)
            tools.sort(([,a], [,b]) => b.callCount - a.callCount);

            let html = '<div class="tool-metrics-grid">';
            
            tools.forEach(([toolName, metrics]) => {
                const avgResponseTime = metrics.callCount > 0 ? (metrics.totalResponseTime / metrics.callCount).toFixed(1) : '0.0';
                const successRate = metrics.callCount > 0 ? ((metrics.successCount / metrics.callCount) * 100).toFixed(1) : '100.0';
                const lastCalledStr = metrics.lastCalled ? new Date(metrics.lastCalled).toLocaleString() : 'Never';
                
                html += `
                    <div class="tool-metric-card">
                        <div class="tool-name">${toolName}</div>
                        <div class="tool-stats">
                            <div class="stat-row">
                                <span class="stat-label">Total Calls</span>
                                <span class="stat-value">${metrics.callCount.toLocaleString()}</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Success Rate</span>
                                <span class="stat-value ${parseFloat(successRate) < 95 ? 'warning' : ''}">${successRate}%</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Avg Response</span>
                                <span class="stat-value">${avgResponseTime}ms</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Errors</span>
                                <span class="stat-value ${metrics.errorCount > 0 ? 'error' : ''}">${metrics.errorCount}</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Last Called</span>
                                <span class="stat-value small">${lastCalledStr}</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            toolMetricsEl.innerHTML = html;
        }

        // Lightweight overview-level maintenance display (optional)
        // Intentionally minimal to avoid blocking overview rendering.
        // If an element with id 'maintenance-overview' exists, populate it; otherwise no-op.
        function displayMaintenanceInfo(maintenance) {
            try {
                const el = document.getElementById('maintenance-overview');
                if (!el || !maintenance) return; // Safe no-op if overview element not present
                const mode = maintenance.maintenanceMode ? 'ENABLED' : 'Disabled';
                el.innerHTML = `
                    <div class="stat-row">
                        <span class="stat-label">Maintenance Mode</span>
                        <span class="stat-value ${maintenance.maintenanceMode ? 'maintenance-enabled' : 'maintenance-disabled'}">${mode}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Last Backup</span>
                        <span class="stat-value">${maintenance.lastBackup ? new Date(maintenance.lastBackup).toLocaleString() : 'Never'}</span>
                    </div>`;
            } catch (err) {
                console.warn('displayMaintenanceInfo error:', err);
            }
        }

        function displaySystemHealth(health) {
            // Defensive normalization: /api/health returns { status, checks, uptime, timestamp } (no issues/recommendations)
            // while richer maintenance/system health objects may include arrays. Avoid assuming presence.
            if(!health || typeof health !== 'object') {
                document.getElementById('system-health').innerHTML = '<div class="error-message">Health data unavailable</div>';
                return;
            }
            const normalized = {
                status: (health.status || 'unknown').toString(),
                issues: Array.isArray(health.issues) ? health.issues : [],
                recommendations: Array.isArray(health.recommendations) ? health.recommendations : [],
                uptime: typeof health.uptime === 'number' ? health.uptime : (typeof health.server?.uptime === 'number' ? health.server.uptime : undefined),
                checks: health.checks || {}
            };
            // Uptime regression styling escalation: if an issue contains 'Uptime regression' force critical indicator
            let statusOverride = normalized.status;
            if (normalized.issues.some(i => /uptime regression/i.test(i))) {
                statusOverride = 'critical';
            }

            // If stats are unavailable, force failure semantics for memory/errors checks.
            if (!statsAvailable) {
                // Ensure checks for memory & errors exist and are marked as failed
                if (normalized.checks) {
                    normalized.checks.memory = false;
                    normalized.checks.errors = false;
                } else {
                    normalized.checks = { memory: false, errors: false };
                }
                if (!normalized.issues.some(i => /statistics unavailable/i.test(i))) {
                    normalized.issues.push('Statistics unavailable');
                }
                // Only override to failed if not already critical (critical remains highest severity)
                if (statusOverride !== 'critical') {
                    statusOverride = 'failed';
                }
            }
            const statusClass = `status-${statusOverride}`;
            let html = `
                <div class="stat-row">
                    <span class="stat-label">Overall Status</span>
                    <span class="stat-value">
                        ${statusOverride.toUpperCase()}
                        <span class="${statusClass} status-indicator"></span>
                    </span>
                </div>
            `;

            // Show basic check breakdown if present
            try {
                const checkKeys = Object.keys(normalized.checks);
                if(checkKeys.length){
                    html += '<div style="margin-top:10px;"><strong>Checks:</strong><ul style="margin-left:20px; margin-top:5px;">' +
                        checkKeys.map(k => `<li style=\"color:${normalized.checks[k]?'#2ecc71':'#e74c3c'};\">${k}: ${normalized.checks[k]?'ok':'fail'}</li>`).join('') + '</ul></div>';
                }
            } catch { /* ignore */ }

            // Add CPU trend information if available
            if (health.cpuTrend) {
                html += `
                    <div style="margin-top: 10px;">
                        <strong>CPU Trend:</strong> 
                        <span style="color: ${health.cpuTrend === 'stable' ? '#2ecc71' : health.cpuTrend === 'increasing' ? '#f39c12' : '#e74c3c'};">
                            ${health.cpuTrend}
                        </span>
                    </div>
                `;
            }

            // Add memory trend information if available
            if (health.memoryTrend) {
                const formatGrowthRate = (rate) => {
                    if (Math.abs(rate) < 1024) return `${rate.toFixed(0)} B/min`;
                    if (Math.abs(rate) < 1024 * 1024) return `${(rate / 1024).toFixed(1)} KB/min`;
                    return `${(rate / (1024 * 1024)).toFixed(1)} MB/min`;
                };
                
                html += `
                    <div style="margin-top: 10px;">
                        <strong>Memory Trend:</strong> 
                        <span style="color: ${health.memoryTrend === 'stable' ? '#2ecc71' : health.memoryTrend === 'increasing' ? '#f39c12' : '#e74c3c'};">
                            ${health.memoryTrend}
                        </span>
                        ${health.memoryGrowthRate ? ` (${formatGrowthRate(health.memoryGrowthRate)})` : ''}
                    </div>
                `;
            }

            if (normalized.issues.length > 0) {
                html += `
                    <div style="margin-top: 15px;">
                        <strong>Issues:</strong>
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            ${normalized.issues.map(issue => `<li style="color: #e74c3c;">${issue}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            if (normalized.recommendations.length > 0) {
                html += `
                    <div style="margin-top: 15px;">
                        <strong>Recommendations:</strong>
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            ${normalized.recommendations.map(rec => `<li style="color: #f39c12;">${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            document.getElementById('system-health').innerHTML = html;
        }

        // --- Backup / Restore ---
        async function loadBackups() {
            try {
                const sel = document.getElementById('backup-select');
                const meta = document.getElementById('backup-list-meta');
                if (!sel) return;
                sel.innerHTML = '<option value="">Loading...</option>';
                const res = await fetch('/api/admin/maintenance/backups');
                if (!res.ok) throw new Error('list failed');
                const data = await res.json();
                const backups = (data.backups || []).slice(0, 200);
                if (!backups.length) {
                    sel.innerHTML = '<option value="">(no backups)</option>';
                    if (meta) meta.textContent = 'No backups available';
                    return;
                }
                sel.innerHTML = backups.map(b => {
                    const label = `${b.id}  ‚Ä¢  ${b.instructionCount} files  ‚Ä¢  ${b.schemaVersion || 'schema?'}  ‚Ä¢  ${new Date(b.createdAt).toLocaleString()}`;
                    return `<option value="${b.id}">${label}</option>`;
                }).join('');
                if (meta) meta.textContent = `${backups.length} backup(s)`;
            } catch (err) {
                console.warn('loadBackups error', err);
                const sel = document.getElementById('backup-select');
                if (sel) sel.innerHTML = '<option value="">(error loading)</option>';
            }
        }

        async function restoreSelectedBackup() {
            try {
                const sel = document.getElementById('backup-select');
                const statusEl = document.getElementById('backup-restore-status');
                if (!sel || !sel.value) { if (statusEl) statusEl.textContent = 'Select a backup first'; return; }
                const choice = sel.value;
                if (!confirm(`Restore backup ${choice}? Current instructions will be safety-backed up first.`)) return;
                statusEl.textContent = 'Restoring...';
                const res = await fetch('/api/admin/maintenance/restore', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ backupId: choice }) });
                const data = await res.json();
                if (data.success) {
                    statusEl.textContent = `Restored ${choice} (${data.restored || 0} files)`;
                    // Re-load stats & instructions to reflect changes
                    loadOverviewData();
                    if (currentSection === 'instructions') loadInstructions();
                } else {
                    statusEl.textContent = `Restore failed: ${data.error || data.message || 'unknown'}`;
                }
            } catch (err) {
                const statusEl = document.getElementById('backup-restore-status');
                if (statusEl) statusEl.textContent = 'Error restoring backup';
            }
        }

                async function loadSessions() {
            try {
                let sessionsCount = 0;
                let connectionsCount = 0;
                // Admin logical sessions
                const response = await fetch('/api/admin/sessions');
                const data = await response.json();
                if (data.success) {
                    displaySessions(data.sessions);
                    sessionsCount = Array.isArray(data.sessions) ? data.sessions.length : 0;
                    // If no sessions were active, attempt auto-create then reload once
                    if (sessionsCount === 0) {
                        try {
                            const created = await maybeEnsureAdminSession(true);
                            if (created) {
                                // Re-fetch sessions after creation
                                const r2 = await fetch('/api/admin/sessions');
                                const d2 = await r2.json();
                                if (d2.success) { displaySessions(d2.sessions); sessionsCount = d2.sessions.length; }
                            }
                        } catch(e) { /* ignore */ }
                    }
                } else {
                    showError('Failed to load sessions');
                }
                // Active websocket connections
                try {
                    const connRes = await fetch('/api/admin/connections');
                    const connData = await connRes.json();
                    const connEl = document.getElementById('connections-list');
                    if (connData.success && connEl) {
                        connectionsCount = Array.isArray(connData.connections) ? connData.connections.length : 0;
                        if (!connectionsCount) {
                            connEl.innerHTML = '<div class="empty-state">No active websocket connections</div>';
                        } else {
                            const fmt = (ms) => {
                                if (ms == null) return '‚Äî';
                                if (ms < 1000) return ms + ' ms';
                                const s = ms / 1000;
                                if (s < 60) return s.toFixed(1) + ' s';
                                const m = Math.floor(s / 60);
                                const rs = Math.floor(s % 60);
                                return m + 'm ' + rs + 's';
                            };
                            connEl.innerHTML = '<table class="session-table"><thead><tr><th>ID</th><th>Connected</th><th>Duration</th></tr></thead><tbody>' +
                                connData.connections.map(c => {
                                    const connected = c.connectedAt ? new Date(c.connectedAt).toLocaleTimeString() : '‚Äî';
                                    return `<tr><td>${escapeHtml(c.id)}</td><td>${connected}</td><td>${fmt(c.durationMs)}</td></tr>`;
                                }).join('') + '</tbody></table>';
                        }
                    } else if (connEl) {
                        connEl.innerHTML = '<div class="error-message">Failed to load active connections</div>';
                    }
                } catch (e) {
                    const connEl = document.getElementById('connections-list');
                    if (connEl) connEl.innerHTML = '<div class="error-message">Error loading active connections</div>';
                }

                // Auto-load session history (now part of Sessions section)
                try { if (typeof loadSessionHistory === 'function') loadSessionHistory(parseInt((document.getElementById('session-history-limit')||{value:'50'}).value,10)); } catch {}
                // Update nav badge with latest counts
                window.__lastSessionsCount = sessionsCount;
                window.__lastConnectionsCount = connectionsCount;
                updateSessionsNavBadge();
            } catch (error) {
                console.error('Error loading sessions:', error);
                showError('Failed to load sessions');
            }
        }

        function updateSessionsNavBadge(){
            const navBtn = document.getElementById('nav-sessions');
            if(!navBtn) return;
            const s = window.__lastSessionsCount ?? 0;
            const c = window.__lastConnectionsCount ?? 0;
            let badge = navBtn.querySelector('.nav-badge');
            if(!badge){
                badge = document.createElement('span');
                badge.className = 'nav-badge';
                badge.style.cssText = 'margin-left:6px; background:#444; color:#fff; padding:2px 6px; border-radius:10px; font-size:11px; font-weight:500;';
                navBtn.appendChild(badge);
            }
            badge.textContent = `${s}/${c}`; // sessions / connections
            badge.title = `Admin sessions: ${s} | Websocket connections: ${c}`;
        }

        // Auto-session creation logic; stores created session id in sessionStorage to avoid duplicates per tab.
        async function maybeEnsureAdminSession(onlyIfRequested) {
            try {
                if (typeof sessionStorage === 'undefined') return false;
                const existing = sessionStorage.getItem('mcp_admin_session_id');
                // If we already have a session id and we're NOT being explicitly
                // asked to ensure one, skip creating a new one.
                if (existing && !onlyIfRequested) return false;
                // Previous logic bailed out even when the server had zero sessions but
                // the tab held a stale session id (after server restart). That prevented
                // auto recreation. Now, when onlyIfRequested is true we will attempt
                // creation even if a stale id exists; we simply overwrite it.
                const res = await fetch('/api/admin/sessions', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ userId: 'dashboard_auto' }) });
                const data = await res.json().catch(()=>({}));
                if (data.success && data.session && data.session.id) {
                    sessionStorage.setItem('mcp_admin_session_id', data.session.id);
                    return true;
                }
            } catch (e) { /* ignore */ }
            return false;
        }

        // ===== Session History (NEW) =====
        async function loadSessionHistory(limit = 50) {
            try {
                const res = await fetch('/api/admin/sessions/history?limit=' + limit);
                const data = await res.json();
                if (!data.success) throw new Error();
                renderSessionHistory(data.history || []);
            } catch (err) {
                const el = document.getElementById('session-history-list');
                if (el) el.innerHTML = '<div class="error">Failed to load session history</div>';
            }
        }

        function renderSessionHistory(history) {
            const el = document.getElementById('session-history-list');
            if (!el) return;
            if (!history.length) { el.innerHTML = '<p>No history entries</p>'; return; }
            el.innerHTML = history.map(h => `
                <div class="session-item" style="background:#fff;">
                  <div class="session-header">
                    <span class="session-id" style="background:#ececec;">${h.id}</span>
                    <span style="font-size:11px; opacity:0.7;">${h.terminationReason || 'active'}</span>
                  </div>
                  <div class="stat-row"><span class="stat-label">Started</span><span class="stat-value">${h.startTime ? new Date(h.startTime).toLocaleString() : '‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">Ended</span><span class="stat-value">${h.endTime ? new Date(h.endTime).toLocaleString() : '‚Äî'}</span></div>
                </div>`).join('');
        }

        function refreshSessionHistory() {
            const limitSel = document.getElementById('session-history-limit');
            const limit = parseInt(limitSel.value, 10) || 50;
            loadSessionHistory(limit);
        }

                // ===== Synthetic Activity (TRACE-ENABLED) =====
                function toggleSyntheticTraceVisibility(){
                    const wrap = document.getElementById('synthetic-traces-wrapper');
                    const chk = document.getElementById('synthetic-trace-toggle');
                    if(!wrap||!chk) return;
                    wrap.style.display = chk.checked ? 'block':'none';
                }
                async function runSyntheticActivity() {
                    const iter = parseInt(document.getElementById('synthetic-iterations').value, 10) || 10;
                    const conc = parseInt(document.getElementById('synthetic-concurrency').value, 10) || 2;
                    const wantTrace = document.getElementById('synthetic-trace-toggle')?.checked !== false; // default true
                    const btn = document.getElementById('synthetic-run-btn');
                    const output = document.getElementById('synthetic-output');
                    btn.disabled = true; btn.textContent = 'Running‚Ä¶';
                    output.textContent = 'Executing synthetic activity...';
                    const tracesBody = document.getElementById('synthetic-traces-body');
                    if(tracesBody) tracesBody.innerHTML = '';
                    // Accelerate monitoring poll during run
                    let previousInterval = monitoringInterval;
                    if (monitoringInterval) { clearInterval(monitoringInterval); monitoringInterval=null; }
                    monitoringInterval = setInterval(()=>{
                        if (document.getElementById('monitoring-section')?.classList.contains('hidden')) return;
                        loadMonitoringData();
                        updateActiveSyntheticRequests();
                    }, 1000); // fast poll while running
                    let statusTimer = setInterval(updateActiveSyntheticRequests, 1000);
                    try {
                        const url = '/api/admin/synthetic/activity?debug=1'+(wantTrace?'&trace=1&stream=1':'');
                        const res = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ iterations: iter, concurrency: conc }) });
                        const rawText = await res.text();
                        let data = null; try { data = JSON.parse(rawText); } catch { /* ignore */ }
                        if (!res.ok || !data) {
                            throw new Error(data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${res.status} (non-JSON)`);
                        }
                        if (!data.success) {
                            throw new Error(data.error || data.message || 'Unknown failure');
                        }
                        const metaLine = `Executed ${data.executed}/${data.iterationsRequested} (errors:${data.errors}) in ${data.durationMs}ms @c=${data.concurrency} tools:${data.availableCount}`;
                        output.textContent = metaLine + (data.available ? `\nSample: ${data.available.slice(0,5).join(', ')}` : '');
                        const lastMeta = document.getElementById('synthetic-last-meta');
                        if (lastMeta) lastMeta.textContent = `Last run: ${new Date().toLocaleTimeString()} ${metaLine}`;
                        if (wantTrace && tracesBody) {
                            if (Array.isArray(data.traces) && data.traces.length) {
                                const rows = data.traces.map((t,i)=>{
                                    const clr = t.success ? '#0a0' : '#a00';
                                    const err = t.error ? String(t.error).slice(0,80) : '';
                                    const skipped = t.skipped ? ' (skipped)' : '';
                                    return `<tr>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee;">${i+1}</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee; font-family:monospace;">${t.method}${skipped}</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${clr};">${t.success?'‚úì':'‚úó'}</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee;">${t.durationMs}ms</td>
                                        <td style="padding:2px 4px; border-bottom:1px solid #eee; color:${t.error?'#b55':'#666'};">${err}</td>
                                    </tr>`;
                                }).join('');
                                tracesBody.innerHTML = rows;
                            } else {
                                const reason = data.traceReason || 'no traces captured';
                                tracesBody.innerHTML = `<tr><td colspan="5" style="padding:4px; font-style:italic;">${reason}</td></tr>`;
                            }
                            document.getElementById('synthetic-traces-wrapper').style.display = 'block';
                        }
                        // Refresh overview + monitoring for updated metrics
                        loadOverviewData();
                        loadMonitoringData();
                    } catch (err) {
                        const emsg = (err && err.message) || 'unknown error';
                        output.textContent = `Synthetic activity failed: ${emsg}`;
                        if (/No safe tools/i.test(emsg)) {
                            output.textContent += '\nHint: Ensure server started after tool handlers registered (import order)';
                        }
                    } finally {
                        btn.disabled = false; btn.textContent = 'Run Synthetic Activity';
                        // Restore slower poll cadence
                        if (monitoringInterval) { clearInterval(monitoringInterval); monitoringInterval=null; }
                        if (statusTimer) { clearInterval(statusTimer); statusTimer=null; }
                        if (!previousInterval) { // restart default if monitoring tab visible
                            ensureMonitoringPoll();
                        }
                        // One last status refresh to clear active counter
                        updateActiveSyntheticRequests();
                    }
                }

                // Fetch active synthetic request count and inject into monitoring panel if present
                async function updateActiveSyntheticRequests(){
                    try {
                        const res = await fetch('/api/admin/synthetic/status');
                        const data = await res.json();
                        if (!data.success) return;
                        const active = data.activeRequests || 0;
                        // Find monitoring panel metric list and append/update a synthetic active row
                        const container = document.getElementById('monitoring-data');
                        if (container && container.innerHTML.includes('Throughput')) {
                            const id = 'active-synth-requests-row';
                            let el = document.getElementById(id);
                            if (!el) {
                                const div = document.createElement('div');
                                div.className='stat-row';
                                div.id = id;
                                div.innerHTML = '<span class="stat-label">Active Synthetic Requests</span><span class="stat-value">0</span>';
                                container.insertBefore(div, container.firstChild.nextSibling); // after first row
                                el = div;
                            }
                            const valSpan = el.querySelector('.stat-value');
                            if (valSpan) valSpan.textContent = String(active);
                        }
                    } catch { /* ignore */ }
                }

        function displaySessions(sessions) {
            if (sessions.length === 0) {
                document.getElementById('sessions-list').innerHTML = '<p>No active admin sessions</p>';
                return;
            }

            const html = sessions.map(session => `
                <div class="session-item">
                    <div class="session-header">
                        <span class="session-id">${session.id}</span>
                        <button class="action-btn danger" onclick="terminateSession('${session.id}')">Terminate</button>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">User ID</span>
                        <span class="stat-value">${session.userId}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">IP Address</span>
                        <span class="stat-value">${session.ipAddress}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Start Time</span>
                        <span class="stat-value">${new Date(session.startTime).toLocaleString()}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Last Activity</span>
                        <span class="stat-value">${new Date(session.lastActivity).toLocaleString()}</span>
                    </div>
                </div>
            `).join('');

            document.getElementById('sessions-list').innerHTML = html;
        }

        async function createTestSession() {
            try {
                const response = await fetch('/api/admin/sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: 'test_admin_' + Date.now() })
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess('Test session created successfully');
                    loadSessions();
                } else {
                    showError('Failed to create test session');
                }
            } catch (error) {
                console.error('Error creating test session:', error);
                showError('Failed to create test session');
            }
        }

        async function terminateSession(sessionId) {
            try {
                const response = await fetch(`/api/admin/sessions/${sessionId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess('Session terminated successfully');
                    loadSessions();
                } else {
                    showError('Failed to terminate session');
                }
            } catch (error) {
                console.error('Error terminating session:', error);
                showError('Failed to terminate session');
            }
        }

        async function loadMaintenanceStatus() {
            try {
                const response = await fetch('/api/admin/maintenance');
                const data = await response.json();

                if (data.success) {
                    displayMaintenanceStatus(data.maintenance);
                } else {
                    showError('Failed to load maintenance status');
                }
            } catch (error) {
                console.error('Error loading maintenance status:', error);
                showError('Failed to load maintenance status');
            }
        }

        function displayMaintenanceStatus(maintenance) {
            const statusClass = maintenance.maintenanceMode ? 'maintenance-enabled' : 'maintenance-disabled';
            const statusText = maintenance.maintenanceMode ? 'MAINTENANCE MODE ENABLED' : 'NORMAL OPERATION';
            
            let html = `
                <div class="maintenance-status ${statusClass}">
                    ${statusText}
                </div>
                <div class="stat-row">
                    <span class="stat-label">Last Backup</span>
                    <span class="stat-value">${maintenance.lastBackup ? new Date(maintenance.lastBackup).toLocaleString() : 'Never'}</span>
                </div>
            `;

            if (!maintenance.maintenanceMode) {
                html += `<button class="action-btn warning" onclick="toggleMaintenanceMode(true)">Enable Maintenance Mode</button>`;
            } else {
                html += `<button class="action-btn" onclick="toggleMaintenanceMode(false)">Disable Maintenance Mode</button>`;
            }

            document.getElementById('maintenance-control').innerHTML = html;
        }

        async function toggleMaintenanceMode(enable) {
            try {
                const response = await fetch('/api/admin/maintenance/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        enabled: enable, 
                        message: enable ? 'Admin panel maintenance' : undefined 
                    })
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(data.message);
                    loadMaintenanceStatus();
                } else {
                    showError('Failed to toggle maintenance mode');
                }
            } catch (error) {
                console.error('Error toggling maintenance mode:', error);
                showError('Failed to toggle maintenance mode');
            }
        }

        async function performBackup() {
            try {
                showSuccess('Backup started...');
                const response = await fetch('/api/admin/maintenance/backup', {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(`Backup completed: ${data.backupId}`);
                    loadMaintenanceStatus();
                } else {
                    showError('Backup failed');
                }
            } catch (error) {
                console.error('Error performing backup:', error);
                showError('Backup failed');
            }
        }

        async function clearCaches() {
            try {
                const response = await fetch('/api/admin/cache/clear', {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(`Caches cleared: ${data.cleared.join(', ')}`);
                } else {
                    showError('Failed to clear caches');
                }
            } catch (error) {
                console.error('Error clearing caches:', error);
                showError('Failed to clear caches');
            }
        }

        async function restartServer() {
            if (!confirm('Are you sure you want to restart the server? This may temporarily interrupt service.')) {
                return;
            }

            try {
                showSuccess('Server restart initiated...');
                const response = await fetch('/api/admin/restart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ component: 'all' })
                });

                const data = await response.json();
                if (data.success) {
                    showSuccess(data.message);
                } else {
                    showError('Server restart failed');
                }
            } catch (error) {
                console.error('Error restarting server:', error);
                showError('Server restart failed');
            }
        }

                async function loadConfiguration() {
                        try {
                                const res = await fetch('/api/admin/config');
                                const data = await res.json();
                                if (!data.success) throw new Error('Failed to load config');
                                const cfg = data.config;
                                const html = `
                                    <form onsubmit="return updateConfiguration(event)">
                                        <div class="form-group">
                                            <label class="form-label">Max Connections</label>
                                            <input class="form-input" type="number" id="cfg-maxConnections" value="${cfg.serverSettings.maxConnections}" />
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Request Timeout (ms)</label>
                                            <input class="form-input" type="number" id="cfg-requestTimeout" value="${cfg.serverSettings.requestTimeout}" />
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Verbose Logging</label>
                                            <select class="form-input" id="cfg-verbose"> <option value="1" ${cfg.serverSettings.enableVerboseLogging ? 'selected':''}>Enabled</option><option value="0" ${!cfg.serverSettings.enableVerboseLogging ? 'selected':''}>Disabled</option></select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Enable Mutation</label>
                                            <select class="form-input" id="cfg-mutation"> <option value="1" ${cfg.serverSettings.enableMutation ? 'selected':''}>Enabled</option><option value="0" ${!cfg.serverSettings.enableMutation ? 'selected':''}>Disabled</option></select>
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Rate Limit Window (ms)</label>
                                            <input class="form-input" type="number" id="cfg-windowMs" value="${cfg.serverSettings.rateLimit.windowMs}" />
                                        </div>
                                        <div class="form-group">
                                            <label class="form-label">Rate Limit Max Requests</label>
                                            <input class="form-input" type="number" id="cfg-maxRequests" value="${cfg.serverSettings.rateLimit.maxRequests}" />
                                        </div>
                                        <div style="margin-top:10px;">
                                            <button class="action-btn" type="submit">üíæ Save Config</button>
                                        </div>
                                    </form>`;
                                document.getElementById('config-form').innerHTML = html;
                        } catch (e) {
                                document.getElementById('config-form').innerHTML = '<div class="error">Failed to load configuration</div>';
                        }
                }

                async function updateConfiguration(ev) {
                        ev.preventDefault();
                        const updates = {
                                serverSettings: {
                                        maxConnections: parseInt(document.getElementById('cfg-maxConnections').value),
                                        requestTimeout: parseInt(document.getElementById('cfg-requestTimeout').value),
                                        enableVerboseLogging: document.getElementById('cfg-verbose').value === '1',
                                        enableMutation: document.getElementById('cfg-mutation').value === '1',
                                        rateLimit: {
                                                windowMs: parseInt(document.getElementById('cfg-windowMs').value),
                                                maxRequests: parseInt(document.getElementById('cfg-maxRequests').value)
                                        }
                                }
                        };
                        try {
                                const res = await fetch('/api/admin/config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(updates)});
                                const data = await res.json();
                                if (data.success) { showSuccess('Configuration updated'); loadConfiguration(); } else { showError(data.error || 'Update failed'); }
                        } catch (e) { showError('Update failed'); }
                        return false;
                }

        async function loadMonitoringData() {
            try {
                const [perfRes, sysRes, alertsRes] = await Promise.all([
                    fetch('/api/performance/detailed').catch(e=>e),
                    fetch('/api/system/health').catch(e=>e),
                    fetch('/api/alerts/active').catch(e=>e)
                ]);
                const [perfData, sysData, alertsData] = await Promise.all([
                    perfRes?.json ? perfRes.json().catch(()=>({})) : {},
                    sysRes?.json ? sysRes.json().catch(()=>({})) : {},
                    alertsRes?.json ? alertsRes.json().catch(()=>({})) : {}
                ]);
                const perf = perfData.data || {};
                const sys = sysData.data || {};
                const alerts = (alertsData.data || []).slice(0,5);
                const html = `
                  <div class="stat-row"><span class="stat-label">Throughput (rpm)</span><span class="stat-value">${perf.requestThroughput ?? '‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">Avg Response</span><span class="stat-value">${perf.averageResponseTime?.toFixed ? perf.averageResponseTime.toFixed(1)+'ms':'‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">P95</span><span class="stat-value">${perf.p95ResponseTime ?? '‚Äî'}ms</span></div>
                  <div class="stat-row"><span class="stat-label">Error Rate</span><span class="stat-value">${perf.errorRate?.toFixed ? perf.errorRate.toFixed(2)+'%':'‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">Active Connections</span><span class="stat-value">${perf.concurrentConnections ?? '‚Äî'}</span></div>
                  <div class="stat-row"><span class="stat-label">System Health</span><span class="stat-value">${sys.status || '‚Äî'}</span></div>
                  <div style="margin-top:10px;">
                    <strong>Active Alerts (${alerts.length})</strong>
                    <ul style="margin-left:20px;">${alerts.map(a=>`<li>${a.type} (${a.severity}) - ${a.message}</li>`).join('') || '<li>No active alerts</li>'}</ul>
                  </div>`;
                document.getElementById('monitoring-data').innerHTML = html;
                                // Update nav badge if sessions already loaded
                                updateSessionsNavBadge();
            } catch (e) {
                document.getElementById('monitoring-data').innerHTML = '<div class="error">Failed to load monitoring data</div>';
            }
        }

                // Periodic refresh when Monitoring tab visible
                let monitoringInterval = null;
                function ensureMonitoringPoll(){
                    if (document.getElementById('monitoring-section')?.classList.contains('hidden')) return;
                    if (monitoringInterval) return; // already
                    monitoringInterval = setInterval(()=>{
                        if (document.getElementById('monitoring-section')?.classList.contains('hidden')) { clearInterval(monitoringInterval); monitoringInterval=null; return; }
                        loadMonitoringData();
                    }, 5000);
                }

        // ===== Log Viewer =====
        let logEventSource = null;
        let logTailing = false;

    async function loadLogs() {
            try {
                const lines = document.getElementById('log-lines').value || 100;
                // Prefer JSON shape; fall back to raw if server older
                let logsArray = [];
                let rawMode = false;
                let response = await fetch(`/api/logs?lines=${lines}`);
                if (response.ok) {
                    const ct = response.headers.get('content-type') || '';
                    if (ct.includes('application/json')) {
                        try {
                            const data = await response.json();
                            if (Array.isArray(data.logs)) {
                                logsArray = data.logs;
                            } else if (typeof data === 'object') {
                                // attempt common legacy shape
                                logsArray = Object.values(data).filter(v=>typeof v === 'string');
                            }
                        } catch {
                            rawMode = true;
                        }
                    } else {
                        rawMode = true;
                    }
                }
                if (rawMode) {
                    // Re-fetch explicitly requesting raw text
                    response = await fetch(`/api/logs?lines=${lines}&raw=1`);
                    const txt = await response.text();
                    logsArray = txt.split(/\r?\n/);
                }
                const rendered = logsArray.join('\n');
                document.getElementById('log-content').innerHTML = `<pre>${escapeHtml(rendered)}</pre>`;
                
                // Auto-scroll to bottom if tailing
                if (logTailing) {
                    const logContent = document.getElementById('log-content');
                    logContent.scrollTop = logContent.scrollHeight;
                }
            } catch (error) {
                console.error('Failed to load logs:', error);
                document.getElementById('log-content').innerHTML = '<div class="error">Failed to load logs</div>';
            }
        }

        function toggleLogTail() {
            // ID in markup is log-tail-btn (previous mismatch prevented toggling)
            const button = document.getElementById('log-tail-btn');
            
            if (logTailing) {
                // Stop tailing
                if (logEventSource) {
                    logEventSource.close();
                    logEventSource = null;
                }
                logTailing = false;
                button.textContent = 'Start Tail';
                button.className = 'btn btn-primary';
            } else {
                // Start tailing
                logTailing = true;
                button.textContent = 'Stop Tail';
                button.className = 'btn btn-warning';
                
                // Start EventSource for real-time logs
                logEventSource = new EventSource('/api/logs/stream');
                
                logEventSource.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.line) {
                            const logContent = document.getElementById('log-content');
                            const pre = logContent.querySelector('pre') || document.createElement('pre');
                            
                            if (!logContent.querySelector('pre')) {
                                logContent.innerHTML = '';
                                logContent.appendChild(pre);
                            }
                            
                            pre.textContent += data.line + '\n';
                            
                            // Auto-scroll to bottom
                            logContent.scrollTop = logContent.scrollHeight;
                            
                            // Limit log display to prevent memory issues
                            const lines = pre.textContent.split('\n');
                            const maxLines = 2000;
                            if (lines.length > maxLines) {
                                pre.textContent = lines.slice(-maxLines).join('\n');
                            }
                        }
                    } catch (error) {
                        console.error('Error processing log stream:', error);
                    }
                };
                
                logEventSource.onerror = function(error) {
                    console.error('Log stream error:', error);
                    // Auto-reconnect on error
                    setTimeout(() => {
                        if (logTailing) {
                            toggleLogTail();
                            setTimeout(() => toggleLogTail(), 1000);
                        }
                    }, 2000);
                };
            }
        }

        function clearLogViewer() {
            document.getElementById('log-content').innerHTML = '<div class="info">Log viewer cleared</div>';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ===== Resource Trend (CPU/Mem) Long-Term History =====
        // Lightweight front-end integration for /api/system/resources
        (function initResourceTrends(){
            const overview = document.querySelector('#overview-section');
            if(!overview) return;
            // Avoid duplicate insertion
            if(document.getElementById('resource-trends-card')) return;
            const card = document.createElement('div');
            card.className = 'admin-card';
            card.id = 'resource-trends-card';
            card.innerHTML = `
                <div class="card-header">
                  <div class="card-icon">üß†</div>
                  <div class="card-title">Resource Trends</div>
                </div>
                <div id="resource-trends-body" style="font-size:12px; line-height:1.4;">
                  <em>Collecting samples...</em>
                </div>`;
            // Insert after existing performance card if present
            overview.appendChild(card);

            async function fetchResourceTrends(){
                try {
                    const res = await fetch('/api/system/resources?limit=300');
                    if(!res.ok) throw new Error('http '+res.status);
                    const json = await res.json();
                    const samples = json?.data?.samples || [];
                    const trend = json?.data?.trend || { cpuSlope:0, memSlope:0 };
                    if(samples.length === 0){
                        document.getElementById('resource-trends-body').innerHTML = '<span style="opacity:.7">No samples yet.</span>';
                        return;
                    }
                    const latest = samples[samples.length-1];
                    const first = samples[0];
                    const durationSec = ((latest.timestamp - first.timestamp)/1000).toFixed(0);
                    // Convert memSlope (bytes/sec) to KB/sec for readability
                    const memSlopeKb = (trend.memSlope/1024).toFixed(2);
                    // Simple sparkline (last up to 40 samples) using unicode blocks based on cpu percent
                    const tail = samples.slice(-40);
                    const spark = tail.map(s=>{
                        const v = Math.min(100, Math.max(0, s.cpuPercent));
                        const idx = Math.round(v/12.5); // 0-8
                        const blocks = ['‚ñÅ','‚ñÇ','‚ñÉ','‚ñÑ','‚ñÖ','‚ñÜ','‚ñá','‚ñà'];
                        return blocks[Math.min(blocks.length-1, idx)];
                    }).join('');
                    document.getElementById('resource-trends-body').innerHTML = `
                        <div style="display:flex; flex-direction:column; gap:4px;">
                          <div><strong>Window:</strong> ${durationSec}s (${samples.length} samples)</div>
                          <div><strong>Latest CPU:</strong> ${latest.cpuPercent.toFixed(1)}% &nbsp; <strong>Latest Heap:</strong> ${(latest.heapUsed/1024/1024).toFixed(2)} MB</div>
                          <div><strong>CPU Slope:</strong> ${trend.cpuSlope.toFixed(3)} %/s &nbsp; <strong>Mem Slope:</strong> ${memSlopeKb} KB/s</div>
                          <div style="font-family:monospace; font-size:14px;">${spark}</div>
                        </div>`;
                } catch(e){
                    document.getElementById('resource-trends-body').innerHTML = '<span class="error">Failed to load resource history</span>';
                }
            }
            fetchResourceTrends();
            setInterval(fetchResourceTrends, 10000); // update every 10s
        })();

        // ===== Instruction Management =====
        let instructionEditing = null;
                // Pagination state
                let allInstructions = [];
                let instructionPage = 1;
                let instructionPageSize = 25; // default page size

                function getInstructionPageSizes() { return [10,25,50,100, 'All']; }

                function buildInstructionPaginationControls(totalFiltered) {
                        const container = document.getElementById('instruction-pagination');
                        if (!container) return;
                        const total = totalFiltered;
                        const pageSize = instructionPageSize === 'All' ? total : instructionPageSize;
                        const totalPages = pageSize === 0 ? 1 : Math.max(1, Math.ceil(total / pageSize));
                        if (instructionPage > totalPages) instructionPage = totalPages; // clamp

                        const disablePrev = instructionPage <= 1;
                        const disableNext = instructionPage >= totalPages;

                        const sizeOptions = getInstructionPageSizes().map(s => `<option value="${s}" ${s===instructionPageSize? 'selected':''}>${s}</option>`).join('');
                        container.innerHTML = `
                            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                                <label style="display:flex; align-items:center; gap:4px;">Page Size:
                                    <select id="instruction-page-size" class="form-input" style="width:auto; padding:4px;">${sizeOptions}</select>
                                </label>
                                <div style="display:flex; align-items:center; gap:4px;">
                                    <button class="action-btn" onclick="changeInstructionPage('first')" ${disablePrev?'disabled':''}>‚èÆ First</button>
                                    <button class="action-btn" onclick="changeInstructionPage('prev')" ${disablePrev?'disabled':''}>‚óÄ Prev</button>
                                    <span style="font-size:12px;">Page ${instructionPage} / ${totalPages}</span>
                                    <button class="action-btn" onclick="changeInstructionPage('next')" ${disableNext?'disabled':''}>Next ‚ñ∂</button>
                                    <button class="action-btn" onclick="changeInstructionPage('last')" ${disableNext?'disabled':''}>Last ‚è≠</button>
                                </div>
                                <span style="margin-left:auto; font-size:12px; opacity:0.8;">Filtered: ${total} total</span>
                            </div>`;
                        const sizeSelect = document.getElementById('instruction-page-size');
                        sizeSelect.onchange = () => {
                                instructionPageSize = sizeSelect.value === 'All' ? 'All' : parseInt(sizeSelect.value,10);
                                instructionPage = 1; // reset to first page when size changes
                                renderInstructionList(allInstructions);
                        };
                }

                function changeInstructionPage(dir) {
                        const totalFiltered = getFilteredInstructions(allInstructions).length;
                        const pageSizeVal = instructionPageSize === 'All' ? totalFiltered : instructionPageSize;
                        const totalPages = pageSizeVal === 0 ? 1 : Math.max(1, Math.ceil(totalFiltered / pageSizeVal));
                        if (dir === 'first') instructionPage = 1;
                        else if (dir === 'prev' && instructionPage > 1) instructionPage--;
                        else if (dir === 'next' && instructionPage < totalPages) instructionPage++;
                        else if (dir === 'last') instructionPage = totalPages;
                        renderInstructionList(allInstructions);
                }

                // Instruction filtering & sorting enhancements
                function getFilteredInstructions(list) {
                    const nameFilter = (document.getElementById('instruction-filter').value || '').toLowerCase();
                    const categoryFilter = (document.getElementById('instruction-category-filter')?.value || '');
                    const sizeFilter = (document.getElementById('instruction-size-filter')?.value || '');
                    let filtered = list.filter(i => i.name.toLowerCase().includes(nameFilter));
                    if (categoryFilter) filtered = filtered.filter(i => i.category === categoryFilter);
                    if (sizeFilter) filtered = filtered.filter(i => i.sizeCategory === sizeFilter);
                    const sortSelect = document.getElementById('instruction-sort');
                    const sortVal = sortSelect ? sortSelect.value : 'name-asc';
                    const cmp = (a,b, key, dir='asc') => {
                        if (a[key] === b[key]) return 0;
                        return (a[key] < b[key] ? -1 : 1) * (dir === 'asc' ? 1 : -1);
                    };
                    switch(sortVal) {
                        case 'name-desc': filtered.sort((a,b)=>cmp(a,b,'name','desc')); break;
                        case 'size-asc': filtered.sort((a,b)=>cmp(a,b,'size','asc')); break;
                        case 'size-desc': filtered.sort((a,b)=>cmp(a,b,'size','desc')); break;
                        case 'mtime-asc': filtered.sort((a,b)=>cmp(a,b,'mtime','asc')); break;
                        case 'mtime-desc': filtered.sort((a,b)=>cmp(a,b,'mtime','desc')); break;
                        case 'category': filtered.sort((a,b)=>cmp(a,b,'category','asc') || cmp(a,b,'name','asc')); break;
                        default: // name-asc
                            filtered.sort((a,b)=>cmp(a,b,'name','asc'));
                    }
                    return filtered;
                }

    async function loadInstructions() {
            const listEl = document.getElementById('instructions-list');
            listEl.innerHTML = 'Loading...';
            try {
                // Load categories first to populate the dropdown
                await loadInstructionCategories();
                
                const res = await fetch('/api/instructions');
                const data = await res.json();
                if (!data.success) throw new Error();
                                allInstructions = data.instructions || [];
                                instructionPage = 1; // reset page whenever we reload
                                renderInstructionList(allInstructions);
            } catch (e) {
                listEl.innerHTML = '<div class="error">Failed to load instructions</div>';
            }
        }

        async function loadInstructionCategories() {
            try {
                const res = await fetch('/api/instructions/categories');
                if(!res.ok) throw new Error('http '+res.status);
                const data = await res.json();
                // Accept shapes: {success:true,categories:[{name,count}]}, {success:true,data:{categories:[...]}}
                let cats = data.categories || data.data?.categories || [];
                if(Array.isArray(cats) && cats.length && typeof cats[0] === 'string') {
                    cats = cats.map(n=>({ name:n, count: undefined }));
                }
                if(!Array.isArray(cats)) cats = [];
                const select = document.getElementById('instruction-category-filter');
                if(select){
                    select.innerHTML = '<option value="">All Categories</option>';
                    cats.forEach(cat => {
                        if(!cat || !cat.name) return;
                        const option = document.createElement('option');
                        option.value = cat.name;
                        option.textContent = cat.count != null ? `${cat.name} (${cat.count})` : cat.name;
                        select.appendChild(option);
                    });
                }
                return cats.map(c=>c.name);
            } catch (e) {
                console.warn('Failed to load instruction categories:', e);
                return [];
            }
        }

        function renderInstructionList(instructions) {
                        const filtered = getFilteredInstructions(instructions);
            if (filtered.length === 0) {
                document.getElementById('instructions-list').innerHTML = '<p>No instructions found</p>';
                                buildInstructionPaginationControls(0);
                return;
            }
                        const totalFiltered = filtered.length;
                        let pageItems = filtered;
                        if (instructionPageSize !== 'All') {
                                const start = (instructionPage - 1) * instructionPageSize;
                                const end = start + instructionPageSize;
                                pageItems = filtered.slice(start, end);
                        }

                        const rows = pageItems.map(instr => `
                <div class="session-item" style="background:#fff;">
                    <div class="session-header">
                        <span class="session-id" style="background:#dfe6f1;">${instr.name}</span>
                        <div>
                           <button class="action-btn" onclick="editInstruction('${instr.name}')">‚úè Edit</button>
                           <button class="action-btn danger" onclick="deleteInstruction('${instr.name}')">üóë Delete</button>
                        </div>
                    </div>
                    <div class="stat-row"><span class="stat-label">Category</span><span class="stat-value">${instr.category || '‚Äî'}</span></div>
                    <div class="stat-row"><span class="stat-label">Size</span><span class="stat-value">${instr.size} bytes (${instr.sizeCategory})</span></div>
                    <div class="stat-row"><span class="stat-label">Modified</span><span class="stat-value">${new Date(instr.mtime).toLocaleString()}</span></div>
                </div>`).join('');
            document.getElementById('instructions-list').innerHTML = rows;
                        buildInstructionPaginationControls(totalFiltered);
        }

        function filterInstructions() {
                        instructionPage = 1; // reset to first page on filter change
                        renderInstructionList(allInstructions);
        }

        function showCreateInstruction() {
            instructionEditing = null;
            document.getElementById('instruction-editor-title').textContent = 'New Instruction';
            document.getElementById('instruction-filename').value = '';
            document.getElementById('instruction-filename').disabled = false;
            document.getElementById('instruction-content').value = '{\n  "description": "New instruction"\n}';
            document.getElementById('instruction-editor').classList.remove('hidden');
            document.getElementById('instruction-filename').focus();
            instructionOriginalContent = document.getElementById('instruction-content').value;
            updateInstructionEditorDiagnostics();
        }

        async function editInstruction(name) {
            try {
                const res = await fetch('/api/instructions/' + encodeURIComponent(name));
                const data = await res.json();
                if (!data.success) throw new Error();
                instructionEditing = name;
                document.getElementById('instruction-editor-title').textContent = 'Edit Instruction: ' + name;
                document.getElementById('instruction-filename').value = name;
                document.getElementById('instruction-filename').disabled = true;
                document.getElementById('instruction-content').value = JSON.stringify(data.content, null, 2);
                document.getElementById('instruction-editor').classList.remove('hidden');
                instructionOriginalContent = JSON.stringify(data.content, null, 2);
                updateInstructionEditorDiagnostics();
            } catch (e) {
                showError('Failed to load instruction');
            }
        }

        function cancelEditInstruction() {
            document.getElementById('instruction-editor').classList.add('hidden');
            const diff = document.getElementById('instruction-diff-container');
            if(diff) diff.classList.add('hidden');
            instructionOriginalContent='';
        }

        async function loadInstructions() {
                const listEl = document.getElementById('instructions-list');
                listEl.innerHTML = 'Loading...';
                try {
                    // Load categories first to populate the dropdown (ignore errors; we'll derive later if needed)
                    const catNames = await loadInstructionCategories();
                    const res = await fetch('/api/instructions');
                    if(!res.ok) throw new Error('http '+res.status);
                    const data = await res.json();
                    if (!data.success && !data.data) throw new Error();
                    // Accept shapes: {instructions:[...]}, {data:{instructions:[...]}}
                    const rawList = data.instructions || data.data?.instructions || [];
                    allInstructions = Array.isArray(rawList) ? rawList : [];
                    // If categories endpoint failed / returned empty, derive from instruction list
                    if(!catNames.length) {
                        try {
                            const select = document.getElementById('instruction-category-filter');
                            if(select){
                                const derived = Array.from(new Set(allInstructions.map(i=>i.category).filter(Boolean))).sort();
                                derived.forEach(n=>{
                                    const opt = document.createElement('option');
                                    opt.value = n; opt.textContent = n; select.appendChild(opt);
                                });
                            }
                        } catch(_) { /* ignore */ }
                    }
                    instructionPage = 1; // reset page whenever we reload
                    renderInstructionList(allInstructions);
                } catch (e) {
                    console.warn('loadInstructions error', e);
                    listEl.innerHTML = '<div class="error">Failed to load instructions</div>';
                }
            }
        
            // Re-introduced after patch: formatInstructionJson utility (was accidentally truncated)
            function formatInstructionJson(){
                const ta = document.getElementById('instruction-content');
                if(!ta) return;
                try {
                    const parsed = JSON.parse(ta.value);
                    ta.value = JSON.stringify(parsed, null, 2);
                    updateInstructionEditorDiagnostics();
                } catch { showError('Cannot format: invalid JSON'); }
            }

        function applyInstructionTemplate(){
            const ta = document.getElementById('instruction-content');
            // Provide a minimal enriched template; preserve user edits if already non-empty & ask confirmation.
            if(ta.value.trim() && !confirm('Replace current content with template?')) return;
            const template = {
                schemaVersion: '1.0.0',
                title: 'Sample Instruction',
                description: 'Describe purpose and scope.',
                category: 'general',
                owner: 'you@example.com',
                tags: ['sample','template'],
                body: 'Detailed instruction content here.',
                governance: { version: 1 },
                metadata: { createdBy: 'admin-ui', createdAt: new Date().toISOString() }
            };
            ta.value = JSON.stringify(template, null, 2);
            updateInstructionEditorDiagnostics();
        }

        function toggleInstructionDiff(){
            const container = document.getElementById('instruction-diff-container');
            if(container.classList.contains('hidden')){
                buildInstructionDiff();
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        function buildInstructionDiff(){
            const original = (instructionOriginalContent||'').split(/\r?\n/);
            const current = document.getElementById('instruction-content').value.split(/\r?\n/);
            // Simple line diff (LCS not required for lightweight enrichment)
            const max = Math.max(original.length, current.length);
            const out = [];
            for(let i=0;i<max;i++){
                const o = original[i];
                const c = current[i];
                if(o===c){
                    if(o!==undefined) out.push('  '+o);
                } else {
                    if(o!==undefined) out.push('- '+o);
                    if(c!==undefined) out.push('+ '+c);
                }
            }
            document.getElementById('instruction-diff').textContent = out.join('\n');
        }

        function hashString(str){
            // FNV-1a 32-bit for quick client hash
            let h=0x811c9dc5;
            for(let i=0;i<str.length;i++){
                h ^= str.charCodeAt(i);
                h = (h + (h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))>>>0; // *16777619
            }
            return ('0000000'+h.toString(16)).slice(-8);
        }

        function updateInstructionEditorDiagnostics(){
            const diag = document.getElementById('instruction-diagnostics');
            const ta = document.getElementById('instruction-content');
            if(!diag || !ta) return;
            const raw = ta.value;
            const bytes = new Blob([raw]).size; // approximate size
            let valid=false; let parsed; let errorMsg='';
            try { parsed = JSON.parse(raw); valid=true; } catch(e){ errorMsg = (e&&e.message)||'Invalid JSON'; }
            const hash = valid ? hashString(raw) : '--------';
            // Basic field guidance
            const required = ['title','description'];
            const missing = []; if(valid){ for(const f of required){ if(!(f in parsed)) missing.push(f); } }
            let html = `<strong>Status:</strong> ${valid?'<span style="color:#2c7;">Valid JSON</span>':'<span style="color:#e74c3c;">Invalid</span>'}`;
            html += ` ‚Ä¢ <strong>Size:</strong> ${bytes} bytes`;
            html += ` ‚Ä¢ <strong>Hash:</strong> ${hash}`;
            if(valid && missing.length) html += ` ‚Ä¢ <strong>Missing fields:</strong> ${missing.join(', ')}`;
            if(!valid) html += `<br/><code style="color:#e74c3c;">${escapeHtml(errorMsg)}</code>`;
            if(instructionEditing && instructionOriginalContent){
                if(raw!==instructionOriginalContent) html += ' ‚Ä¢ <em>Modified</em>'; else html += ' ‚Ä¢ <em>Unchanged</em>';
            }
            diag.innerHTML = html;
            const diffVisible = !document.getElementById('instruction-diff-container').classList.contains('hidden');
            if(diffVisible) buildInstructionDiff();
        }

        async function deleteInstruction(name) {
            if (!confirm('Delete instruction ' + name + '?')) return;
            try {
                const res = await fetch('/api/instructions/' + encodeURIComponent(name), { method:'DELETE' });
                const data = await res.json();
                if (data.success) { showSuccess('Deleted'); loadInstructions(); } else { showError(data.error || 'Delete failed'); }
            } catch { showError('Delete failed'); }
        }

        function startAutoRefresh() {
            refreshInterval = setInterval(() => {
                if (currentSection === 'overview') {
                    loadOverviewData();
                } else if (currentSection === 'sessions') {
                    loadSessions();
                } else if (currentSection === 'maintenance') {
                    loadMaintenanceStatus();
                }
            }, 30000); // Refresh every 30 seconds
        }

        // Build metadata loader
    (async function fetchBuildMeta(){
            try {
        // Cache bust query param to avoid any intermediary caching of status response
        const r = await fetch('/api/status?t=' + Date.now());
                const j = await r.json();
                const el = document.getElementById('buildMeta');
                const ver = j.version || '?.?.?';
                const commit = j.build ? `<span class=\"build-badge\">${j.build}</span>` : '';
                const bt = j.buildTime ? new Date(j.buildTime).toLocaleString() : 'unknown';
                el.innerHTML = `Version <strong>${ver}</strong> ${commit} ‚Ä¢ Built ${bt}`;
            } catch { const el = document.getElementById('buildMeta'); if(el) el.textContent='Build metadata unavailable'; }
        })();

        function showError(message) {
            // Remove existing notifications
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.admin-container').insertBefore(errorDiv, document.querySelector('.admin-container').firstChild.nextSibling);
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            // Remove existing notifications
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
            
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.admin-container').insertBefore(successDiv, document.querySelector('.admin-container').firstChild.nextSibling);
            
            setTimeout(() => successDiv.remove(), 5000);
        }

        // Utility functions
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (days > 0) return `${days}d ${hours}h ${minutes}m`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }

        function formatBytes(bytes) {
            const sizes = ['B', 'KB', 'MB', 'GB'];
            if (bytes === 0) return '0 B';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
        }
        function escapeHtml(str) {
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
    </script>
</body>
</html>
